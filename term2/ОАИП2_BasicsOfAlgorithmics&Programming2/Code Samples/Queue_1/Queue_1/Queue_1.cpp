// однонаправленная очередь
#include <locale.h>
#include <stdio.h>
#include <stdlib.h>
#include <conio.h>
#include <string.h>
struct zap
{
	char inf[50];
	zap *nx;
};
void add(zap **, zap **);
void del(zap **, zap **);
void del_any(zap **, zap **, char *);
void show(zap *);
void sort(zap **);
int main()
{
	setlocale(LC_ALL, "Russian");
	zap *h, *t;
	char l, *st;
	st = (char *)malloc(10);
	h = t = NULL;

	while (1)
	{
		puts("вид операции: 1-создать очередь");
		puts("              2-вывод содержимого очереди");
		puts("              3-удаление элемента из очереди");
		puts("              4-удаление любого элемента из очереди");
		puts("              5-сортировка очереди");
		puts("              0-окончить");
		fflush(stdin);
		switch (getch())
		{
		case '1': add(&h, &t); break;    // добавление в хвост очереди
		case '2': show(h); break;        // просмотр с головы очереди
		case '3': if (h) del(&h, &t); break; // удаление с головы очереди
		case '4': if (h)                 // удаление с любого места в очереди 
		{
					  fflush(stdin);
					  puts("Введите информацию для удаления ");
					  gets(st);
					  del_any(&h, &t, st);
		} break;
		case '5': if (h) sort(&h); break;
		case '0': return 0;
		default: printf("Ошибка, повторите \n");
		}
	}
}

// функция создания очереди
void add(zap **h, zap **t)
{
	zap *n;
	puts("Создание очереди \n");
	do
	{
		if (!(n = (zap *)calloc(1, sizeof(zap))))
		{
			puts("Нет свободной памяти");
			return;
		}
		puts("Введите информацию в inf");
		scanf("%s", n->inf);
		if (!*h)        // очерель еще не создана
			*t = *h = n;        // устанавливаем оба указателя (голова и хвост)
		// на единственный элемент очереди
		else            // очередь уже создана
		{
			(*t)->nx = n;   // добавляем очередной элемент в хвост очереди 
			*t = n;         // передвигаем указатель на хвост
		}
		puts("Продолжить (y/n): ");
		fflush(stdin);
	} while (getch() == 'y');
}

// функция вывода содержимого очереди
void show(zap *h)
{
	puts("Вывод содержимого очереди \n");
	if (!h)
	{
		puts("Очередь пуста");
		return;
	}
	do
	{
		printf("%s\n", h->inf);
		h = h->nx;
	} while (h);
	return;
}

// функция удаления первого элемента очереди
void del(zap **h, zap **t)
{
	zap *p;
	if (*t == *h)              // в очереди только один элемент
	{
		free(*h);
		*t = *h = nullptr;       // очередь пуста
		return;
	}
	p = (*h)->nx;
	free(*h);             // удаление первого элемента из очереди
	*h = p;
}

// функция удаления любого элемента очереди
void del_any(zap **h, zap **t, char *st)
{
	zap *p, *pr;          // указатели: на анализируемый элемент и 
	// предыдущий ему элемент очедеди
	if (*t == *h &&        // в очереди только один элемент
		(!strcmp((*h)->inf, st) || *st == '\0'))
	{
		free(*t);
		*t = *h = nullptr;             // очередь пуста
		return;
	}

	while (*h && !strcmp((*h)->inf, st)) // удаление всех элементов st
		// с головы очереди
	{
		p = *h;           // сохраняем адрес удаляемого элемента
		*h = (*h)->nx;    // премещение указателя на голову очереди
		// на следующий элемент
		free(p);        // удаление элемента          

	}
	p = (*h)->nx;       // следующий за элементом головы
	pr = (*h);          // элемент перед ним	
	while (p)
	{
		if (!strcmp(p->inf, st)) // удаление всех элементов st
			// с головы очереди
		{
			pr->nx = p->nx;    // исключение из очереди удаляемого элемента
			free(p);         // удаление из очереди          
			p = pr->nx;        // премещение головы на следующий элемент
		}
		else
		{
			p = p->nx;        // переход к новому элементу очереди 
			pr = pr->nx;
		}
	}
	p = *h;
	while (p->nx) p = p->nx; // проход по новой очереди до конца
	*t = p;                 // коррекция адреса хвоста очереди
}

// функция сортировки содержимого очереди
void sort(zap **h)
{
	zap *s1, *s2, *s3, *s4, *hh = nullptr;
	s1 = s3 = *h;                           // ссылка на голову очереди
	s4 = (zap *)calloc(1, sizeof(zap));
	for (; s1->nx; s1 = s1->nx)            // выбор исходного элемента очереди
	{
		for (s2 = s1->nx; s2; s3 = s3->nx, s2 = s2->nx) // перебор последующих за S1
		{
			if (s2 == s1->nx) s3 = s1;          // S3-элемент расположенный перед S2
			if (strcmp(s1->inf, s2->inf)>0)   // найдено новое меньшее значение
			{
				s3->nx = s2->nx;
				s2->nx = s1;             // элемент с min становится перед S1
				s4->nx = s2;             // S4- элемент расположенный перед S1
				s1 = s2;	               // новый адрес S1- (после замены S1<->S2)
			}
		}
		if (!hh)
		{
			hh = s1;    // модификация текущего указателя на голову очереди
			free(s4);
		}
		s4 = s1;
	}
	*h = hh;              // возврат возможно измененного указателя на голову
	puts("Сортировка выполнена");
}