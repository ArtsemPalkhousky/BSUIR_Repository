#include <stdio.h>
#include <conio.h>
#include <stdlib.h>
#include <locale.h>

//void f(char *, int);

// В командной строке вводится несколько строк.
// В рекурсивной функции для каждой строки выполнить
// реверсивный переворот последнего слова

// asdf "abc d efg 12345 qwert"  // две строки: первая - слово, второе - кавычки
//
//int main(int argc, char *argv[]) // 1-how many inform // massv of points 
//{ 
//  setlocale(LC_ALL, "Russian");
//  int i;
//  for(i=1;i<argc;i++)  // обработка очередной строки         начинаем с 1!!!!!! вся инфа с 1!!! 0 хранит адрес exe-шника
//  {
//	printf("\n исходная строка:        %s", argv[i]);
//	f(argv[i],0);      // передача в функцию argv строки argv[i]
//	printf("\n преобразованная строка: %s", argv[i]);
//  }
//  puts("\n\n");
//  return 0;
//}
//
//
//void f(char *s,int i) // получает строку 
//{
//  static int j;
//  char c;
//  if (*(s+i)==' ') 
//	  j=i+1;  // запоминаем позицию ' ' перед словом (т.е. тем самым найдем начало (j) последнего слова)
//  if (*(s+i))      // если не конец строки
//    { 
//	  c=*(s+i++);    // чтение символа из строки (строка как бы дублируется в локальную с)
//      f(s,i);        // рекурсия
//     }
//  else 
//	  return;     // строка окончена
//     printf("\n i= %d  j= %d",i,j); 
//  if (*(s+j))  *(s+j++)=c;      // реверс слова
//  if (i==1) j = 0;
//}




//================================================================================

#include <string.h>
int main(int argc, char *argv[], char *env[]) // в данном случае в env отправляется системная информация argc к нему не относится
{
  setlocale(LC_ALL, "Russian");
  int t;
  for (t=0;env[t];t++) //двигаемся до тех пор пока не найдем слово PATH
  {
	  if ( strstr (env[t],"PATH")) // strstr информация PATH
       printf("%s\n",env[t]);
  }
  return 0;
}




//=================================================================================
// В командной строке вводятся слова состоящие из чисел и знаков
// '+' и '-', например 1+39-5-8+23=?  44-2-13+99=?

// перевод цифровой символьной строки в signed int
int atoi(char *ss)
{
	int n, i = 0, znak;
	while (ss[i] == ' ') i++;
	if (!ss[i]) return 0;   // в строке одни пробелы
	znak = (ss[i] == '-') ? -1 : 1;
	if (ss[i] == '+' || ss[i] == '-')  // пропуск знака
		i++;
	for (n = 0; ss[i] >= '0' && ss[i] <= '9'; i++)  // выбор цифр числа из строки
		n = 10 * n + (ss[i] - '0');
	return znak*n;    // возврат числа со знаком
}


int main(int argv,char *argc[]) // argv & argc  вводятся с параметров (в системе) программа вызывается в командной строке, выполняется и выводится на экран
{
  setlocale(LC_ALL, "Russian");
  int n,i,j,sum;
  char *s,c;
  for(i=1;i<argv;i++)             // считывание очередного слова из ком. стр.
  { sum=n=0; c=' ';
    s=(char *)calloc(1,sizeof(char)); // строка для одного символа
    for(j=0;*(argc[i]+j);j++)     // проход по выбранному слову
    { switch(*(argc[i]+j))
      { case '?': break;
	    case '=': case '-':	case '+': 
		  if (c==' ') sum=atoi(s);  // первичная сумма
		  if (c=='+') sum+=atoi(s); // увеличение результата
		  if (c=='-') sum-=atoi(s); // уменьшение результата
		  free(s);
		  n=0;
		  s=(char *)calloc(1,sizeof(char));
		  c=*(argc[i]+j);  // запоминаем знак  +  -
		  break;      // сброс числа букв для ввода нового слова
	    default : n++;
		  s=(char *)realloc(s,(n+1)*sizeof(char)); // строка увеличи-
							                       // вается на 1 букву
		  s[n-1]=*(argc[i]+j);	   // введена буква
		  s[n]='\0';
      }
    }
    free(s);
    printf("\n %20s  ответ  %d",argc[i],sum);
  }
  puts("\n");
  return 0;
}
