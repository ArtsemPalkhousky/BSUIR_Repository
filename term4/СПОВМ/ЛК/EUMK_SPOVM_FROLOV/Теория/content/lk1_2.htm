<!-- (C) 2011-2012 V.Prytkov, V. Suponev, A.Uvarov. BSUIR -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//RU">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1251">
<META HTTP-EQUIV="Content-Language" CONTENT="ru">
<link rel="stylesheet" type="text/css" href="../css/style.css" />

<title>Лекция №2. Понятие  операционной системы.</title>
<base target="_top">
</HEAD><BODY>
  <p align="center"><strong>Понятие  операционной системы</strong></p>
  <p><em>Операционная  система. Классификация ОС. ОС реального времени. Микроядерные и монолитные ОС.  Структура ОС. Ядро, командный процессор, подсистема ввода-вывода, система  управления памятью, файловая система. Принципы построения ОС. Понятие  виртуальной машины. Безопасность операционных систем. Понятие системных  вызовов. Системные вызовы стандарта </em><em>POSIX</em><em>.  Интерфейс </em><em>Win</em><em>32 </em><em>API</em><em>.</em></p>
  <p>Первые программы разрабатывались непосредственно в  машинных кодах. Для этого требовалось владеть в совершенстве архитектурой как  самого микропроцессора, так и системы на его основе. Очевидно, что переход к  новой системе был связан с большими затратами на обучение. По мере развития  вычислительной техники стали выделять наиболее часто встречающиеся операции и  создавать для них программные модули, которые затем можно использовать в  разрабатываемом ПО. Так, в 50-х гг. при разработке первых систем  программирования вначале создавали модули для операций ввода-вывода, после &ndash;  для вычисления математических операций и функций. Дальнейшее развитие привело к  появлению трансляторов высокого уровня, которые могли подставлять вместо  операторов необходимые вызовы библиотечных функций. Количество библиотек возрастало.  В итоге у разработчиков прикладного ПО отпала необходимость в подробном  владении архитектурой системы. Они могли обращаться к программной подсистеме с  соответствующими вызовами и получать от нее необходимые функции и сервисы. Эта  программная подсистема и является ОС.</p>
  <p><strong>Основные  составляющие современной ОС</strong> &ndash; это  ядро, подсистема ввода-вывода, командный процессор, система управления памятью,  файловая система. <strong>Ядро</strong> обеспечивает  основной набор базовых функций по управлению задачами и ресурсами, их  синхронизацией и взаимодействием. <strong>Командный  процессор</strong> обеспечивает прием и обработку команд, вызов соответствующих  сервисов ОС по запросу пользователя.</p>
  <p><strong>Подсистема  ввода-вывода</strong> обеспечивает выполнение  задач по вводу-выводу данных с внешними устройствами. Наличие этих библиотек в  ОС позволяет не встраивать их средствами систем программирования в каждую из  разрабатываемых программ. Системы программирования только генерируют обращения  к системному коду ввода-вывода и выполняют подготовку данных. Подсистема ВВ  является одной из самых сложных в силу большого числа различных устройств  ввода-вывода. При этом недостаточно обеспечить эффективное управление,  требуется еще и создать удобный и эффективный виртуальный интерфейс,  позволяющий прикладным программистам абстрагироваться от специфики устройств. С  другой стороны, требуется обеспечение доступа к устройствам ВВ множества  параллельно выполняющихся задач. Некоторые из программ ВВ являются независимыми  от устройств, и их можно применять ко многим устройствам ВВ, другое ПО, в т.ч.  драйверы устройств, предназначены для конкретных устройств ВВ.</p>
  <div class="imageTip"><img src="../images/1sem_theory_p2_clip_image002.gif" alt="1" width="589" height="246" hspace="12" /><br />Файл &ndash; набор данных, организованных в виде совокупности записей  одинаковой структуры.</div> <strong>Файловая система </strong>определяет  способ организации данных на диске или ином носите информации и предоставляет  пользователю возможность иметь дело с логическим уровнем структур данных и  операций. Все современные ОС имеют соответствующие системы управления файлами.  Она является основной в большинстве современных ОС. Благодаря СУФ все системные  обрабатывающие программы связываются по данным. СУФ решает проблему  централизованного распределения дискового пространства и управления  данными.&nbsp; СУФ предоставляют пользователям  широкие сервисные возможности по работе с файлами и каталогами, в тоже время  скрывая от пользователя особенности дисков и других устройств ВВ. В UNIX важным является понятие монтирования дисков. Корневая  файловая система и файловая система на диске существуют отдельно и никак не  связаны между собой. При этом файлы гибкого диска нельзя использовать,  поскольку&nbsp; для них неопределен путь. UNIX не позволяет присоединять к пути название диска или  его номер, поскольку это приводит к нежелательной для ОС жесткой зависимости от  устройств. Системный вызов mount позволяет  монтировать (присоединять) файловую систему гибкого диска к корневой файловой системе  в указанное место. Еще одно понятие UNIX &ndash;  специальные файлы. На самом деле это устройства ввода-вывода, которые выглядят  как файлы. </p>
  <p><strong>Классификация  ОС:</strong></p>
  <p>ОС классифицируются по назначению, по режиму обработки  задач, по способу взаимодействия с системой, по способу построения. Самый широкий  ряд ОС возникает при классификации по назначению, поскольку сколько видов  вычислительной техники &ndash; столько и видов ОС: ОС мэйнфреймов, серверные ОС,  многопроцессорные, для ПК, ОС реального времени, для переносимых компьютеров и  встроенных систем, для смарт-карт.</p>
  <p><strong>Мэйнфреймы</strong> отличаются от ПК по возможностям ввода-вывода,  позволяя зачастую обрабатывать терабайты данных. ОС мэйнфреймов ориентированы  на обработку множества одновременных заданий с большим количеством операций ввода-вывода.  Как правило, предлагают три вида обслуживания: пакетная обработка, обработка  транзакций (групповых операций) и разделение времени. В случае пакетной  обработки задачи обрабатываются без участия пользователей. Например, составление  разнообразных отчетов может быть выполнено в пакетном режиме. В случае  обработки транзакций выполняется большое число маленьких запросов, таких как  бронирование билетов, операции с кредитными карточками и т.д. Запросы невелики,  но система одновременно обрабатывает сотни и тысячи таких запросов в секунду. В  режиме разделения времени система позволяет множеству удаленных пользователей  одновременно выполнять задачи на одной машине. Типичным примером является  многопользовательская база данных. Пример ОС для мэйнфрейма &ndash; OS/390.</p>
  <p><strong>Серверы</strong> одновременно обслуживают множество пользователей,  позволяя им делить между собой программные и аппаратные ресурсы. Серверы  предоставляют возможность работы с печатающими устройствами, файлами,  Интернетом. На серверах хранятся Web-страницы и  обрабатываются входящие запросы. UNIX, Windows 2000, Linux &ndash; примеры  серверных ОС. Для работы с системами, в которых объединены несколько  процессоров, требуются специальные ОС, часто <strong>многопроцессорные ОС</strong> представляют собой серверные ОС со  специальными возможностями связи. Основная задача <strong>ОС для ПК</strong> &ndash; предоставление удобного интерфейса пользователю. Эти ОС  используются для доступа к Интернету, работы с текстом, электронными таблицами  и т.д. Все клоны ОС Windows, Linux.</p>
  <p><strong>ОС реального  времени</strong> используются, когда процессы,  которыми управляет машина, например, сборочной линией на производстве, должны  удовлетворять жестким временным требованиям. Если действия должны происходить  строго в указанный диапазон времени &ndash; это жесткая СРВ, если же время от времени  возможны пропуски сроков выполнения операции, например, цифровое аудио и  мультимедийные системы, то это гибкая СРВ. Примерами СРВ являются VxWorks и QNX. <strong>Для карманных компьютеров, а также  встроенных систем</strong>, управляющих широким спектром бытовых и прочих устройств  (телевизоры, микроволновые печи, мобильные телефоны) используются встроенные  ОС. Они могут обладать характеристиками ОС реального времени, но имеют меньший  размер, память, ограниченную мощность. Примерами являются PalmOS и Windows  CE. <strong>Смарт-карта</strong> &ndash; устройство размером с кредитную карту, содержащее центральный процессор.  Часто ОС для смарт-карт являются патентованными системами. Часть смарт-карт  являются Java-ориентированными, у них ПЗУ  содержит интерпретатор виртуальной Java-машины  (JVM). Некоторые из смарт-карт позволяют управлять  несколькими апплетами одновременно, что приводит к многозадачности и  необходимости планирования, требуется управление ресурсами и защитой.&nbsp; Все эти задачи выполняет, как правило,  примитивная ОС, находящаяся на смарт-карте.</p>
  <p>В <strong>монолитных ОС</strong> все части системы сильно связаны между собой. Поэтому изменение или удаление  какой-либо части требует хорошего знания всей архитектуры ОС и может повлечь  необходимость изменения остальных модулей. При этом возникает ряд проблем,  связанных&nbsp; с тем, что функции макроядра  работают в едином адресном пространстве. Это вызывает опасность возникновения  конфликтов, а также сложность подключения новых драйверов. Структура как  таковая отсутствует. ОС представляет собой набор процедур, каждая из которых  может вызывать при необходимости любые другие. Для построения такой системы  компилируются все отдельные процедуры, с помощью компоновщика связываются в  единый объектный файл. Поскольку для каждой процедуры доступны все другие,  практически отсутствует сокрытие деталей реализации. Монолитные системы могут  поддерживать механизм прерываний. В этом случае предполагается некоторая  структура ОС: На верхнем уровне лежит главная программа, которая вызывает  требуемую служебную процедуру. Ниже идет набор служебных процедур, выполняющих  системные вызовы. На самом низу лежат утилиты, обслуживающие системные процедуры.</p>
  <p><strong>Многоуровневые  системы</strong> имеют организацию в виде  иерархии уровней. Первой подобной системой была система THE, созданная Дейкстрой в 1968 году. Она содержала 6 уровней.  0 &ndash; распределение процессора и многозадачность, 1 &ndash; управление памятью, 2 &ndash;  связь оператор-процесс, 3 &ndash; управление ВВ, 4 &ndash; программы пользователя, 5 &ndash;  оператор. Уровень 0 занимался распределением времени процессора, переключая  процессы при возникновении прерывания или срабатывании таймера. Выше этого  уровня система состояла из последовательных процессов, каждый из которых можно  было программировать не беспокоясь о том, что на одном процессоре запущено  несколько процессов. Т.е. уровень 0 обеспечивал базовую многозадачность  процессора. Уровень 1 управлял памятью. Он выделял процессам память в ОЗУ и на  магнитном барабане, если ОЗУ не хватало. По мере необходимости страницы с  барабана попадали в ОЗУ. Выше этого уровня процессам не было необходимости  заботиться о том, где они находятся &ndash; в ОЗУ или на барабане. Уровень 2 управлял  связью между консолью оператора и процессами. Все процессы выше этого уровня  имели свою собственную консоль оператора. Уровень 3 управлял устройствами ВВ и  буферизацией данных. Любой процесс выше 3 уровня работал уже не с конкретными  устройствами ВВ, а с абстрактными УВВ с удобными для пользователя  характеристиками. Дальнейшее обобщение концепции многоуровневых систем было  сделано в системе MULTICS. Уровни представляли серию  концентрических колец, внутренние кольца являлись более привилегированными, чем  внешние. Если внешнее кольцо хотело вызвать процедуру из кольца внутреннего,  выполнялся эквивалент системного вызова с тщательной проверкой параметров и  возможности доступа. Многоуровневые системы просты в реализации. При разработке  каждого из уровней нет необходимости знать устройство более низкого уровня,  достаточно знать, как к обратиться к функциям этого уровня. Упрощается  тестирование. Поскольку отладка идет снизу вверх послойно, то можно быть  уверенным, что возникшая ошибка находится именно в тестируемом слое. Упрощается  модификация систем. При необходимости достаточно изменить функциональность  одного из уровней, не меняя остальных. Недостаток подобных систем в том, что  запрос от пользователя вынужден проходить все слои поочередно, аналогично и  результат запроса передается от уровня к уровню. Кроме того весьма непросто  разделить систему на нужное количество уровней, определить их иерархию и  разграничить возможности каждого слоя.</p>
  <p><strong>Виртуальные  машины</strong> развились на основе проработки  двух принципов: 1. система с разделением времени обеспечивает многозадачность,  2. расширенную машину с более удобным интерфейсом, чем предоставляемый  непосредственно оборудованием. Первая ОС такого рода VM/370. Монитор виртуальной машины работает с  оборудованием и обеспечивает многозадачность, предоставляя верхнему слою не  одну, а несколько виртуальных машин. В отличие от других ОС, эти ВМ не являются  расширенными, а представляют собой точную копию аппаратуры, включая режимы ядра  и пользователя, ВВ, прерывания и т.д. В итоге на каждой из таких ВМ может быть  запущена любая ОС. Когда программа выполняет системный вызов, он прерывает ОС  на виртуальной машине, а не на VM/370. В случае  ВМ многозадачность реализуется на уровне ядра, и она отделена от ОС  пользователя. Недостаток в том, что снижается эффективность, кроме того,  подобные системы очень громоздки. Однако имеется возможность использования на  одной машине программ, написанных для разных ОС. Сейчас ВМ используются  несколько в ином контексте. Например, для организации нескольких операционных  сред. Примером этого является VDM-машина (Virtual DOS machine) &ndash; защищенная подсистема,  предоставляющая полную среду MS-DOS и консоль для выполнения ее приложений. Одновременно  может выполняться практически произвольное число VDM-сессий. Однако здесь пользователю предоставляется  виртуальный процессор 8086, не обладающий функциональностью реальной системы на  уровне Pentium. Понятие виртуальной машины используется и при  построении Java-апплетов. Компилятор Java строит код для JVM. Этот код может быть выполнен на любой платформе, для  которой существует интерпретатор JVM. </p>
  <p>Развитие концепции ВМ привело к появлению систем,  обеспечивающих пользователя абсолютной копией реального компьютера, но с  подмножеством ресурсов. На нижнем уровне в режиме ядра работает программа,  называемая <strong>экзоядром</strong>, распределяющая  ресурсы для ВМ и защиту их использования.&nbsp;  Каждая ВМ на уровне пользователя может работать со своей собственной ОС,  с тем отличием, что она ограничена предоставленным набором ресурсов.  Преимущество схемы в том, что не требуется таблицы преобразования адресов ВМ в  реальные адреса диска, так как каждой ВМ выделяется свой блок адресов. </p>
  <p>В современных ОС наблюдается тенденция в сторону переноса  кода в верхние уровни, оставляя в режиме ядра минимально необходимые функции,  т.н. <strong>микроядро</strong>. Микроядро  функционирует в привилегированном режиме и обеспечивает взаимодействие между  программами, планирование использование процессора, первичную обработку  прерываний, операции ввода-вывода и базовое управление памятью. Остальные  функции, характерные для ОС, проектируются как модульные дополнения-процессы,  взаимодействующие между собой путем передачи сообщений через микроядро.  Реализуется клиент-серверная схема взаимодействия. Получая запрос на операцию,  пользовательский процесс <strong>(клиент)</strong> посылает запрос обслуживающему процессу <strong>(серверу</strong>),  который выполняет обработку и возвращает ответ.<br />
    <div class="imageTip"><img src="../images/1sem_theory_p2_clip_image004.gif" alt="2" width="573" height="93" hspace="12" /></div> <br />
    Благодаря разделению ОС на части, каждая из которых  управляет одним элементом системы, все части становятся маленькими и  управляемыми. Серверные процессы ничем принципиально не отличаются от  клиентских. В таких системах можно без перезагрузки добавлять и удалять из  системы драйверы устройств, файловые системы и т.д. Поскольку все серверы работают  как процессы в режиме пользователя, они не имеют прямого доступа к  оборудованию, что повышает устойчивость системы к сбоям. Некоторые функции ОС,  например, загрузка команд в регистры устройств ВВ, практически невозможно выполнить  из программ в пространстве пользователя. Одно из решений заключается в том, что  критические серверные процессы (например, драйверы устройств), запускаются в  режиме ядра, но общаются с другими процессами по традиционной схеме путем  передачи сообщений. Преимущество модели клиент-сервер еще и в том, что она  легко адаптируется к распределенным системам. Действительно, поскольку части  независимы, любая из них легко может быть выполнена на удаленной машине, при  этом с точки зрения клиента, происходит то же самое: посылается запрос и  возвращается ответ. Однако затраты на передачу сообщений существенно влияют на  производительность, поэтому требуется очень грамотное разбиение системы на  компоненты.</p>
  <p>Большинство структур имеют как достоинства, так и  недостатки. Как правило, современные ОС комбинируют несколько подходов.  Например, ядро Linux является монолитным с  элементами микроядерной архитектуры. При компиляции ядра можно разрешить  динамическую загрузку/выгрузку многих модулей ядра. Монолитное ядро с  микроядерными элементами имеет и Windows  NT. Компоненты системы располагаются в вытесняемой  памяти и взаимодействуют путем передачи сообщений, что характерно для  микроядерных ОС, однако они работают в едином адресном пространстве и  используют общие структуры данных, что является признаком монолитных ОС.</p>
  <p>Еще один пример смешанной архитектуры &ndash; возможность  запуска ОС с монолитным ядром под управлением микроядра. Например, 4.4BSD и MkLinux,  основанные на микроядре Mach. Микроядро  обеспечивает управление виртуальной памятью и работу низкоуровневых драйверов,  а все остальные функции обеспечиваются монолитным ядром. </p>
  <p><strong>Основные  принципы построения ОС:</strong><br />
    <strong>Частотный  принцип.</strong> Основан на выделении в алгоритмах программ, а в обрабатываемых массивах  действий и данных по частоте использования. Действия и данные, которые часто  используются, располагаются в операционной памяти, для обеспечения наиболее  быстрого доступа. Основным средством такого доступа является организация  многоуровневого планирования. На уровень долгосрочного планирования выносятся  редкие и длинные операции управления деятельностью системы. К краткосрочному  планированию подвергаются часто используемые и короткие операции. Система  инициирует или прерывает исполнение программ, предоставляет или забирает  динамически требуемые ресурсы, и прежде всего центральный процессор и память.</p>
  <p><strong>Принцип  модульности</strong>. Модуль &ndash; это  функционально законченный элемент системы, выполненный в соответствии с принятыми  межмодульными интерфейсами. Модуль по определению предполагает возможность  замены его на любой другой при наличии соответствующих интерфейсов. Чаще всего  при построении ОС разделение на модули происходит по функциональному признаку.  Важное значение при построении ОС имеют привилегированные, повторно входимые и  реентерабельные модули. Привилегированные модули функционируют в  привилегированном режиме, при котором отключается система прерываний, и никакие  внешние события не могут нарушить последовательность вычислений.  Реентерабельные модули допускают повторное многократное прерывание исполнения и  повторный запуск из других задач. Для этого обеспечивается сохранение  промежуточных вычислений и возврат к ним с прерванной точки. Повторно входимые  модули допускают многократное параллельное использование, однако не допускают  прерываний. Они состоят из привилегированных блоков и повторное обращение к ним  возможно после завершения какого-либо из этих блоков. Принцип модульности  отражает технологические и эксплуатационные свойства системы. Максимальный  эффект от использования достигается, если принцип распространяется и на ОС, и  на прикладные программы, и на аппаратуру.</p>
  <p><strong>Принцип  функциональной избирательности</strong>. Этот  принцип подразумевает выделение некоторых модулей, которые должны постоянно  находиться в оперативной памяти для повышения производительности вычислений.  Эту часть ОС называют ядром. С одной стороны, чем больше модулей в ОЗУ, тем  выше скорость выполнения операций. С другой стороны, объем памяти, занимаемой  ядром, не должен быть слишком большим, поскольку в противном случае обработка  прикладных задач будет низкоэффективной. В состав ядра включают модули по  управлению прерываниями, модули для обеспечения мультизадачности и передачи  управления между процессами, модули по распределению памяти и т.д. </p>
  <p><strong>Принцип  генерируемости ОС</strong>. Этот принцип  определяет такой способ организации архитектуры ядра ОС, который позволял бы  настраивать его, исходя из конкретной конфигурации вычислительного комплекса и  круга решаемых задач. Эта процедура выполняется редко, перед достаточно  протяженным периодом эксплуатации ОС. Процесс генерации осуществляется с  помощью специальной программы-генератора и соответствующего входного языка. В  результате генерации получается полная версия ОС, представляющая собой  совокупность системных наборов модулей и данных. Принцип модульности существенно  упрощает генерацию. Наиболее ярко этот принцип используется в ОС Linux, которая позволяет не только генерировать ядро ОС, но  указывать состав подгружаемых, т.н. транзитных модулей. В остальных ОС  конфигурирование выполняется в процессе инсталляции.</p>
  <p><strong>Принцип  функциональной избыточности</strong>. Принцип  учитывает возможность проведения одной и той же операции различными средствами.  В состав ОС могут входить несколько разных мониторов, управляющих тем или иным  видом ресурса, несколько систем управления файлами и т.д. Это позволяет быстро  и достаточно адекватно адаптировать ОС к определенной конфигурации  вычислительной системы, обеспечить максимально эффективную загрузку технических  средств при решении конкретного класса задач и получить при этом максимальную производительность.</p>
  <p><strong>Принцип  умолчания.</strong> Применяется для облегчения организации связи с системами, как на стадии  генерации, так и при работе с системой. Принцип основан на хранении в системе  некоторых базовых описаний, структур процесса, модулей, конфигураций  оборудования и данных, определяющих прогнозируемые объемы требуемой памяти,  времени счета программы, потребности во внешних устройствах, которые  характеризуют пользовательские программы и условия их выполнения. Эту  информацию пользовательская система использует в качестве заданной, если она не  будет заданна или сознательно не конкретизирована. В целом применение этого  принципа позволяет сократить число параметров устанавливаемых пользователем,  когда он работает с системой.</p>
  <p><strong>Принцип  перемещаемости.</strong> Предусматривает  построение модулей, исполнение которых не зависит от места расположения в  операционной памяти. Настройка текста модуля в соответствии с его расположением  в памяти осуществляется либо специальными механизмами, либо по мере ее  выполнения. Настройка заключается в определении фактических адресов, используемых  в адресных частях команды, и определяется применяемым способом адресации и  алгоритмом распределения оперативной памяти, принятой для данной ОС. Она может  быть распределена и на пользовательские программы.</p>
  <p><strong>Принцип виртуализации</strong>.  Принцип позволяет представить структуру системы в виде определенного набора  планировщиков процессов и распределителей ресурсов (мониторов), используя  единую централизованную схему. Концепция виртуальности выражается в понятии  виртуальной машины. Любая ОС фактически скрывает от пользователя реальные  аппаратные и иные ресурсы, заменяя их некоторой абстракцией. В результате  пользователи видят и используют виртуальную машину как достаточно абстрактное  устройство, способное воспринимать их программы, выполнять их и выдавать  результат. Пользователю совершенно не интересна реальная конфигурация  вычислительной системы и способы эффективного использования ее компонентов. Он  работает в терминах используемого им языка и представленных ему&nbsp; виртуальной машиной ресурсов. Для нескольких параллельных процессов  создается иллюзия одновременного использования того, что одновременно в  реальной системе существовать не может. Виртуальная машина может воспроизводить и  реальную архитектуру, однако элементы архитектуры выступают с новыми, либо  улучшенными, характеристиками, зачастую упрощающими работу с системой. Идеальная,  с точки зрения пользователя, машина должна иметь:</p>
  <ul>
    <li>единообразную по  логике работы виртуальную память практически неограниченного объема;</li>
    <li>произвольное  количество виртуальных процессоров, способных функционировать параллельно и  взаимодействовать во время работы; </li>
    <li>произвольное  количество виртуальных внешних устройств, способных получать доступ к памяти  виртуальной машины последовательно или параллельно, синхронно или асинхронно.  Объемы информации не ограничиваются.</li>
  </ul>
  <p>Чем больше виртуальная машина, реализуемая ОС,  приближена к идеальной, т.е. чем больше ее архитектурно-логические  характеристики отличны от реальных, тем большая степень виртуальности  достигнута. ОС  строится как иерархия вложенных друг в друга виртуальных машин. Нижним уровнем  программ является аппаратные средства машин. Следующим уровнем уже является  программным, который совместно с нижним уровнем обеспечивает достижение машиной  новых свойств. Каждый новый уровень дает возможность расширять функции  возможности по обработке данных и позволяет достаточно просто производить  доступ к низшим уровням. Применение метода иерархического упорядочивания  виртуальных машин наряду с достоинствами: систематичность проекта, возрастание  надежности программных систем, уменьшение сроков разработки имеет проблемы.  Основная из них: определение свойств и количества уровней виртуализации,  определения правил внесения на каждый уровень необходимых частей ОС. Свойства  отдельных уровней абстракции (виртуализации):<br />
    1. На каждом уровне ничего не  известно о свойствах и о существовании более высоких уровней.<br />
    2. На каждом уровне ничего не  известно о внутреннем строении других уровней. Связь между ними осуществляется  только через жесткие, заранее определенные сопряжения.<br />
    3. Каждый уровень представляет  собой группу модулей, некоторые из них являются внутренними для данного и доступны  для других уровней. Имена остальных модулей известны на следующим, более  высоком уровне, и представляют собой сопряжение с этим уровнем.<br />
    4. Каждый уровень располагает  определенными ресурсами и либо скрывает от других уровней, либо представляет другим  уровням их абстракции (виртуальные ресурсы).<br />
    5. Каждый уровень может  обеспечивать некоторую абстракцию данных в системе.<br />
    6. Предположения, что на каждом  уровне делается относительно других уровней, должны быть минимальными.<br />
    7. Связь между уровнями  ограничена явными аргументами, передаваемыми с одного уровня на другой.<br />
    8. Недопустимо совместное  использование несколькими уровнями глобальных данных.<br />
    9. Каждый уровень должен иметь  более прочное и слабое сцепление с другими уровнями.<br />
    10. Всякая функция, выполняемая  уровнем абстракции должна иметь единственный вход.</p>
  <p><strong>Принцип  независимости ПО</strong> от внешних  устройств. Принцип заключается в том, что связь программы с конкретными устройствами  производится не на уровне трансляции программы, а в период планирования ее  использования. При работе программы с новым устройством, перекомпиляция не  требуется. Принцип реализуется в подавляющем большинстве ОС.</p>
  <p><strong>Принцип  совместимости</strong>. Этот принцип  определяет возможность выполнения ПО, написанного для другой ОС или для более  ранних версий данной ОС. Различают совместимость на уровне исполняемых файлов и  на уровне исходных текстов программ. В первом случае готовую программу можно  запустить на другой ОС. Для этого требуется совместимость на уровне команд  микропроцессора, на уровне системных и библиотечных вызовов. Как правило,  используются специально разработанные эмуляторы, позволяющие декодировать  машинный код и заменить его эквивалентной последовательностью команд в терминах  другого процессора. Совместимость на уровне исходных текстов требует наличия  соответствующего транслятора и также совместимости на уровне системных вызовов  и библиотек.</p>
  <p><strong>Принцип  открытости и наращиваемости</strong>.  Открытость подразумевает возможность доступа для анализа как системным  специалистам, так и пользователям. Наращиваемость подразумевает возможность  введения в состав ОС новых модулей и модификации существующих. Построение ОС по  принципу клиент-сервер с использованием микроядерной структуры обеспечивает  широкие возможности по наращиваемости. В этом случае ОС строится как  совокупность привилегированной управляющей программы и непривилегированных услуг-серверов.  Основная часть остается неизменной, тогда как серверы могут быть легко заменены  или добавлены.</p>
  <p><strong>Принцип  мобильности (переносимости).</strong> Подразумевает возможность перенесения ОС с аппаратной платформы одного типа на  платформу другого типа. При разработке переносимой ОС следуют следующим  правилам: большая часть ОС пишется на языке, который имеет трансляторы на всех  платформах, предназначенных для использования. Это язык высокого уровня, как  правило, С. Программа на ассемблере в общем случае не является переносимой.  Далее, минимизируют или исключают те фрагменты кода, которые непосредственно  взаимодействуют с аппаратными ресурсами. Аппаратно-зависимый код изолируется в  нескольких хорошо локализуемых модулях. </p>
  <p><strong>Принцип  безопасности.</strong> Подразумевает защиту  ресурсов одного пользователя от другого, а также предотвращения захвата всех  системных ресурсов одним пользователем, включая и защиту от  несанкционированного доступа. Безопасная система должна обладать  конфиденциальностью, доступностью и целостностью. <strong>Конфиденциальность</strong> &ndash; это возможность доступа к данным только тем  пользователям, которым этот доступ разрешен. <strong>Доступность</strong> &ndash; это гарантия того, что авторизованные пользователи  всегда получат информацию, которая им необходима. <strong>Целостность</strong> &ndash; это невозможность модификации данных  неавторизованными пользователями. При защите использую механизмы идентификации,  аутентификации и авторизации. <strong>Идентификация</strong> &ndash; это сообщение пользователем своего идентификатора. Для проверки, что  пользователь именно тот, за кого себя выдает (т.е. он предоставил действительно  свой идентификатор), используется <strong>аутентификация</strong>.  В простейшем случае для аутентификации используется пароль. Предоставление  пользователю прав на доступ к объекту &ndash; это <strong>авторизация</strong>. Различают <strong>избирательный</strong> (дискреционный) и <strong>полномочный</strong> (мандатный) способ управления доступом. В первом случае определенные операции  над конкретным ресурсом запрещаются или разрешаются пользователям либо группам  пользователей. Во втором случае все объекты имеют уровень секретности, а  пользователи делятся на группы в соответствии с уровнем допуска к информации.  При этом обеспечиваются правила:<br />
    - простое правило секретности. Пользователь может  читать информацию только из объекта, уровень секретности которого не выше  уровня доступа пользователя. Т.е. генерал читает документы лейтенанта. <br />
    *-свойство. Пользователь может записывать информацию  только в объекты, уровень секретности которых не ниже уровня доступа  пользователя. Т.е. генерал может отправить секретную информацию маршалу или  другому генералу, но не майору.</p>
  <p>Наиболее известна Оранжевая книга безопасности  (стандарт Министерства обороны США). Все системы делятся на 4 уровня  безопасности: A, B, C, D. Уровень С делится на классы С1 и С2, уровень В &ndash; на  классы В1, В2, В3. А является уровнем с максимальной защитой. Большинство  современных ОС отвечают требованиям уровня С2. Он обеспечивает:</p>
  <ul>
    <li>средства  секретного входа, позволяющие идентифицировать пользователя путем ввода  уникального имени и пароля при входе в систему;</li>
    <li>&nbsp;избирательный контроль доступа, позволяющий  владельцу ресурса определить, кто имеет доступ к ресурсу и его права;</li>
    <li>средства учета и  наблюдения (аудита), обеспечивающие возможность обнаружения и фиксации событий,  связанных с безопасностью системы и доступом к системным ресурсам;</li>
    <li>защита памяти,  подразумевающая инициализацию перед повторным использованием.</li>
  </ul>
  <p>На этом уровне система не защищена от ошибок  пользователя, но его действия легко отслеживаются по журналу. Системы уровня В  распределяют пользователей по категориям, присваивая определенный рейтинг  защиты, и предоставляя доступ к данным только в соответствии с этим рейтингом.  Уровень А требует выполнения формального, математически обоснованного  доказательства соответствия системы определенным критериям безопасности. На  уровне А управляющие безопасностью механизмы занимают до 90% процессорного  времени. Сейчас используется и новый стандарт Common Criteria, а  набор критериев Controlled Access Protection Profile примерно  соответствует классу С2. </p>
  <p>В ОС реализуется несколько подходов для обеспечения защиты. Одним из  них является двухконтекстность работы процессора, т.е. в каждый момент времени  процессор может выполнить либо программу из состава ОС, либо прикладную или служебную  программу, не входящую в состав ОС. Для того, чтобы гарантировать невозможность  непосредственного доступа к любому разделяемому ресурсу со стороны  пользовательских и служебных программ, в состав машинных команд вводятся  специальные привилегированные команды, управляющие распределением и  использованием ресурсов. Эти команды разрешается выполнять только ОС. Контроль  за их выполнением производится аппаратно. При попытке выполнить такую команду  возникает прерывание, и процессор переводится в привилегированный режим. Для  реализации принципа защиты используется механизм защиты данных и текста  программ, находящихся в ОЗУ. Самым распространенным подходом при этом является  контекстная защита. Для программ и пользователей выделяется определенный  участок памяти, и выход за его пределы приводит к прерыванию по защите.  Механизм контроля реализуется аппаратным способом на основе ограниченных регистров  или ключей памяти. Применяются различные способы защиты хранения данных в  файлах. Самый простой способ защиты &ndash; парольный.</p>
  <p>Интерфейс между ОС и программами пользователя&nbsp; определяется набором <strong>системных вызовов</strong>, предоставляемых ОС. Если процесс выполняет  программу в пользовательском режиме, и ему необходимо произвести при этом  системный вызов, то происходит прерывание либо вызывается команда системного  вызова для передачи управления ОС. Далее в зависимости от параметров, ОС  определяет, что требуется вызывающему процессу. Далее обрабатывается системный  вызов, и возвращает управление команде, следующей за системным вызовом.  Системные вызовы выполняются в привилегированном режиме. В общем случае системный  вызов может и блокировать вызвавшую его процедуру, например при чтении символа  с клавиатуры. В UNIX системах библиотека libc обеспечивает С-интерфейс каждому системному вызову. В  результате системный вызов для прикладного программиста ничем не отличается от  вызова обычной библиотечной процедуры.</p>
  <p><strong>Интерфейс  прикладного программирования</strong> (API - Application Program Interface) является более широким понятием, чем системные  вызовы. Он представляет собой средства для использования прикладными  программами системных ресурсов ОС и реализуемых ею функций. Соответственно, API может реализовываться на уровне ОС, представляя собой  системные вызовы, на уровне систем программирования, как правило в виде  библиотеки RTL. Кроме того, API могут реализовываться в виде внешних библиотек,  например, MFC, VCL. </p>
  <p>Платформенно независимый системный интерфейс для  компьютерных сред, описываемый стандартом <strong>POSIX</strong> (Portable  Operating System Interface for Computer Environments) &ndash;  определяет минимальный набор системных вызовов для открытых ОС, базируясь на UNIX системах. Как правило, каждая UNIX система имеет и дополнительные, присущие только ей  вызовы. POSIX описывает более 100 вызовов. </p>
  <p>В отличие от UNIX, в Windows системные вызовы и запускающиеся для их выполнения  библиотечные вызовы полностью разделены. Для вызова служб ОС используется набор  процедур <strong>Win</strong><strong>32 </strong><strong>API</strong>.  Количество вызовов в WinAPI составляет несколько тысяч, причем многие из них  целиком работают в пространстве пользователя, а не ядра. Далее, в UNIX графический интерфейс пользователя GUI запускается в пространстве пользователя, тогда как WinAPI имеет огромное количество процедур для работы с  графической оболочкой &ndash; управление окнами, меню, шрифтами и т.д. В большинстве  версий Windows графическая система запускается в режиме ядра, и&nbsp; в этом случае соответствующие вызовы являются  системными, в противном случае только библиотечными. В Win32API не  существует понятия связанных файлов, монтирования файловой системы, сигналов. WinAPI для Windows систем  на основе ядра NT 5.x (Windows 2000, Windows XP, Windows Server  2003) поддерживает вызовы POSIX,  определенные стандартом POSIX.1, и имеет  возможность монтирования файловой системы.</p>
  <p>Основные системные вызовы:<br />
    <strong>POSIX</strong><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; назначение&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </strong><strong>Win</strong><strong>32 </strong><strong>API</strong><strong> </strong><br />
    fork&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; создать  дочерний процесс, идентичный родительскому&nbsp;&nbsp;&nbsp; CreateProcess&nbsp; (fork+execve)<br />
    waitpid&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ожидать  завершение дочернего процесса&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WaitForSingleObject <br />
    execve&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; переместить  образ памяти процесса&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -<br />
    exit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; завершить  выполнение процесса&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ExitProcess <br />
    open&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; открыть  файл&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CreateFile <br />
    close&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; закрыть  файл&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CloseHandle <br />
    read&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; чтение  данных из файла в буфер&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ReadFile <br />
    write&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; записьданных  из буфера в файл&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WriteFile <br />
    lseek&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; переместить  указатель файла&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SetFilePointer <br />
    stat&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; информация  о состоянии файла&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GetFileAttributesEx <br />
    mkdir&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; создать  каталог&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CreateDirectory <br />
    rmdir&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; удалить  каталог&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RemoveDirectory <br />
    link&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; создать  новый элемент каталога, ссылающийся на другой&nbsp;&nbsp;  -<br />
    unlink&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; удалить  элемент каталога&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DeleteFile <br />
    mount&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; монтирование  файловой системы&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -<br />
    umount&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; демонтирование  файловой системы&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -<br />
    chdir&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; изменить  рабочий каталог&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SetCurrentDirectory <br />
    chmod&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; изменить  биты защиты файла&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -<br />
    kill&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; послать  сигнал процессу&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -<br />
    time&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; получить  системное время&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GetLocalTime </p>
<p align="center">&nbsp;</p>
</BODY>
</HTML>