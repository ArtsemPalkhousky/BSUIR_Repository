<!-- (C) 2011-2012 V.Prytkov, V. Suponev, A.Uvarov. BSUIR -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//RU">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1251">
<META HTTP-EQUIV="Content-Language" CONTENT="ru">
<link rel="stylesheet" type="text/css" href="../css/style.css" />
<title>Лекция №3. Понятие  процесса и потока.</title>
<base target="_top">
</HEAD><BODY>
  <p align="center"><strong>Понятие  процесса и потока</strong></p>
  <p><em>Концепция  процесса. Диаграмма состояний процесса. Операции над процессами. Создание и  завершение процесса. Иерархия процессов. Структуры управления процессами.  Процессы-зомби. Системные вызовы для управления процессами. Процессы в </em><em>Windows</em><em> и </em><em>UNIX</em><em>.  Процессы и потоки. Понятия мультизадачности и многопоточности. Потоки в  пространстве пользователя. Потоки в ядре. Облегченные потоки. Потоки в </em><em>Windows</em><em> и </em><em>UNIX</em><em>.  Всплывающие потоки. Понятие о прерываниях. Параллельные процессы. Независимые и  взаимодействующие процессы. Сигналы </em><em>UNIX. </em><em>Сообщения </em><em>Windows </em></p>
  <p>В  первых системах программа могла выполняться только после завершения предыдущей.  В полном соответствии с принципами, разработанными фон Нейманом, все подсистемы  и устройства, в т.ч. управление памятью и в/в с внешними устройствами  управлялись центральным процессором. Введение в состав системы специальных  контроллеров позволило распараллелить эти процессы и непосредственно обработку  данных. Был предложен <strong>мультипрограммный</strong> режим работы: пока одна программа (процесс) ожидает завершения операций  ввода-вывода, другой может быть поставлен на обработку данных.<br />
    <div class="imageTip"><img src="../images/1sem_theory_p3_clip_image002.jpg" alt="1" width="276" height="181" hspace="12" /></div> <br />
    Общее  время выполнения двух задач меньше, чем при последовательной обработке, однако  время выполнения отдельной задачи несколько увеличивается. Т.е. при  мультипрограммировании повышается пропускная способность системы, но отдельная  задача не может быть выполнен быстрее, чем в однопрограммном режиме в силу  затрат времени на ожидание освобождения ресурса. В такой многозадачной системе  процессор переключается между задачами, предоставляя каждой из них от&nbsp; десятков до сотен миллисекунд, при этом в  каждый конкретный момент времени процессор занят только одной программой, но за  секунду он успевает поработать с несколькими, создавая у пользователя иллюзию  параллельной работы.</p>
  <p><strong>Процесс</strong> &ndash; это выполняемая программа, включая  текущие значения счетчика команд, регистров и переменных. С этой точки зрения,  у каждого процесса есть собственный виртуальный процессор. При необходимости  использования ресурса, процесс обращается с запросом на ресурс к супервизору ОС  (центральному управляющему модулю), который может состоять из нескольких,  например, супервизор в/в, супервизор прерываний и т.д. При этом указывается вид  ресурса и при необходимости, параметры (объем памяти, например, или  необходимость в монопольном использовании ресурса). Управление передается ОС,  переводя процессор в привилегированный режим работы. Ресурс может быть выделен  процессу, если:</p>
  <ul>
    <li>он  свободен и в системе нет запросов на этот ресурс от задач с более высоким  приоритетом</li>
    <li>текущий  запрос и ранее выданные запросы допускают совместное использование ресурсов</li>
    <li>ресурс  используется процессом с более низким приоритетом и может быть временно отобран  (разделяемый ресурс)</li>
  </ul>
  <p>Получив запрос, ОС либо удовлетворяет его и  возвращает управление процессу, либо, если ресурс занят, ставит задачу в очередь,  переводя ее в состояние ожидания. После использования ресурса процесс с помощью  специального вызова супервизора сообщает об этом ОС, либо ОС сама забирает  ресурс у процесса, если управление возвращается супервизору после вызова  какой-либо системной функции. Супервизор освобождает ресурс и проверяет  очередь. В зависимости от принятой дисциплины обслуживания и приоритета  запросов, он выводит из состояния ожидания соответствующую задачу и переводит  ее в состояние готовности. Управление передается либо этой задаче, либо той,  которая только что освободила ресурс.</p>
  <p><strong>Диаграмма  состояний процесса.</strong><br />
    <div class="imageTip"><img src="../images/1sem_theory_p3_clip_image004.jpg" alt="2" width="305" height="147" hspace="12" /></div> <br />
    Процесс может находиться в <strong>активном</strong> и <strong>пассивном</strong> состоянии. В активном он может участвовать в конкуренции  за использование ресурсов системы, а в пассивном &ndash; он только известен системе,  а в конкуренции не участвует, хотя его существование в системе и связано с  предоставлением ему памяти. Активный процесс может быть в одном из 3 состояний: </p>
  <ul>
    <li><strong>выполнение</strong> &ndash; все затребованные процессом ресурсы  выделены. В этом состоянии в&nbsp; однопроцессорной  системе в каждый момент времени может находиться только один процесс</li>
    <li><strong>готовность</strong> &ndash; ресурсы могут быть предоставлены, тогда  процесс перейдет в состояние выполнения</li>
    <li><strong>ожидание</strong> &ndash; ресурсы не могут быть предоставлены, либо не завершена  операция ввода-вывода.</li>
  </ul>
  <p>В большинстве ОС процесс возникает при  запуске программы на выполнение. ОС выделяет для него соответствующий дескриптор,  и процесс начинает выполняться. Состояние неактивности отсутствует. В ОС  реального времени зачастую состав процессов известен заранее, в т.ч. и многие  их параметры, поэтому с целью экономии времени, дескрипторы выделены заранее, а  многие процессы находятся в пассивном состоянии.</p>
  <p>За время существования процесс может  неоднократно переходить из одного состояния в другое. Из состояния пассивности  в состояние готовности процесс может перейти в следующих случаях:</p>
  <ul>
    <li>по  команде оператора. Происходит в диалоговых ОС, где программа имеет статус  задачи и может являться пассивной, а не просто быть исполняемым файлом</li>
    <li>при  выборе из очереди планировщиком (характерно для пакетного режима)</li>
    <li>по  вызову из другой задачи (с помощью обращения к супервизору один процесс может  создать, инициировать, остановить, уничтожить другой процесс)</li>
    <li>по  прерыванию от внешнего устройства</li>
    <li>при  наступлении запланированного времени запуска задачи.</li>
  </ul>
  <p>Процесс, который может исполняться, как  только ему будет предоставлен процессор (в некоторых системах и память), находится  в состоянии готовности. Ему выделены все необходимые ресурсы, кроме процессора.  Из состояния выполнения процесс может выйти по следующим причинам:</p>
  <ul>
    <li>процесс  завершается, с помощью супервизора передает управление ОС. Супервизор либо  переводит его в список пассивных процессов, либо уничтожает. В пассивное  состояние процесс может быть переведен и принудительно по команде оператора,  либо при обращении к супервизору иного процесса с запросом на остановку данного  процесса</li>
    <li>переводится  супервизором в состояние готовности в связи с появлением более приоритетной  задачи или по окончанию выделенного кванта времени</li>
    <li>процесс  блокируется либо вследствие запроса операции ввода-вывода, либо из-за занятости  ресурса, а также по команде оператора или по требованию супервизора от другой  задачи. При наступлении соответствующего события (завершилась операция  ввода-вывода, освободился ресурс и т.д. процесс деблокируется и переводится в  состояние готовности.</li>
  </ul>
  <p><strong>Понятие  последовательного процесса в ОС</strong>.&nbsp; <br />
    Все функционирующее на компьютере ПО,  иногда включая ОС, организовано в виде набора последовательных процессов.  Обычно при загрузке ОС создается несколько процессов. Одни из них являются  высокоприоритетными, другие &ndash; фоновыми. Фоновые процессы, связанные с  электронной почтой, web-страницами,  новостями, выводом на печать, называют <strong>демонами</strong>.  Если процесс может создавать другие процессы, и т.д., то образуется  соответствующее дерево процессов. Процессы связаны, если они объединены для  решения какой-либо задачи и им необходимо передавать данные от одного к другому  и синхронизировать свои действия. Эта связь называется <strong>межпроцессным взаимодействием</strong>. </p>
  <p>На каждый процесс выделяется специальная  информационная структура &ndash; <strong>дескриптор  процесса</strong>. В общем случае он содержит:</p>
  <ul>
    <li>идентификатор процесса PID &ndash; process  identificator</li>
    <li>тип/класс  процесса, который определяет для супервизора некоторые правила предоставления  ресурсов</li>
    <li>приоритет  процесса. В рамках класса в первую очередь обслуживаются процессы с более  высоким приоритетом</li>
    <li>переменная  состояния, определяющую, в каком состоянии находится процесс</li>
    <li>защищенную  область памяти (ее адрес), в которой сохраняются текущие значения регистров  процессора при прерывании выполнения процесса. Эта область называется  контекстом задачи.</li>
    <li>Информацию  о ресурсах, которыми владеет процесс или имеет право пользоваться (указатели на  файлы, информация о незавершенных операциях в/в)</li>
    <li>Область  памяти (адрес) для организации взаимодействия с другими процессами</li>
    <li>Параметры  времени запуска (момент активации и периодичность этого)</li>
    <li>При  отсутствии системы управления файлами &ndash; адрес задачи на диске в ее исходном  состоянии и адрес, куда она выгружается, если ее вытесняет другая.</li>
  </ul>
  <p>Дескрипторы, как правило, постоянно  находятся в оперативной памяти с целью ускорения работы супервизора. Для  каждого состояния ОС ведет соответствующий список процессов, находящихся в этом  состоянии. При изменении состояния процесса, супервизор перемещает дескриптор  из одного списка в другой. Для состояния ожидания может быть не один список, а  несколько &ndash; по количеству соответствующих видов ресурсов. Часто в ОС заранее  определяется максимальное количество дескрипторов задач. Существует и  аппаратная поддержка дескрипторов задач. Так в процессорах i80x86  начиная с 80286 имеется регистр TR (task register), указывающий местонахождение сегмента  состояния задачи TSS, где  при переключении задач сохраняется содержание регистров.</p>
  <p>В UNIX используются 2 структуры: u и proc. Ядро имеет массив структур proc, который называется таблицей процессов. Поскольку  таблица находится в системном пространстве, она всегда доступна ядру. Область u является часть пространства процесса, т.е.  видна только в момент выполнения процесса, и содержит данные, необходимые  только в период выполнения процесса. </p>
  <p>В UNIX существует только один системный запрос для создания процесса: <strong>fork</strong>. Этот  запрос создает дубликат существующего, т.е. дочерний процесс полностью  повторяет родительский процесс. Адресное пространство полностью повторяет адресное  пространство родительского процесса, аналогичны и строки окружения, эти  процессы имеют одни и те же открытые файлы. Все переменные имеют одинаковые  величины во время вызова fork как у  родительского, так и у дочернего процесса, но как только данные скопированы для  дочернего процесса, дальнейшие изменения в одном из них уже не влияют на другой.  Чтобы можно было отличить родительский процесс от дочернего, fork возвращает 0 для дочернего процесса и PID дочернего процесса для родительского, &ndash;1 в  случае ошибки. Вызов fork  выполняет следующие действия:</p>
  <ul>
    <li>резервирует  пространство своппинга для данных и стека процесса-потомка</li>
    <li>назначает  новый идентификатор PID и  структуру proc  потомка</li>
    <li>инициализирует  структуру proc  потомка. Часть полей копируются от родителя, часть устанавливается в 0, часть устанавливается  в специфические для потомка значения</li>
    <li>размещает  карты трансляции адресов для потомка</li>
    <li>выделяет  область u  потомка и копирует в нее содержимое области u родителя</li>
    <li>изменяет  ссылки области u на  новые карты адресации и своппигна</li>
    <li>добавляет  потомка в набор процессов, разделяющих между собой область кода программы,  выполняемой родителем.</li>
    <li>Постранично  дублирует области данных и стека родителя и модифицирует карты адресации  потомка в соответствии с этими новыми страницами</li>
    <li>Получает  ссылки на разделяемые ресурсы, наследуемые потомком, такие как открытые файлы и  рабочий каталог</li>
    <li>Инициализирует  аппаратный контекст потомка копируя текущие состояния регистров родителя</li>
    <li>Процесс  потомок становится выполняемым и помещается в очередь планировщика</li>
    <li>Для  потомка установить возвращаемое значение в 0</li>
    <li>Для  родителя возвращается PID  потомка</li>
  </ul>
  <p>Очевидно, что если после fork сразу использовать exec, то в копировании образа памяти родительского  процесса нет необходимости. Один из подходов &ndash; метод копирования при записи.  Страницы данных и стека родителя временно получают атрибут только для чтения и  помечаются как копируемые при записи. Потомок получает собственную копию карт  трансляции адресов, но использует те же самые страницы, что и родитель. Если  любой из этих двух процессов попытается изменить страницу, произойдет  исключительная ситуация, ядро запустит соответствующий обработчик, который,  увидев пометку копирования при записи, создаст копию страницы, которую уже  можно изменять. Таким&nbsp; образом создаются  копии только тех страниц памяти, которые изменяются в одном из процессов.  Второй подход &ndash; использование системного вызова vfork, который не копирует страницы памяти.  Процесс родитель предоставляет свое адресное пространство потомку и блокируется  до тех пор, пока потомок не выполнит exec или exit, после  чего ядро вернет родителю его адресное пространство и переведет его из  состояния ожидания.</p>
  <p>&nbsp;Для  изменения образа памяти и запуска новой программы дочерний процесс выполняет  системный вызов <strong>execve</strong>. Вызов заменяет весь образ памяти процесса  файлом, имя которого указано в первом параметре. Как правило, у вызова имеется  еще два параметра: указатель на массив аргументов и указатель на массив переменных  окружения. Например, при выполнении команды cp file1 file2 произойдет следующее: оболочка с помощью fork создаст дочерний процесс, далее с помощью exec будет помещен в память файл cp (код программы копирования), а вторым  аргументом вызова будет указатель на массив параметров, содержащих имена  файлов. Вызов выполняет следующие действия:</p>
  <ul>
    <li>Разбирает  путь к исполняемому файлу и осуществляет доступ к нему</li>
    <li>Проверяет,  есть у процесса полномочия на выполнение файла</li>
    <li>Читает  заголовок, чтобы убедиться что файл исполняемый</li>
    <li>Идентификаторы  пользователя и группы UID и GID изменяются на соответствующие владельцу  файла</li>
    <li>Копируются  передаваемые аргументы и переменные среды в пространство ядра, подготавливая  текущее пользовательское пространство к уничтожению</li>
    <li>Выделяется  пространство своппинга для областей данных и стека</li>
    <li>Освобождается  старое адресное пространство и связанное с ним пространство своппинга</li>
    <li>Выделяются  карты трансляции адресов для нового текста, данных и стека</li>
    <li>Устанавливается  новое адресное пространство</li>
    <li>Аргументы  и переменные среды копируются обратно в новый стек приложения</li>
    <li>Все  обработчики сигналов сбрасываются в действия по умолчанию</li>
    <li>Инициализируется  аппаратный контекст</li>
  </ul>
  <p>Родительский  процесс может ожидать окончания дочернего с помощью системного вызова <strong>waitpid</strong>. В качестве  первого параметра выступает pid  дочернего процесса, либо &ndash;1, если достаточно дождаться завершения любого из  них. Вторым параметром передается указатель, который будет установлен на статус  завершения дочернего процесса. Вызов <strong>wait</strong> тоже  позволяет ожидать завершения работы потомка, однако без указания какого именно.  Wait  возвращает PID  завершившегося процесса, освобождает его структуру proc, сохраняет его статус выхода в  соответствующей переменной. Если работу завершили несколько дочерних процессов,  то обработан будет только один из них. Пример кода создания дочернего процесса:<br />
    if (fork()!=0)<br />
  &nbsp;&nbsp; {waitpid(-1,&amp;status,0); }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //  код родительского процесса<br />
    else  execve (command, parameters,0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //  а это дочерний процесс </p>
  <p>Вызов <strong>exit</strong> завершает процесс. При этом выполняется:</p>
  <ul>
    <li>Отключаются  все сигналы</li>
    <li>Закрываются  открытые файлы</li>
    <li>Освобождается  файл программы и другие ресурсы</li>
    <li>Делается  запись в журнал</li>
    <li>Сохраняются  данные об использованных ресурсах и статус выхода в структуре proc </li>
    <li>Состояние  процесса изменяется на SZOMB, его структура  proc  помещается в список процессов-зомби</li>
    <li>Все  потомки процесса получают в качестве нового родителя системный процесс init </li>
    <li>Освобождается  адресное пространство, область u, карты  трансляции адресов и пространство своппинга</li>
    <li>Родителю  процесса посылается сигнал SIGCHLD </li>
    <li>Будится  родительский процесс</li>
    <li>Вызывается  swtch для  перехода к следующему процессу</li>
  </ul>
  <p>После выполнения вызова процесс находится в  состоянии <strong>зомби</strong>. В этом состоянии не  освобождена структура proc,  данные из которой могут понадобиться родителю. Соответственно родитель и  отвечает за ее освобождение. Здесь существует проблема. Если родительский  процесс завершен раньше дочернего, то дочерний усыновляется процессом init. Все в порядке. Если дочерний завершается  раньше, а родитель не вызывает wait, который  освобождает proc, то  процесс-зомби так и останется. Эти процессы видны при вызове ps, однако завершить их невозможно, поскольку  они уже завершены. Кроме того, они продолжают занимать структуру proc, число которых в таблице процессов как  правило, ограничено.</p>
  <p>В Windows и созданием процесса и запуском в нем нужной программы  управляет функция <strong>CreateProcess</strong>. Родительский и дочерний процессы имеют  собственные адресные пространства, различные изначально. Процессы в Windows идентифицируются как дескрипторами, так и  идентификаторами процессов. <strong>GetCurrentProcess</strong> и <strong>GetCurrentProcessId</strong> возвращают дескриптор и идентификатор соответственно.  Завершается процесс функцией <strong>ExitProcess</strong>. Ожидание завершения процесса или группы  процессов выполняется функциями <strong>WaitForSingleObject</strong> и <strong>WaitForMultipleObject</strong>. Во втором случае происходит ожидание либо  одного из указанных объектов либо всех. Выполнение дочернего процесса не  зависит от родительского. <br />
    Функция CreateProcess выполняет следующие действия:</p>
  <ul>
    <li>открывается  исполняемый файл</li>
    <li>если  файл не является Windows-приложением,  ищется образ поддержки (программа) для запуска этого приложения</li>
    <li>создается  и инициализируется объект процесса исполнительной системы ОС</li>
    <li>создается  первичный поток &ndash; стек, контекст и объект потока исполнительной системы</li>
    <li>подсистема  Windows  получает сообщение о создании нового процесса и потока</li>
    <li>начинается  выполнение первичного потока</li>
    <li>в  контексте нового процесса и потока инициализируется адресное пространство и  начинается выполнение программы</li>
  </ul>
  <p><strong>Процессы  и потоки.</strong><br />
    Процесс можно рассматривать как способ  объединения используемых ресурсов в одну группу. Процесс имеет свое виртуальное  адресное пространство, ему назначаются ресурсы &ndash; файлы, окна, семафоры и т.д.  Это позволяет защитить процессы друг от друга. ОС считает процессы совершенно  несвязанными между собой. С другой стороны процесс можно рассматривать как  поток исполняемых команд. У потока или нити (thread) есть счетчик команд, отслеживающий  последовательность операций, регистры, хранящие текущие значения, стек,  содержащий протокол выполнения. Концепция потоков&nbsp; добавляет к модели процесса возможность  одновременного выполнения в одной и той же среде процесса нескольких в  достаточной степени независимых программ. Для них ОС не требуется  организовывать полноценную виртуальную машину. Они не имеют собственных  ресурсов, пользуясь общими для процесса ресурсами. Единственный ресурс, который  им необходим &ndash; это процессор. В однопроцессорной системе потоки разделяют между  собой процессорное время точно так же, как и процессы,&nbsp; в мультипроцессорной могут выполняться одновременно.</p>
  <div class="imageTip"><img src="../images/1sem_theory_p3_clip_image006.gif" alt="3" width="213" height="289" hspace="12" /></div>Многопоточность обеспечивает параллельное выполнение нескольких  видов операций в одной программе. Особо эффективно выполнение многопоточных  приложений на распределенных системах. Т.о., процесс предполагает, что при  диспетчеризации требуется учитывать все ресурсы, закрепленные за ним. При  переключении между потоками достаточно изменять только контекст задачи, не  затрагивая всех остальных ресурсов. Каждый процесс всегда имеет как минимум  один поток. Каждый поток выполняется строго последовательно. Потоки, как и  процессы могут порождать потоки-потомки. Аналогично процессам, поток может  находиться в одном из активных состояний. Пока один поток заблокирован, другой  может выполняться. Поскольку потоки одного процесса выполняются в одном и том  же виртуальном адресном пространстве, между ними легче организовать тесное  взаимодействие, в отличие от процессов, которым необходимы специальные  механизмы обмена&nbsp; сообщениями и данными.  Для потоков не существует прерываний по таймеру, позволяющему установить режим  разделения времени, поэтому существует запрос, позволяющий потоку самостоятельно  передать управление другому.</p>
  <p>Возможны два основных варианта реализации  потоков &ndash; на уровне пользователя и на уровне ядра. В первом случае у каждого  процесса имеется своя собственная таблица потоков, в которой хранится  информация, необходимая для переключения потока в состояние выполнения. Когда  поток на уровне пользователя завершает на время свою работу, процедуре передачи  управления нет необходимости использовать системные вызовы на уровне ядра,  поскольку вся информация о потоках находится внутри процесса-хозяина.  Соответственно, процедура может сама сохранить информацию в таблице потоков,  более того, даже вызвать планировщик потоков для выбора следующего.  Соответственно не требуется прерывание, переключение контекста, сохранение кэша  и т.д., что дает значительное ускорение. Потоки на уровне пользователя  позволяют каждому процессу иметь собственный алгоритм планирования потоков.  Однако в общем случае, при блокировке одного потока блокируется весь процесс.  Ядру ничего не известно о том, что приложение многопоточное, поэтому вся  синхронизация при доступе к общим переменным из разных потоков должна быть  выполнена на уровне пользователя. В Windows такие потоки называются <strong>облегченными</strong>.</p>
  <p>При реализации на уровне ядра, таблица  потоков единая для всех процессов. Ядро в общем случае может при блокировании  потока выбрать новый, не принадлежащий текущему процессу. В терминологии UNIX такие потоки часто называют &ldquo;легковесными  процессами&rdquo;. (LWP, lightweight process). В отличие от пользовательских потоков,  при блокировке одного LWP остальные  продолжают работать. Поскольку все потоки LWP планируются на выполнение ядром независимо  друг от друга, но в отличие от полновесных процессов, разделяют общее адресное  пространство, при доступе к переменным, используемым несколькими LWP, требуется применение специальных  механизмов синхронизации на уровне ядра. Все запросы, которые могут блокировать  поток, реализуются как системные, что увеличивает временные издержки. Чтобы их  снизить некоторые системы после завершения потока не уничтожают его структуры,  только помечая, как неработающий. При запросе на создание нового потока  используются уже готовые структуры. В Windows именно потоки, а не процессы являются объектами  диспетчеризации. Т.е. планировщик выбирает из очереди готовый поток, а не  процесс.</p>
  <p>Концепция потока не дает увеличения  производительности в однопроцессорной системе, если все они ограничены возможностями  процессора. Но если имеется потребность в выполнении большого объема вычислений  и операций ввода-вывода, то потоки позволяют совместить эти действия во  времени, увеличивая общую скорость работы. Для обработки входящих сообщений  можно использовать концепцию <strong>всплывающих  потоков</strong>. В обычном случае в процессе существует поток, который в обычном  состоянии заблокирован, и активизируется с приходом сообщения. В случае  всплывающего потока он создается с нуля с приходом сообщения. При этом нет  необходимости в восстановлении контекста потока. Однако при этом необходимо  предварительное планирование. Например, в каком процессе должен возникнуть  новый поток? Он должен быть на уровне ядра или пользователя ? и т.д.</p>
  <p><strong>Потоки  в </strong><strong>Windows</strong> создаются функцией <strong>CreateThread</strong>.  Завершить поток можно функцией <strong>ExitThread</strong>, либо возврат из функции потока с  использованием кода завершения в качестве возвращаемого значения. Функции <strong>GetCurrentThread</strong> и <strong>GetCurrentThreadId</strong> позволяют получить дескриптор и  соответственно идентификатор вызывающего потока, <strong>OpenThread</strong> позволяет получить дескриптор потока по известному идентификатору. Функции <strong>SuspendThread</strong> и <strong>ResumeThread</strong> позволяют  приостановить поток и возобновить его выполнение. Ожидание завершения потока  выполняется функциями <strong>WaitForSingleObjects</strong> и <strong>WaitForMultipleObjects</strong>. <strong>CreateRemoteThread</strong> позволяет создать поток в другом процессе. </p>
  <p>POSIX описывает стандарт библиотеки <strong>pthreads</strong> для  поддержки потоков. Поддержка включена в ряд реализаций UNIX и Linux. Соответственно создание и завершение  потока соответствуют системные вызовы <strong>pthread</strong><strong>_</strong><strong>create</strong> и <strong>pthread</strong><strong>_</strong><strong>exit</strong>, для  организации ожидания завершения потока <strong>pthread</strong><strong>_</strong><strong>join</strong>.</p>
  <p>Стандартные библиотеки С исторически были  рассчитаны на однопоточные системы. Поэтому многие библиотечные функции  используют глобальные данные для хранения переменных. В результате потоки будут  работать не каждый со своими данными отдельно, а с общими глобальными, что  потенциально является источником проблем.</p>
  <p>В архитектуру современных процессоров  включена возможность работать с задачами (Task), объединяющими в себе понятие потока и  процесса. Это при разработке ОС позволяет построить соответствующие дескрипторы  как для процесса, так и для потока. </p>
  <p><strong>Прерывания. </strong>Основная причина изменения  состояний процесса &ndash; события. Одним из видов событий являются прерывания.  Прерывания представляют собой механизм, позволяющий координировать параллельное  функционирование отдельных устройств вычислительной системы и реагировать на  особые состояния, возникающие при работе процессора. Это принудительная  передача управления от выполняемой программы к системе, происходящая при  возникновении определенного события. Основная цель введения прерываний &ndash;  реализация асинхронного режима работы и распараллеливание. Механизм прерываний  реализуется программно-аппаратными средствами. Механизм обработки прерываний  независимо от архитектуры системы включает следующие элементы:</p>
  <ul>
    <li>прием  запроса на прерывание и его идентификация</li>
    <li>запоминание  состояния прерванного процесса. Сохраняется счетчик команд, регистры  процессора, а также другая информация.</li>
    <li>Передача  управления подпрограмме обработки прерываний.&nbsp;  В простейшем случае в счетчик команд заносится начальный адрес  обработчика, а в регистры &ndash; информация из слова состояния. </li>
    <li>Сохранение  информации о прерванной программе, не сохраненную ранее аппаратными средствами</li>
    <li>Обработка  прерывания</li>
    <li>Восстановление  информации прерванного процесса</li>
    <li>Возврат  управления прерванной программе</li>
  </ul>
  <p>Первые три шага реализуются аппаратно,  остальные &ndash; программно.</p>
  <p>Переход от прерываемой программы к  обработчику должен быть максимально быстрым. Один из используемых подходов &ndash;  использование таблиц, содержащих перечень всех допустимых прерываний и адреса  соответствующих обработчиков. Содержимое регистров процессора запоминается либо  в памяти с прямым доступом либо в системном стеке. Прерывания, возникающие в  системе, можно разделить на внутренние и внешние.</p>
  <p>Внешние прерывания вызываются асинхронными  событиями, происходящими вне прерываемого процесса, например:</p>
  <ul>
    <li>прерывание  от таймера</li>
    <li>прерывание  от ВУ на ввод-вывод</li>
    <li>прерывание  по нарушению питания</li>
    <li>прерывание  от оператора</li>
    <li>прерывание  от другого процесса или системы</li>
  </ul>
  <p>Внутренние прерывания вызываются событиями,  связанными с работой процессора и синхронны относительно его операций:</p>
  <ul>
    <li>нарушение  адресации (используется запрещенный или несуществующий адрес, обращение к  отстутствующей странице виртуальной памяти)</li>
    <li>ошибочный  код операции (неизвестная процессору команда)</li>
    <li>деление  на ноль</li>
    <li>переполнение</li>
    <li>обнаружение  ошибок четности и пр.</li>
  </ul>
  <p>Существуют программные прерывания.  Происходят по соответствующей команде прерывания. Были введены для того, чтобы  переключение на системные модули происходило не как переход к подпрограмме, а  тем же самым образом, как и при асинхронных прерываниях. Этим самым  обеспечивается переключение процессора в привилегированный режим с возможностью  исполнения любых команд.</p>
  <p>Сигналы, вызывающие прерывания, могут  возникать одновременно. Выбор одного из них происходит в зависимости от приоритета.  Прерывания от схем контроля процессора имеют наивысший приоритет, программные  прерывания &ndash; самый низкий. Учет приоритетов может быть как аппаратным, так  программным на уровне ОС. </p>
  <p>В общем случае процессор обладает системой  защиты от прерываний: отключение механизма, маскирование отдельных сигналов и  т.п., что позволяет ОС регулировать их обработку. Обычно операция прерывания  начинается только после выполнения текущей команды процессора, даже если оно  возникло асинхронно в процессе ее выполнения. Программное управление позволяет  реализовать разные дисциплины обслуживания прерываний:</p>
  <ul>
    <li>с  относительными приоритетами. Обслуживание не прерывается, даже если пришел  запрос на прерывание с более высоким приоритетом. После окончания обслуживания  текущего запроса обслуживается запрос с наивысшим приоритетом. Для организации  этого либо отключается система прерываний, либо накладываются маски на все  сигналы.</li>
    <li>С  абсолютными приоритетами. Всегда обслуживается прерывание с наивысшим  приоритетом. Для реализации маскируются все запросы с низшим приоритетом. При  этом возможно многоуровневое прерывание. </li>
    <li>По  принципу стека. Любой приходящий запрос прерывает текущее обслуживание. В этом  случае маски не накладываются.</li>
  </ul>
  <p>Во время сохранения контекста задачи и  затем последующего его восстановления система прерываний должна быть отключена.  В процессе выполнения собственно обработчика прерывания, система функционирует  в соответствии с организуемой дисциплиной обслуживания. Очень часто сохранение  контекста задачи возлагается на супервизор прерываний.&nbsp; В его функции входит: сохранение в  дескрипторе текущей задачи рабочие регистры процессора (контекст задачи),  определение адреса необходимого обработчика, установление необходимого режима  обслуживания прерываний и передача управления обработчику. После выполнения,  обработчик вновь передает управление супервизору, на этот раз на модуль,  управляющий диспетчеризацией задач. И уже диспетчер задач, в соответствии с  принятым режимом распределения процессорного времени, восстановит контекст той  задачи, которой будет предоставлен процессор. Т.е. возврата в прерванную  программу может и не произойти. </p>
  <p>Особенностью мультипрограммных ОС является  то, что в их среде параллельно развивается несколько последовательных  процессов. <strong>Параллельные процессы</strong> &ndash;  это последовательные вычислительные процессы, которые одновременно находятся в  каком-либо активном состоянии. Они могут быть независимыми либо  взаимодействующими. Независимыми являются процессы, множество данных  (переменных и файлов) которых не пересекается. Независимые процессы не влияют  на работу друг друга. Взаимодействующие процессы совместно используют некоторые  общие переменные и выполнение одного процесса может повлиять на выполнение  другого.</p>
  <p>В UNIX для оповещения процесса о возникновении системных событий  используются <strong>сигналы</strong>. Они же могут  использоваться и как средство синхронизации и обмена данными. Сигналы позволяют  вызвать какую-либо процедуру при возникновении события из их определенного  набора. Процесс состоит из двух этапов &ndash; генерирования и доставки. Число  поддерживаемых сигналов в различных системах различно. POSIX определяет стандартные символические имена  для наиболее часто используемых сигналов. Каждый сигнал обладает некоторым  действием, которое производится ядром системы, если процесс не имеет  альтернативного обработчика. Их всего пять:</p>
  <ul>
    <li>аварийное  завершение abort.  Завершает процесс, создавая дамп состояния процесса, который может  использоваться в дальнейшем при отладке и т.д.</li>
    <li>выход exit. Завершает процесс без создания дампа</li>
    <li>игнорирование  ignore.  Игнорировать сигнал</li>
    <li>Остановка  stop.  Приостанавливает процесс</li>
    <li>Продолжение  continue.  Возобновляет работу приостановленного процесса</li>
  </ul>
  <p>Процесс может переопределить действия по  умолчания для любого сигнала, в т.ч. и запуск определенной в приложении фйнкции  &ndash; обработчика сигнала. Процесс может временно блокировать сигнал. Сигналы SIGKILL и SIGSTOP являются специальными, и процесс не может  их блокировать, игнорировать или определять собственные обработчики. Основными  источниками сигналов являются: </p>
  <ul>
    <li>исключительные  состояния, </li>
    <li>другие  процессы</li>
    <li>прерывания  от терминала, например при нажатии определенной комбинации клавиш</li>
    <li>управление  заданиями, это извещение родителя о завершении или приостановке дочернего  процесса, управление фоновыми и текущим процессами;</li>
    <li>квоты,  при превышении процессом временных квот или размера файла</li>
    <li>уведомления,  например, о готовности устройства в/в</li>
    <li>будильники.</li>
  </ul>
  <p>Для поддержки механизма сигналов в  структуре u  содержатся следующие поля:<br />
    u_signal[] вектор обработчиков для каждого сигнала<br />
    u_sigmask[] маски сигналов, ассоциированных с каждым обработчиком<br />
    u_sigaltstack указатель на альтернативный стек сигнала<br />
    u_sigonstack маска сигналов, обрабатываемых с альтернативным стеком<br />
    u_oldsig набор обработчиков для имитации базового механизма сигналов<br />
    Структура proc также содержит несколько полей :<br />
    p_cursig текущий сигнал, обрабатываемый в данный момент<br />
    p_sig маска  ожидающих сигналов<br />
    p_hold маска блокируемых сигналов<br />
    p_ignore маска игнорируемых сигналов</p>
  <p>Перечень некоторых типовых сигналов:<br />
    <strong>Сигнал&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; описание&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; действие  по умолчанию</strong><br />
    SIGABRT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; процесс  аварийно завершен&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; abort <br />
    SIGALRM&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; сигнал  тревоги реального времени&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit <br />
    SIGCHLD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; потомок  завершил работу или приостановлен&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ignore <br />
    SIGCONT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; возобновить  приостановленный процесс&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ignore <br />
    SIGFPE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; арифметическая  ошибка&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; abort <br />
    SIGILL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; недопустимая  инструкция&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; abort <br />
    SIGINT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; прерывание  терминала&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit <br />
    SIGKILL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; завершить  процесс&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit <br />
    SIGPIPE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; запись  в канал при отсутствии считывающих процессов&nbsp; exit <br />
    SIGQUIT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; выход  из терминала&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; abort <br />
    SIGSEGV&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ошибка  сегментации&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; abort <br />
    SIGSTOP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; остановить  процесс&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stop <br />
    SIGSYS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; неверный  системный вызов&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit <br />
    SIGTERM&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; завершить  процесс&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit <br />
    SIGUSR1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; определяется  процессом&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit <br />
    SIGUSR2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; определяется  процессом&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit </p>
  <p>В Windows для оповещения процессов о возникновении каких-либо событий  используется концепция <strong>сообщений</strong>.  Существует около 900 различных типов сообщений. Каждый тип сообщений имеет свой  числовой идентификатор. В случаях, когда пользователь выбирает пункт меню,  щелкает на кнопке, или выбирает из списка и т.д. формируется сообщения специального  типа WM_COMMAND или WM_NOTIFY. Сообщения этих типов принято называть <strong>командами</strong>. Процесс может передавать  сообщения с помощью функции Win32 API <strong>PostMessage</strong> или <strong>PostThreadMessage</strong>,  в первом случае указывается, какому окну передается сообщение, во втором &ndash;  какому потоку. Остальные параметры указывают собственно сообщение, и дополнительную  информацию. Сообщение помещается в специальную очередь сообщений, связанную с  потоком, которому они посланы. Получить сообщение из этой очереди можно  функцией <strong>GetM</strong><strong>e</strong><strong>ssage</strong>. Идентификаторы от 0 до WM_USER &ndash; 1 используются для сообщеинй Windows, от WM_USER до 0x7FFF, от 0x8000 до  0xBFFF зарезервированы для последующего использования Windows, от 0xC000 до 0xFFFF строковые сообщения пользователя, от 0xFFFF  и выше &ndash; зарезервированы Windows.</p>
<p align="center">&nbsp;</p>

</BODY>
</HTML>