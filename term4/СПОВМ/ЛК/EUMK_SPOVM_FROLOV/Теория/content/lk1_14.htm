<!-- (C) 2011-2012 V.Prytkov, V. Suponev, A.Uvarov. BSUIR -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//RU">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1251">
<META HTTP-EQUIV="Content-Language" CONTENT="ru">
<link rel="stylesheet" type="text/css" href="../css/style.css" />
<title>Лекция №14. Понятие  файловой системы.</title>
<base target="_top">
</HEAD><BODY>
  <p align="center"><strong>Понятие  файловой системы</strong></p>
  <p><em>Функции  файловой системы. Понятие файла. Структура файла. Типы файлов. Регулярные файлы  и каталоги. Специальные файлы.&nbsp; Файлы с  последовательным и произвольным доступом. Структуры управления файлами.  Атрибуты файла. Отображение файлов на память. Непрерывная организация файлов на  диске, связные списки, i-узлы. Каталоги. Одноуровневая, двухуровневая и  иерархическая структуры каталогов. Имена файлов. Совместно используемые файлы.  Символьное связывание. Учет свободных блоков. Монтирование. Непротиворечивость  файловой системы. Журналирование и каскадный откат транзакций. Кэширование.  Типовые операции файловой системы </em></p>
  <p>К долговременным устройствам хранения информации предъявляют  следующие требования:</p>
  <ol>
    <li>устройства должны позволять хранить  очень большие объемы данных</li>
    <li>информация должна сохраняться после  прекращения работы процесса, использующего ее</li>
    <li>несколько процессов должны иметь  возможность получения одновременного доступа к информации</li>
  </ol>
  <p>Обычное решение этих задач состоит в хранении информации на  дисках и других носителях в модулях, называемых <strong>файлами.</strong> По мере необходимости процессы могут читать и создавать  файлы. Информация в файлах должна обладать устойчивостью, т.е. на нее не должны  оказывать влияние создание или прекращение работы какого либо процесса. Файл  должен исчезать только тогда, когда его владелец даст команду удаления файла.  Файлами управляет ОС. Их структура, именование, использование, защита,  реализация и доступ к ним являются важными нюансами ОС. Часть ОС, работающая с  файлами и определяющая эти свойства, называется системой управления файлами или  файловой системой. Помимо работы с файлами, ФС может позволять работать с  недисковыми устройствами, как с файлами. ОС может позволять работать с  несколькими ФС. С другой стороны, ФС называется также определенный способ  организации данных на диске. Система управления файлами не существует сама по  себе, она разрабатывается для работы с конкретной ФС в конкретной ОС. </p>
  <p>Файлы относятся к абстрактному механизму и предоставляют  способ сохранять информацию на диске и считывать ее. От пользователя скрываются  такие детали как способ и место хранения информации, а также детали работы  дисков. При создании файла процесс дает файлу имя. В разных системах  используются разные правила именования, но большинство поддерживает  8-символьные текстовые строки. Часто разрешается использование в имени цифр и  специальных символов, многие системы поддерживают имена длиной до 255 символов.  Некоторые ОС (UNIX) различают строчные и прописные символы, другие (MS-DOS)  нет. Windows использует файловую систему MS-DOS и наследует многие ее свойства,  однако NT имеет свою ФС NTFS. Во многих ОС используется расширение, как правило  означающее тип файла. В MS-DOS расширение содержит до 3 символов, в UNIX его  длина зависит от пользователя. У файла может быть несколько расширений.  Расширение файла является всего лишь декларативным и не носит обязательный  характер. Т.е. ехе скорее всего является исполняемым файлом, но это не является  обязательным. </p>
  <p>Файлы могут быть структурированы различными способами. 1.  Файл может восприниматься как неструктурированная последовательность байт. В  этом случае ОС не интересуется содержимым файла. Она видит только байты.  Значение этим байтам придается в программах пользователя. Этот подход обеспечивает  максимальную гибкость. Программы могут помещать в файл все что угодно и  именовать любым удобным способом, а ОС не смешивается в этот процесс. 2. Файл  представлен последовательностью записей фиксированной длины, каждая со своей  внутренней структурой. Для таких файлов операция чтения и записи возвращает или  пишет одну запись полностью. 2. Файл может представлять собой дерево записей,  не обязательно одинаковой длины. Каждая запись в фиксированной позиции содержит  поле ключа. Дерево отсортировано по ключу, что обеспечивает быстрый поиск.  Здесь главная операция не получение следующей записи, а получение записи с  указанным значением ключа.</p>
  <p>ОС поддерживают в общем случае различные типы файлов.  Например, в UNIX и Windows различают регулярные файлы и каталоги. <strong>Регулярные</strong> &ndash; все файлы, которые  содержат информацию пользователя. <strong>Каталоги</strong> &ndash; это системные файлы, обеспечивающие поддержку структуры файловой системы. В  UNIX поддерживаются символьные <strong>специальные</strong> файлы и блочные специальные файлы. ССФ используются для моделирования  последовательных устройств вв, например, терминалы, принтеры, сеть и т.д. БСФ  используются для моделирования дисков. Регулярные файлы в основном являются  либо ASCII-файлами либо двоичными. Код конца строки различен в разных системах.  Это может быть ВК, ПС (UNIX), оба (MS-DOS). ASCII файлы могут отображаться на  экране и выводиться на печать так как есть, без какого-либо преобразования.</p>
  <p><strong>Доступ к  данным</strong> может быть последовательный, когда  чтение или запись могут идти только последовательно, байт за байтом, или  произвольный, когда чтение или запись могут выполняться в произвольном порядке  или получать доступ к записям по ключу.&nbsp; </p>
  <p>У каждого файла есть имя и данные. Дополнительная  информация, связанная с файлом и учитываемая ОС, называется <strong>атрибутами</strong>. Наиболее распространенные:  защита (кто и каким образом может получить доступ к файлу), пароль, создатель  (идентификатор пользователя, создавшего файл), владелец, флаг только для  чтения, флаг скрытый, флаг системный, флаг архивный, флаг ASCII/двоичный, флаг  произвольного доступа, временный (удаляется по окончании процесса), флаг блокировки,  длина записи, позиция ключа, длина ключа, время создания, время последнего  доступа, время последнего изменения, текущий размер, максимальный размер.</p>
  <p>&nbsp;Стандартный способ  доступа к файлу сильно отличен от доступа к памяти. Для того, чтобы  использовать единообразный интерфейс, файлы в некоторых ОС могут отображаться  на память. Это можно представить в виде двух системных вызовов &ndash; map и&nbsp; unmap. Первый имеет на входе два параметра &ndash;  имя файла и виртуальный адрес памяти, по которому ОС отображает этот файл.  Когда процесс завершает работу, модифицированный файл из памяти выгружается на  диск. В итоге все словно происходит так, как если бы использовали seek и write.  При записи в файл соответствующая страница памяти помечается как  модифицированная. Если эта страница памяти выгружается алгоритмом замены  страниц, она записывается в соответствующую область файла. Отображение на  память лучше всего работает при сегментной организации памяти. В этом случае каждый  файл может отображаться на свой сегмент. Хотя отображение на память устраняет  необходимость обращения к системным вызовам ввода-вывода, имеются следующие  вопросы:<br />
    - ОС трудно определить длину выходного файла, т.е. ОС знает  номер модифицированной страницы, но она не может определить, сколько байт было  туда записано. Второй вопрос &ndash; при попытке открыть файл, уже открытый другим  процессом. Каждый из процессов будет модифицировать свою копию файла в памяти,  т.е. изменения, сделанные одним, не будут доступны другим, пока файл открыт.  Требуется особый механизм. Третий &ndash; файл может оказаться больше сегмента памяти  и даже больше, чем все доступное виртуальное адресное пространство.</p>
  <p><img src="../images/1sem_theory_p13_clip_image002.gif" alt="1" width="483" height="108" hspace="12" align="right" /><strong>Реализация файловой системы.</strong> Простейший  вариант организации самого файла на диске &ndash; <strong>непрерывный</strong>, когда файл занимает соседние блоки диска. Такая  система легко организуется, обладает высокой производительностью, однако  система очень быстро подвергается фрагментации. Этот вариант организации файлов  широко используется в СD_ROМ. Второй вариант &ndash; <strong>связные списки</strong>. В начале каждого блока, принадлежащего файлу,  находится указатель на следующий блок. В этом случае фрагментация не так  опасна, существенно снижаются потери дискового пространства, в каталоге  достаточно хранить только адрес первого блока. Однако произвольный доступ к  такому файлу достаточно медленный, поскольку требуется пробежать всю цепочку  блоков от начала файла, чтобы найти нужный блок. Третий вариант &ndash; организация  таблицы связных списков. </p>
  <table border="1" cellspacing="0" cellpadding="0">
    <tr>
      <td width="63" valign="top"><br />
        Файл А </td>
      <td width="29" valign="top"><p>4</p></td>
      <td width="48" valign="top"><p>&nbsp;</p></td>
      <td width="29" valign="top"><p>0</p></td>
      <td width="34" valign="top"><p>&nbsp;</p></td>
    </tr>
    <tr>
      <td width="63" valign="top"><p>Файл В</p></td>
      <td width="29" valign="top"><p>6</p></td>
      <td width="48" valign="top"><p>&nbsp;</p></td>
      <td width="29" valign="top"><p>1</p></td>
      <td width="34" valign="top"><p>-1</p></td>
    </tr>
    <tr>
      <td width="63" valign="top"><p>&nbsp;</p></td>
      <td width="29" valign="top"><p>&nbsp;</p></td>
      <td width="48" valign="top"><p>&nbsp;</p></td>
      <td width="29" valign="top"><p>2</p></td>
      <td width="34" valign="top"><p>8</p></td>
    </tr>
    <tr>
      <td width="63" valign="top"><p>&nbsp;</p></td>
      <td width="29" valign="top"><p>&nbsp;</p></td>
      <td width="48" valign="top"><p>&nbsp;</p></td>
      <td width="29" valign="top"><p>3</p></td>
      <td width="34" valign="top"><p>1</p></td>
    </tr>
    <tr>
      <td width="63" valign="top"><p>&nbsp;</p></td>
      <td width="29" valign="top"><p>&nbsp;</p></td>
      <td width="48" valign="top"><p>&nbsp;</p></td>
      <td width="29" valign="top"><p>4</p></td>
      <td width="34" valign="top"><p>7</p></td>
    </tr>
    <tr>
      <td width="63" valign="top"><p> </p></td>
      <td width="29" valign="top"><p>&nbsp;</p></td>
      <td width="48" valign="top"><p>&nbsp;</p></td>
      <td width="29" valign="top"><p>5</p></td>
      <td width="34" valign="top"><p>&nbsp;</p></td>
    </tr>
    <tr>
      <td width="63" valign="top"><p>&nbsp;</p></td>
      <td width="29" valign="top"><p>&nbsp;</p></td>
      <td width="48" valign="top"><p>&nbsp;</p></td>
      <td width="29" valign="top"><p>6</p></td>
      <td width="34" valign="top"><p>3</p></td>
    </tr>
    <tr>
      <td width="63" valign="top"><p>&nbsp;</p></td>
      <td width="29" valign="top"><p>&nbsp;</p></td>
      <td width="48" valign="top"><p>&nbsp;</p></td>
      <td width="29" valign="top"><p>7</p></td>
      <td width="34" valign="top"><p>2</p></td>
    </tr>
    <tr>
      <td width="63" valign="top"><p>&nbsp;</p></td>
      <td width="29" valign="top"><p>&nbsp;</p></td>
      <td width="48" valign="top"><p>&nbsp;</p></td>
      <td width="29" valign="top"><p>8</p></td>
      <td width="34" valign="top"><p>-1</p></td>
    </tr>
  </table>
  <p>В этом случае указатели на блоки хранятся не в самих блоках,  а в отдельной таблице, загружаемой в память. Эта таблица называется FAT file  allocation table. Основной недостаток в том, что вся таблица должна полностью  находиться в памяти. При диске большого объема размер таблицы существенно  вырастает, для его уменьшения можно использовать увеличенный размер блока, но в  этом случае возрастают потери дискового пространства. Вариант <strong>с i-узлами</strong> состоит в связывании с  каждым файлом специальной структуры данных, index node &ndash; индексный узел,  содержащий атрибуты файла и несколько записей для хранения адресов блоков  файла. Преимущество в том, что i-узел находится в памяти только тогда, когда  соответствующий ему файл открыт. Если файл небольшой, вся информация о его  размещении хранится в i-узле. В  случае, если выделенного в i-узле числа записей для адресов блоков недостаточно,  имеется запись, содержащая адрес блока косвенной адресации, содержащего продолжение  таблицы с адресами блоков файла. Если этого недостаточно, используется запись,  содержащая адрес блока двойной косвенной адресации. В этом блоке содержатся  указатели на блоки, в которых содержится продолжение таблицы с адресами блоков.  Если и этого недостаточно, используется запись, содержащая адрес блока тройной  косвенной адресации. Такую схему использует UNIX,  а также ФС HPFS, NTFS  и др. Это позволяет поддерживать i-узлы фиксированного размера и вместе с тем работать с  файлами размером от нескольких байт до нескольких Гб. </p>
  <p>Файлы обычно организуются в <strong>каталоги</strong>, которые в свою очередь, являются файлами. Структуры  каталогов. <strong>Одноуровневая</strong>. Имеется  один каталог, в котором содержатся все файлы. Использовалась в ранних ВМ.  Преимущества: простота и быстрота поиска файла. Недостатки: различные  пользователи могут использовать для своих файлов одинаковые имена. <strong>Двухуровневая</strong>. Каждому пользователю  выделяется каталог. При этом одинаковые имена файлов у разных пользователей уже  не конфликтуют друг с другом. <strong>Иерархическая</strong>.  При большом количестве файлов возникает необходимость логически группировать  файлы. Т.о. необходимо дерево каталогов. Для указания файла требуется указывать  путь, по которому он находится. Это либо абсолютное имя пути, начиная с  корневого каталога и заканчивая тем, где расположен файл, либо относительное  имя, указываемое относительно рабочего каталога. У каждого процесса свой  рабочий каталог. Большинство ОС с иерархической структурой каталогов имеют  специальные элементы в каждом каталоге &ldquo;.&rdquo; &rdquo;..&rdquo;.&nbsp; Означающие соответственно текущий каталог и  родительский каталог. </p>
  <p><strong>Реализация  каталогов</strong>. Запись в каталоге содержит  информацию, необходимую для нахождения блоков диска. В зависимости от системы  это может быть дисковый адрес всего файла для&nbsp;  непрерывных файлов, номер первого блока файла или номер i-узла.  Различные атрибуты файла, поддерживаемые файловой системой, могут храниться  непосредственно в записи каталога.&nbsp; В  этом случае запись каталога имеет фиксированную длину. Системы, использующие  i-узлы, &nbsp;могут хранить атрибуты в узлах,  а не в записях каталога. В этом случае запись каталога существенно короче &ndash; имя  файла и номер i-узла. </p>
  <p>Современные ОС поддерживают длинные имена файлов. В  простейшем случае длина имени файла ограничивается 255 символами, и  используются уже рассмотренные схемы хранения. Однако далеко не все файлы имеют  максимальную длину, и большая часть отведенного пространства пустует.  Альтернативный подход &ndash; когда поле записи, содержащее имя файла имеют  переменную длину. В этом случае первое поле записи каталога хранит длину записи  либо имени файла, далее следуют поля фиксированной длины с атрибутами файла,  далее &ndash; имя файла, выровненное на границу слова. Недостаток такого подхода &ndash;  при удалении файла остается свободная область переменной длины, в которую  далеко не всегда можно поместить новую запись каталога, т.е. каталог  фрагментируется. Еще один недостаток &ndash; запись может занимать несколько страниц  памяти. При чтении такой записи нужной страницы может не оказаться в памяти.  Еще один вариант реализации длинных имен &ndash; сделать записи каталога одинаковой  длины, и хранить в нем не имя файла, а указатель на него, сами имена же хранить  в куче. В этом случае фрагментация каталога отсутствует, но будет  фрагментироваться память в куче. Все рассмотренные схемы предусматривают при  поиске файла просмотр каталога линейно сверху вниз. Для очень больших каталогов  такой поиск требует много времени. Часто для поиска используют хэш-таблицы для  каждого каталога. В зависимости от имени файла ему присваивается некоторый  номер из диапазона 0&nbsp; -&nbsp; N-1, где N &ndash; длина хэш-таблицы. При  добавлении файла, если элемент хэш-таблицы с данным номером свободен, туда  помещается указатель на запись каталога для данного файла, если же элемент  занят, то создается связный список, объединяющий все записи каталога с данным  хэш-кодом. аналогично выполняется поиск: вычисляется хэш, и просматривается  список, соответствующий ему.</p>
  <p><strong>Совместно  используемые файлы</strong>. Часто удобно, чтобы один и тот же  физический файл содержался в разных каталогах. В этом случае между каталогом и  совместно используемым файлом устанавливается связь. Сама файловая система  представляет теперь не дерево, а ориентированный ациклический граф. Такая схема  создает новые проблемы. Если в каталоге содержать указатели на блоки файла, то  при изменении файла из одного каталога, соответствующая ему запись другого  каталога не будет содержать измененной цепочки блоков. Первый вариант решения &ndash;  содержать указатели на блоки файла в особой структуре, а в каталоге содержать  только ссылку на эту структуру. В этом случае даже при перемещении файла (но не  i-узла) все связи останутся действующими. Второй вариант &ndash;  при создании связи, во втором каталоге создается новый файл типа связь (link).  Он просто содержит путь к файлу, с которым он связан. Это называется <strong>символьным связыванием</strong>. Дополнительное  преимущество символьных связей &ndash; в том, что их можно использовать для ссылок на  файлы, расположенные на удаленных машинах. Оба способа имеют проблемы. В первом  случае, если файл существует в нескольких каталогах, то при удалении его из  одного каталога, ОС не может найти все связи, поэтому может только удалить  запись в одном каталоге, оставив и сам файл и записи других каталогов, ему  соответствующих, уменьшая счетчик связей. При символьном связывании такой  проблемы не возникает. Однако при этом увеличивается время поиска &ndash; поскольку  сначала находится лишь файл связи, а затем, взяв из него правильный путь,  ищется собственно файл. Кроме того, при перемещении файла ссылка становится нерелевантной,  т.е. связь теряется. <br />
    При разработке файловой системы важным показателем является <strong>размер блока</strong>. Чем он больше, тем выше  скорость чтения-записи файла, но тем ниже эффективность использования дискового  пространства. <strong>Учет свободных блоков</strong> может производиться двумя разными способами &ndash; либо связный список свободных  блоков, либо битовая карта, в которой один бит соответствует одному блоку  диска. </p>
  <p>Для качественной работы ФС требуется вести учет свободных  блоков. Используются два подхода, как и в случае учета свободных блоков памяти  &ndash; битовый вектор и связный список. Первый вариант эффективен, если битовая  карта помещается в памяти целиком. Например, для диска 40 Гб и блоке в 512 б  размер битового вектора составляет 10 Мб. Связный список не эффективен, если  требуется получить адреса нескольких свободных блоков, поскольку это ведет к  увеличению обращений к диску при поиске блоков. Используют и модифицированный  вариант связного списка. В этом случае в первом свободном блоке хранятся адреса  N-свободных блоков. N-1 из них  действительно являются свободными, а последний адрес указывает на следующий  блок с адресами свободных блоков. </p>
  <p>Монтирование. Файловая система, хранящаяся на разделе диска,  должна быть связана с существующей иерархией файловых систем, чтобы стать  доступной процессам системы. Mount, umount. В общем случае, в Windows монтирование происходит автоматически, раздел подключается  на корневом уровне, и ему присваивается определенная буква, являющаяся  начальным путем. ФС UNIX  организована иначе. На корневом уровне находится ряд каталогов &ndash; usr, bin, home, dev  и т.д. Файловый системы монтируются в  каталог mnt.<u></u></p>
  <p><strong>Непротиворечивость  файловой системы</strong>. Этот вопрос относится к проблеме  непротиворечивости ФС. ФС обычно читают блоки данных, изменяют их и записывают  обратно. Если в системе произойдет сбой прежде, чем все измененные блоки будут  записаны на диск, ФС может оказаться в противоречивом состоянии. Это особенно  важно, если таким измененным и не сохраненным блоком оказывается блок i-узла,  каталога или списка свободных блоков. Всоставе ОС имеется специальная утилита,  проверяющая ФС на непротиворечивость. В UNIX это fsck, в Windows &ndash; scandisk.  Fsck работает следующим образом. Для проверки непротиворечивости блоков  создается две таблицы, каждая из которых содержит счетчик для каждого из блоков,  изначально нулевые. Счетчики первой таблицы учитывают, сколько раз каждый блок  присутствует в файлах. Во второй &ndash; сколько раз блок учитывается в списке  свободных блоков. Считываются все i-узлы. При считывании каждого номера блока  соответствующий счетчик увеличивается на 1. Далее анализируется список  свободных блоков, при считывании номера блока увеличивается соответствующий  счетчик во второй таблице. Если ФС непротиворечива, то каждый блок будет  встречаться только один раз, либо в первой, либо во второй таблице. В случае.  если для какого-то блока содержится 0 в обеих таблицах, это говорит о  недостающем блоке. Ошибка корректируется добавлением этого блока в список  свободных. Если какой-то блок появляется многократно в списке свободных блоков,  проблема также легко решается. Хуже, если один и тот же блок окажется в разных  файлах. При удалении любого из этих файлов, блок будет перемещен в список  свободных, оставаясь в тоже время используемым в остальных файлах. В этом  случае такой блок копируется нужное количество раз в свободные, и блок заменяется  на них в этих файлах. Проверяется и структура каталогов. Используется таблица  счетчиков, но не для блоков, а для файлов. Проверка идет рекурсивно начиная с  корневого каталога. Символьная связь счетчик не изменяет. В результате сканирования  образуется список, с информацией, в скольких каталогах содержится тот или иной  файл. Эти числа сравниваются с действительным числом использований, хранящимся  в i-узле. В непротиворечивой ФС счетчики совпадают. Если счетчик связей в  i-узле больше, чем рассчитано, то даже при удалении файла из всех связанных  каталогов, счетчик не обнулится, в итоге в системе будет существовать  потерянный файл, занимая дисковое место. Если же наоборот, счетчик связей  i-узла меньше, чем рассчитано, то при удалении файла из части каталогов,  счетчик обнулится и система освободит блоки файла, и в системе окажутся ссылки  на несуществующий флаг. В обоих случаях для решения проблемы следует уравнивать  значения счетчиков. Это не восстановит потерянную информацию, однако ФС будет  непротиворечивой. </p>
  <p>Еще один вариант повышения надежности &ndash; <strong>журналирование</strong> операций, и если произошел критический сбой,  восстановление до непротиворечивого состояния. В ФС протоколируются не все  изменения, а только изменения метаданных &ndash; i-узлов,  записей в каталогах и т.д. Изменение пользовательских данных не  протоколируется. Журнализация реализована в NTFS,  Ext3FS, ReiserFS и  др. Имеется ряд проблем, например, при необходимости выполнить откат, может  оказаться, что откат может затрагивать данные, уже измененный другими файловыми  операциями. Поэтому и они тоже должны быть отменены. Эта проблема называется  каскадным откатом транзакций.</p>
  <p><strong>Увеличение  производительности ФС</strong>. <strong>Кэширование</strong> Кэшем называется набор блоков, логически принадлежащий диску, но хранящийся в  памяти для увеличения производительности. Существуют разные алгоритмы  управления кэшем. Типовой вариант - перехват всех обращений к диску и проверка  наличия соответствующих блоков в кэше. Если блок в кэше, он считывается оттуда,  если нет, то он сначала с диска копируется в кэш, а уже затем в нужную область  памяти. Последующие обращения к этому блоку будут уже выполняться не с диском,  а с кэшем. Для быстрого определения, имеется ли нужный блок в кэше или нет,  обычно используется хэширование номера устройства и номера блока с поиском  соответствующего кода в хэш-таблице. Все блоки с одинаковыми хэш-кодами  организуются в связный список. Когда требуется загрузить блок в полностью  загруженный кэш, должно выполниться замещение одного из ранее загруженных  блоков. Это аналогично ситуации с замещением страниц памяти и допустимы все  соответствующие алгоритмы (FIFO, вторая попытка, LRU). Все блоки можно  разделить на категории, например, блоки i-узлов, косвенные блоки, блоки  каталогов, блоки, полностью заполненные данными и блоки, частично заполненные  данными. Блоки, которые в ближайшее время вероятнее всего не потребуются, помещаются  в начало списка LRU, чтобы их буферы освобождались первыми. Блоки, вероятность  повторного использования которых высока, помещаются в конец списка. Кроме  этого, если блок важен для сохранения непротиворечивости ФС, например, блок  i-узла, то при модификации такой блок сохраняется на диске немедленно,  независимо от положения в списке. Но и в этом случае хранение в кэше блоков с  данными слишком долго нежелательно. В UNIX имеется системный вызов sync, принудительно  сохраняющий все модифицированные блоки кэша на диск. При загрузке ОС  запускается фоновая задача, обычно называющаяся update, которая периодически  вызывает sync. В MS-DOS модифицированный блок записывается сразу же, это  называется кэшем со сквозной записью. </p>
  <p>Типовые системные вызовы для работы с файлами:<br />
    Create). Delete. Open &ndash; позволяет системе прочитать в память  атрибуты файла и список дисковых адресов для быстрого доступа к файлу при  последующих вызовах. Close. Освобождается внутренняя структура с информацией об  открытом файле. Read. Write. Append. ..Seek. Get_attributes. Set_attributes.  Rename. </p>
  <p>Windows.  CreateFile, CloseHandle. ReadFile,  WriteFile. ReadFileGather и WriteFileGather позволяют  выполнять операции чтения-записи с использованием набора буферов различного  размера. DeleteFile. CopyFile.  CreateHardLink &ndash; Для NT5 (2K, WS2003, XP) создание жесткой ссылки! не ярлыка!, аналогично ссылкам в UNIX. SetFilePointer.  Помимо использования явного позиционирования, для обновления записи в файле,  чтобы не гонять туда-сюда указатель, можно использовать параметр hEvent  структуры типа OVERLAPPED, использующейся в ReadFile, WriteFile.  GetFileSize. SetEndOfFile  &ndash; переустанавливает размеры файла. FindFirstFile,  FindNextFile, FindClose.  GetFileTime.GetFileAttributes.  GetTempFileName &ndash; предоставляет уникальное имя для временного файла в  заданном каталоге. LockFile  (LockFileEx) &ndash; блокирование файла или части файла монопольно либо  разделяемо. UnlockFileEx. </p>
  <table border="1" cellspacing="0" cellpadding="0">
    <tr>
      <td width="206" valign="top"><br />
        Существующая блокировка </td>
      <td width="118" valign="top"><p>Запрашивается Разделяемая Блок.</p></td>
      <td width="113" valign="top"><p>Запрашивается монопольная блок</p></td>
      <td width="151" valign="top"><p>Чтение</p></td>
      <td width="151" valign="top"><p>Запись</p></td>
    </tr>
    <tr>
      <td width="206" valign="top"><p>&nbsp;Отсутствует</p></td>
      <td width="118" valign="top"><p>&nbsp;Предоставляется</p></td>
      <td width="113" valign="top"><p>Предоставляется</p></td>
      <td width="151" valign="top"><p>Выполняется</p></td>
      <td width="151" valign="top"><p>Выполняется</p></td>
    </tr>
    <tr>
      <td width="206" valign="top"><p>Разделяемая (одна или несколько)</p></td>
      <td width="118" valign="top"><p>Предоставляется</p></td>
      <td width="113" valign="top"><p>Отказ</p></td>
      <td width="151" valign="top"><p>Выполняется.</p></td>
      <td width="151" valign="top"><p>Не выполняется.</p></td>
    </tr>
    <tr>
      <td width="206" valign="top"><p>Монопольная</p></td>
      <td width="118" valign="top"><p>Отказ</p></td>
      <td width="113" valign="top"><p>Отказ</p></td>
      <td width="151" valign="top"><p>Выполняется, если вызывающий процесс является владельцем    блокировки</p></td>
      <td width="151" valign="top"><p>Выполняется, если вызывающий процесс является владельцем    блокировки</p></td>
    </tr>
  </table>
  <p>&nbsp;<br />
    Основные операции с каталогами. Create. Delete. OpenDir.  Открыть каталог для чтения. CloseDir.ReadDir &ndash; чтение очередного элемента  каталога. Rename. Link. Связывание позволяет одному и тому же файлу  отображаться сразу в нескольких каталогах. Файл связывается с каталогом, в  котором должна появиться ссылка на него. Unlink.  Windows: CreateDirectory,  RemoveDirectory.SetCurrentDirectory,  GetCurrentDirectory. SetVolumeMountPoint  &ndash; монтирование одной ФС в точке монтирования, находящейся в другой ФС. DeleteMountPoint.</p>

</BODY>
</HTML>