<!-- (C) 2011-2012 V.Prytkov, V. Suponev, A.Uvarov. BSUIR -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//RU">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1251">
<META HTTP-EQUIV="Content-Language" CONTENT="ru">
<link rel="stylesheet" type="text/css" href="../css/style.css" />
<title>Лекция №8. Обработка  тупиковых ситуаций.</title>
<base target="_top">
</HEAD><BODY>
  <p align="center"><strong>Обработка  тупиковых ситуаций</strong></p>
  <p><em>Понятие  тупика. Условия Коффмана. Модель Холта. Модель пространства состояний.  Надежное, опасное и безопасное состояния. Обнаружение тупика при наличии одного  ресурса каждого вида. Обнаружение тупика при наличии нескольких ресурсов  каждого вида. Выход из взаимоблокировки. Обход и предотвращение тупиковой ситуации.  Двухфазовое блокирование. Проблема &ldquo;голодания&rdquo;</em></p>
  <p>Ситуация, когда каждый из параллельных процессов ожидает  освобождения ресурса, занятого другим процессом из данного множества,  называется <strong>взаимоблокировкой</strong>, или  тупиком. Для использования ресурса выполняется следующая последовательность  действий: запрос, использование, освобождение. Один из способов разграничения  доступа &ndash; использование семафоров, присоединенных к каждому из ресурсов. Для  запроса используется вызов down(), а для  освобождения&nbsp; up().  Рассмотрим случай, когда процессу необходимо 2 или больше ресурсов:</p>
  <p>typedef int  semaphore<br />
    semaphore rc1,  rc2;</p>
  <p>void  process_A(void)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void  process_B(void)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void  process_C(void)<br />
    {down(&amp;rc1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {down(&amp;rc1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {down(&amp;rc2);<br />
    down(&amp;rc2);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; down(&amp;rc2);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; down(&amp;rc1);<br />
    use_2_resources();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; use_2_resources();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; use_2_resources();<br />
    up(&amp;rc2);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; up(&amp;rc2);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; up(&amp;rc1);<br />
    up(&amp;rc1);}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; up(&amp;rc1);}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; up(&amp;rc2);}</p>
  <p>Пусть пока в системе только 2 процесса А и В. В этом случае  никакая взаимоблокировка невозможна. Действительно, если процесс А получит  доступ к ресурсу 1, процесс В будет заблокирован на получении доступа. Процесс  1 блокирует второй ресурс, использует ресурсы, и освобождает их, после чего  доступ получает второй процесс. В случае, если это процессы А и С возможна  следующая ситуация: процесс А захватил ресурс 1, диспетчер переключил процессы,  процесс С получил управление и захватил ресурс 2. Теперь процесс А ожидает  освобождение ресурса 2, а процесс С &ndash; ресурса 1.&nbsp; Произошла взаимоблокировка. Т.о., на  взаимоблокировки существенное влияние может оказывать код программы. Однако в  системе, в которой существует несколько самых разных видов ресурсов, и за  доступ к которым конкурируют несколько процессов предусмотреть корректное  написание последовательности запросов не представляется возможным. </p>
  <p>Коффман доказал, что для возникновения взаимоблокировки  необходимо выполнение следующих 4 условий:</p>
  <ol>
    <li>условие взаимного исключения. Каждый  ресурс в данный момент времени или отдан ровно одному процессу, или доступен</li>
    <li>Условие удержания и ожидания. Процессы,  в данный момент удерживающие полученные ранее ресурсы, могут запрашивать новые  ресурсы</li>
    <li><img src="../images/1sem_theory_p8_clip_image002.gif" alt="1" width="238" height="152" hspace="12" align="right" />-  условие отсутствия принудительной выгрузки ресурса. У процесса нельзя  принудительным образом забрать ранее полученные ресурсы. Процесс-владелец  должен сам освободить их.</li>
    <li>условие циклического ожидания. Должна  существовать круговая последовательность из двух и более процессов, каждый из  которых ждет доступа к ресурсу, удерживаемому следующим членом  последовательности.</li>
  </ol>
  <p>Для моделирования взаимоблокировок используют графы:<br />
    Ребро, направленное от ресурса к процессу, означает, что  ресурс ранее был запрошен процессом, получен и в данный момент используется  процессом. Ребро, направленное от процесса к ресурсу. означает, что процесс в  данный момент блокирован и находится в состоянии ожидания доступа к этому  ресурсу. Далее показана ситуация взаимоблокировки: Процесс А ожидает ресурс,  который захвачен процессом В, а процесс В ожидает ресурс, который захвачен процессом  А. В обозначении ресурса может быть указано число доступных единиц ресурса.  Число ребер, исходящих из ресурса, не может превышать числа единиц этого  ресурса. Модель, представленную таким графом, называют моделью повторно используемых  ресурсов Холта.</p>
  <p>Возможны 4 стратегии при решении проблемы тупиковых  ситуаций:</p>
  <ol>
    <li>пренебрежение проблемой. </li>
    <li>Обнаружение и восстановление: позволить  взаимоблокировке произойти, обнаружить ее и предпринять какие-либо действия.</li>
    <li>предотвращение тупиковой ситуации с  помощью структурного опровержения одного из четырех условий, необходимых для  взаимоблокировки</li>
    <li>избегание тупиковых ситуаций с помощью  аккуратного распределения ресурсов</li>
  </ol>
  <p>Фактически тупиковые ситуации возможны не только при борьбе  за ресурсы устройств ввода-вывода. Например, в системе всегда ограничивается  максимальное число открытых файлов. Пусть это 100. В системе существует 10  процессов, каждый из которых требует открытия 12 файлов. Возможна ситуация,  когда каждый из этих процессов откроет ровно 10 файлов, полностью исчерпав  ресурс таблицы. Ни один из процессов не сможет продолжить работу.&nbsp; Большинство ОС игнорируют такую  проблему.&nbsp; </p>
  <p><strong>Обнаружение  взаимоблокировок. При наличии в системе одного ресурса каждого вида.</strong><br />
    <img src="../images/1sem_theory_p8_clip_image004.gif" alt="2" width="253" height="174" hspace="12" align="right" /><img src="../images/1sem_theory_p8_clip_image006.gif" alt="3" width="355" height="388" hspace="12" align="left" />Для  системы подобного рода удобно построить граф и проанализировать его. Если на  графе нет замкнутых циклов, то взаимоблокировка отсутствует. В примере процессы  АСF не попали в тупик, любому из них система предоставит ресурс  2, процесс его получит, использует и вернет, после чего ресурс сможет быть  предоставлен другому процессу. Вместе с тем в графе содержится цикл, соответствующие  процессы которого находятся во взаимоблокированном состоянии.</p>
  <p>Рассмотрим алгоритм поиска в графе замкнутых циклов.  Алгоритм использует одну единственную структуру данных &ndash; список узлов L. <br />
    Алгоритм по очереди берет каждый узел в качестве корня того,  что, как он надеется, окажется деревом, и выполняет в дереве поиск в глубину.  Если при этом происходит возврат к уже пройденному узлу, то обнаружен цикл.  Если алгоритм прошел уже все ребра какого-либо узла, то он возвращается к  предыдущему узлу. Если при этом он вернулся к корню, то подграф текущего узла  не содержит циклов и проверяется следующая вершина. </p>
  <p>Еще один вариант&nbsp; -  это редукция графа в модели Холта. В этом случае на графе выполняются  последовательные сокращения (редукции) всех ребер, как входящих в вершину  определенного процесса, так и исходящие из него, если процесс не является  заблокированным. Такое редуцирование эквивалентно ситуации, когда процесс  получит запрашиваемые ресурсы, а потом все их освободит. Признаком  блокированного процесса является то, что ресурс, который он запрашивает, на  текущем шаге редуцирования, уже полностью выделен другим процессам.  Редуцирование выполняется итерационно до тех пор, пока на графе возможны изменения.  Если в результате граф не является полностью сокращаемым, то рассмотренное  состояние является состоянием тупика. Например, процесс D не может быть редуцирован, поскольку он запрашивает ресурс  3, а тот уже предоставлен процессу Е.</p>
  <p><strong>Обнаружение  взаимоблокировок при наличии нескольких ресурсов каждого типа.</strong><br />
    В этом случае используется другой подход. Пусть в системе n процессов P1&hellip;Pn,  m &ndash; число классов ресурсов, Ei &ndash; число ресурсов класса i,  1&lt;=i&lt;=m, Е{E1,&hellip;Em} &ndash; вектор существующих ресурсов. Он содержит общее  количество имеющихся в наличии экземпляров каждого вида ресурса. Аналогично А{A1&hellip;Am} &ndash; вектор доступных ресурсов, где Аi &ndash; это количество экземпляров ресурса i, не использующихся, т.е. доступных в текущий момент. Пусть C &ndash;матрица текущего распределения, где Cij &ndash; количество экземпляров ресурса j,  которое занимает процесс i. Таким  образом, i строка матрицы показывает, какое количество ресурсов  каждого класса использует процесс Pi.  Аналогично R &ndash; матрица запросов, где Rij  &ndash; количество экземпляров ресурса j, которое  хочет получить процесс Pi.<br />
  <img src="../images/1sem_theory_p8_clip_image008.gif" alt="4" width="149" height="75" /><img src="../images/1sem_theory_p8_clip_image010.gif" alt="5" width="147" height="75" /><br />
    Если сложить все экземпляры ресурса j,  предоставленные процессам и доступные в данный момент, то в результате получим  существующее в системе количество экземпляров данного класса ресурсов, т.е.  справедливо равенство<br />
  <img src="../images/1sem_theory_p8_clip_image012.gif" alt="6" width="155" height="173" hspace="12" align="right" /><img src="../images/1sem_theory_p8_clip_image014.gif" alt="7" width="112" height="44" /><br />
    Алгоритм обнаружения взаимоблокировок основан на&nbsp; сравнении векторов. Определим, что A&lt;=B тогда и  только тогда когда Ai&lt;=Bi, 1&lt;=i&lt;=m. <br />
    В начальном состоянии все процессы немаркированы. По мере  выполнения алгоритма на процессы ставится отметка, служащая признаком того, что  они могут завершить свою работу, т.е. для этого достаточно ресурсов и процесс  не находится в тупике. После окончания алгоритма любой немаркированный процесс  будет находиться в тупике. <br />
    Алгоритм ищет процесс, который может быть завершен. Для  такого процесса все требуемые ресурсы должны находиться среди доступных в  данный момент. Тогда найденный процесс сможет завершить свою работу и вернуть  ресурсы в общий фонд доступных ресурсов. Процесс отмечается как завершивший  работу. Если в результате&nbsp; остались  немаркированные процессы, то значит они не могут завершить работу, и  следовательно блокированы.</p>
  <p>Пример</p>
  <p>НМД &nbsp;&nbsp;&nbsp; плоттеры &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; сканеры &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CD <br />
    E={&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - существующие  ресурсы<br />
    A={&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - доступные ресурсы</p>
  <p>М-ца текущего распределения&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Матрица  запросов<br />
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1<br />
    С=&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; R=&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0<br />
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0</p>
  <p>Имеется 3 процесса и 4 класса ресурсов: НМД, плоттеры,  сканеры, CD. Первый процесс использует сканер и требует доступа к двум  НМД и CD. Поскольку свободного CD  нет, процесс не может быть завершен, R1&gt;A.  Аналогично второй процесс. Однако третий процесс может завершиться, R3=A. После завершения, А изменяется на {2 2 2 0}. Теперь может  завершиться процесс 2, а после его завершения и освобождения распределенных ему  ресурсов выполнится и процесс 1. Однако если бы строка R3 выглядела не как 2 1 0 0 , а 2 1 0 1, то вначале ни один из  процессов не смог бы функционировать, поскольку и 1 и 3 процессы нуждались бы в  CD, который был у процесса 2. Этот процесс в свою очередь  требует сканера, все из которых используются 1 и 3 процессами.</p>
  <p>Возникновение взаимоблокировок можно проверять каждый раз,  когда запрашивается очередной ресурс. Однако такой подход требует существенных  временных издержек. Альтернатива: проверять периодически с интервалом в несколько  минут.</p>
  <p><strong>Восстановление  при помощи принудительной выгрузки ресурса</strong>.  Иногда есть возможность отобрать ресурс у его владельца и временно отдать  другому процессу. В этом случае часто требуется ручное вмешательство.  Способность забирать ресурс у процесса, отдавать его другому, а потом  возвращать назад так, что исходный процесс этого не замечает, в значительной  мере зависит от свойств ресурса. Выйти из тупика таким образом зачастую трудно  или невозможно. Выбор приостанавливаемого процесса зависит главным образом от  того, какой процесс владеет ресурсами, которые могут быть легко отняты.</p>
  <p><strong>Восстановление  через откат</strong>. Работа организуется таким образом,  что процессы периодически <strong>создают  контрольные точки</strong>. Состояние процесса записывается в файл, впоследствии  процесс может быть восстановлен из этого файла. Контрольные точки содержат не  только образ памяти, но и состояние ресурсов, т.е. какие из них в данный момент  предоставлены процессу. Для повышения эффективности новая контрольная точка  должна записываться не поверх старой, а в новый файл. При обнаружении  взаимоблокировки требуется определить, каких ресурсов процессам не хватает.  Чтобы выйти из тупика, процесс-владелец этого ресурса выполняет откат к той  контрольной точке, когда ресурс был свободен. Вся работа, выполненная после  этой КТ, теряется. Фактически процесс просто запускается с более раннего  момента, повторяя часть уже выполненной работы. Однако, поскольку ресурс займет  уже другой процесс, то выполнившему откакт придется ожидать освобождения  ресурса.</p>
  <p><strong>Восстановление  путем уничтожения процессов.</strong> Грубый, но наиболее эффективный способ. Уничтожается процесс, находящийся в  цикле взаимоблокировки. Если после этого взаимоблокировка не исчезла, удаляют  еще один процесс из цикла. Можно в качестве жертвы выбрать процесс не  находящийся в цикле, чтобы освободились требуемые ресурсы. По возможности,  следует уничтожать те процессы, которые можно запустить с самого начала безо  всяких&nbsp; излишеств. Например, процесс,  выполняющий компиляцию, можно уничтожить, а потом запустить заново &ndash; это ни на  чем не отразится. А процесс, выполняющий добавление данных в таблицу, уничтожить  нельзя &ndash; в этом случае часть данных будет добавлена дважды.<br />
    <img src="../images/1sem_theory_p8_clip_image016.gif" alt="8" width="335" height="268" hspace="12" align="right" /> <br />
    <strong>Избежание  взаимоблокировок.</strong> При рассмотрении тупиков,  предполагалось, что процесс запрашивает все требуемые ресурсы одновременно.  Однако на самом деле они запрашиваются поочередно. Система должна уметь решать,  является предоставление ресурса безопасным, и только если это так, предоставлять  ресурс. Алгоритмы, позволяющие избегать тупиков, используют концепцию <strong>безопасного состояния</strong>. Рассмотрим  модель с 2 процессами и 2 ресурсами разных типов. По горизонтали отрабатывает  процесс А. По вертикали &ndash; В. В момент I1 процесс  А запрашивает ресурс 1,&nbsp; в момент I2 &ndash; второй.. Он освобождает эти ресурсы в моменты I3 и I4  соответственно. Процесс В требует ресурса 2 в момент I5  до I7, а в момент I6 до I8 &ndash; ресурса 1. Точки PQRST  &ndash; состояния системы. Изначально система находится в состоянии Р. Планировщик  запускает процесс А, который отрабатывает до точки Q,  далее планировщик запускает процесс В, система попадает в точку R, и вновь процесс А. В однопроцессорной системе все линии  будут либо вертикальными либо горизонтальными. Кроме этого линии могут идти  только вверх или направо. Процесс А пересекает I1,  запрашивая и получая ресурс 1. Точка S. Переключение  на процесс В. При пересечении I5, В  запрашивает ресурс 2. Заштрихованные области представляют собой состояния,  когда оба процесса должны использовать один и тот же ресурс. Учитывая, что  взаимное исключение делает это невозможным, то попадания в эти области&nbsp; не происходит. Если система войдет в  прямоугольник I1I2I5I6, то из  него ей не будет выхода. Это взаимоблокировка. В точке Т ситуацию еще можно  спасти &ndash; дать работать процессу А, пока он не пересечет I4. В точке Т процесс В запрашивает ресурс. Система должна  принять решение &ndash; предоставлять его или нет. <br />
    Пусть вектора Е и А &ndash; существующие в системе ресурсы и  доступные соответственно, а матрицы С и R&nbsp; -матрица текущего распределения и запроса  соответственно. Состояние <strong>безопасно</strong>,  если система не находится в тупике и существует такой порядок планирования, при  котором каждый процесс может работать до завершения, даже если все процессы  захотят немедленно получить свое максимальное количество ресурсов. </p>
  <table border="1" cellspacing="0" cellpadding="0">
    <tr>
      <td width="105" rowspan="2" valign="top"><p align="center"><strong>&nbsp;</strong></p></td>
      <td width="54" rowspan="2" valign="top"><p align="center"><strong>Макс.</strong></p></td>
      <td width="370" colspan="10" valign="top"><p align="center"><strong>Имеет</strong></p></td>
    </tr>
    <tr>
      <td width="177" colspan="5" valign="top"><p align="center"><strong>Безопасно</strong></p></td>
      <td width="193" colspan="5" valign="top"><p align="center"><strong>Небезопасно</strong></p></td>
    </tr>
    <tr>
      <td width="105" valign="top"><p align="center">А</p></td>
      <td width="54" valign="top"><p align="center">9</p></td>
      <td width="28" valign="top"><p align="center">3</p></td>
      <td width="34" valign="top"><p align="center">3</p></td>
      <td width="39" valign="top"><p align="center">3</p></td>
      <td width="39" valign="top"><p align="center">3</p></td>
      <td width="39" valign="top"><p align="center">3</p></td>
      <td width="39" valign="top"><p align="center">3</p></td>
      <td width="39" valign="top"><p align="center">4</p></td>
      <td width="39" valign="top"><p align="center">4</p></td>
      <td width="39" valign="top"><p align="center">4</p></td>
      <td width="39" valign="top"><p align="center">&nbsp;</p></td>
    </tr>
    <tr>
      <td width="105" valign="top"><p align="center">В</p></td>
      <td width="54" valign="top"><p align="center">4</p></td>
      <td width="28" valign="top"><p align="center">2</p></td>
      <td width="34" valign="top"><p align="center">4</p></td>
      <td width="39" valign="top"><p align="center">0</p></td>
      <td width="39" valign="top"><p align="center">0</p></td>
      <td width="39" valign="top"><p align="center">0</p></td>
      <td width="39" valign="top"><p align="center">2</p></td>
      <td width="39" valign="top"><p align="center">2</p></td>
      <td width="39" valign="top"><p align="center">4</p></td>
      <td width="39" valign="top"><p align="center">0</p></td>
      <td width="39" valign="top"><p align="center">&nbsp;</p></td>
    </tr>
    <tr>
      <td width="105" valign="top"><p align="center">С</p></td>
      <td width="54" valign="top"><p align="center">7</p></td>
      <td width="28" valign="top"><p align="center">2</p></td>
      <td width="34" valign="top"><p align="center">2</p></td>
      <td width="39" valign="top"><p align="center">2</p></td>
      <td width="39" valign="top"><p align="center">7</p></td>
      <td width="39" valign="top"><p align="center">0</p></td>
      <td width="39" valign="top"><p align="center">2</p></td>
      <td width="39" valign="top"><p align="center">2</p></td>
      <td width="39" valign="top"><p align="center">2</p></td>
      <td width="39" valign="top"><p align="center">2</p></td>
      <td width="39" valign="top"><p align="center">&nbsp;</p></td>
    </tr>
    <tr>
      <td width="105" valign="top"><p align="center">Свободно</p></td>
      <td width="54" valign="top"><p align="center">10</p></td>
      <td width="28" valign="top"><p align="center">3</p></td>
      <td width="34" valign="top"><p align="center">1</p></td>
      <td width="39" valign="top"><p align="center">5</p></td>
      <td width="39" valign="top"><p align="center">0</p></td>
      <td width="39" valign="top"><p align="center">7</p></td>
      <td width="39" valign="top"><p align="center">3</p></td>
      <td width="39" valign="top"><p align="center">2</p></td>
      <td width="39" valign="top"><p align="center">0</p></td>
      <td width="39" valign="top"><p align="center">4</p></td>
      <td width="39" valign="top"><p align="center">&nbsp;</p></td>
    </tr>
  </table>
  <p>Например, в системе 3 процесса, и свободно 10 экземпляров  ресурса одного типа. Процессу А требуется максимум 9 экземпляров, В &ndash; 4, С &ndash; 7.  Пусть в какой-то момент они имеют соответственно 3,2,2 экземпляра. Если процесс  В запросит оставшиеся 2 ресурса, он их получит, отработает и освободит, в  системе станет 5 свободных ресурсов. Если теперь процесс С запросит недостающие  ему 5 ресурсов, он их сможет получить, отработает и освободит. Теперь 7  ресурсов предостаточно, чтобы завершить процесс А. Рассмотрим небезопасную  ситуацию. Процесс А запрашивает еще один ресурс и получает его. В системе  остается 2 свободных экземпляра. Процесс В запрашивает 2 ресурса, освобождает.  Но 4 свободных экземпляров недостаточно ни процессу А, ни процессу С для  завершения. Значит процессу А нельзя было предоставлять еще один ресурс,  поскольку при этом система перешла из безопасного в небезопасное состояние.  Небезопасное состояние еще не означает тупика. Действительно, процесс А может  успеть частично освободить ресурсы, позволяя процессу С завершиться, после чего  уже потребовать максимально возможное число ресурсов. Т.е. небезопасное  состояние приводит к тупику лишь потенциально. Безопасное же состояние  гарантирует, что тупика не произойдет, т.е. все процессы завершат свою работу.  Однако эта модель требует выполнения следующих условий:</p>
  <ol>
    <li>число пользователей и ресурсов  фиксировано;</li>
    <li>число работающих пользователей остается  постоянным;</li>
    <li>клиенты должны гарантированно  возвращать ресурсы;</li>
    <li>максимальные требования процесса к  ресурсам должны быть известны заранее.</li>
  </ol>
  <p><strong>Алгоритм  банкира.</strong> Алгоритм планирования, позволяющий  избегать взаимоблокировок был разработан Дейкстрой в 1965 году, и называется  алгоритмом банкира. Он представляет собой расширение алгоритма обнаружения  тупиков, рассмотренный ранее. Модель основана на примере банкира в небольшом  городке, который имеет несколько клиентов (процессов), которым выдает по  несколько кредитов (ресурсов). При заявке клиента на получение еще одного  кредита, проверяется, хватит ли у банкира сумм, чтобы в итоге все клиенты  смогли завершить свои операции. Если нет, то запрос отклоняется. Фактически  алгоритм идентичен алгоритму поиска взаимоблокировок. При запросе очередного  ресурса, система проверяет, что произойдет, если ресурс будет выделен.  Фактически моделируется ситуация, при которой процесс получил требуемый ресурс  и выполняется проверка на взаимоблокировку. Если ее нет, состояние системы останется  безопасным и ресурс процессу предоставляется. Если же обнаруживается  взаимоблокировка, то состояние становится небезопасным, и запрос отклоняется. Однако  подобный алгоритм заранее требует полных сведений о том, сколько ресурсов может  потребоваться процессу. Кроме того, количество процессов динамически изменяется  в процессе функционирования системы. Более того, ресурсы, считающиеся  доступными, могут перестать такими быть в результате поломки или отказа. В  результате на практике рассмотренный алгоритм практически не используется.</p>
  <p><strong>Предотвращение  взаимоблокировок</strong> в реальных системах основано на  использовании сформулированных выше условий Коффмана. Рассмотрим условие  взаимного исключения. Если в системе нет ресурсов, отдаваемых в единоличное  владение одному процессу, взаимоблокировка невозможна. Однако на практике очень  часто невозможно предоставить одновременный доступ нескольких процессов к  ресурсу. Например, невозможно позволить разным процессам одновременно печатать  на принтере. Правда, в этом случае можно избежать взаимоблокировки, используя  подкачку. В этой модели только один процесс реально запрашивает физический  принтер, являясь демоном печати. Процессы ставят задания в очередь, а демон организует  их поочередную печать. Но и такая модель доступна не для всех видов ресурсов.  Кроме того, конкуренция за дисковое пространство для подкачки сама может  привести к тупику. <br />
    Условие удержания и ожидания. Можно попытаться уберечь  процессы, занимающие некоторые ресурсы от ожидания остальных ресурсов,  взаимоблокировок не будет. Один из возможных путей решения в том, чтобы процесс  запрашивал все необходимые ресурсы до начала работы. В результате или процесс  получает все необходимое для работы, что исключает взаимоблокировки или ожидает  ресурсы, не блокируя другие процессы. Проблема в том, что предварительно не  всегда известно, какие ресурсы будут требоваться. Кроме этого, ресурсы&nbsp; используются не оптимально. <br />
    Условие отсутствия принудительной выгрузки ресурса. Уже  рассматривали, что далеко не всегда есть возможность принудительно отобрать  ресурс у процесса.<br />
    Условие циклического ожидания. Циклическое ожидание можно  устранить несколькими способами. 1. Процесс имеет право только на один ресурс в  конкретный момент времени. Если нужен второй ресурс, процесс должен освободить  первый. Это также не всегда возможно. 2. Общая нумерация всех ресурсов.  Процессы могут запрашивать столько ресурсов сколько захотят, но запросы должны  быть сделаны в соответствии с нумерацией ресурсов. Из двух требуемых ресурсов  сначала должен запрашиваться ресурс с меньшим номером. В этом случае граф  распределения ресурсов никогда не будет иметь циклов. Однако не всегда возможно  выполнить требуемую нумерацию ресурсов. В реальных системах ресурсов столь  много (области таблицы процессов, дисковое пространство подкачки, записи баз  данных, прочие абстрактные ресурсы), что систематизировать их и предусмотреть  все возможные варианты не представляется возможным.<br />
  <strong>Двухфазовое  блокирование.</strong> Если процессу требуется несколько  ресурсов, он пытается их заблокировать (получить) по одному. Если получить все  необходимые ресурсы не удалось, выполняется освобождение занятых ресурсов и  попытка повторяется. На этой первой фазе не выполняется никаких реальных  действий. Получив требуемые ресурсы, выполняется обработка и освобождение  ресурсов -&ndash;это вторая фаза. Фактически подход требует грамотного  программирования, кроме того, он не обобщается на системы реального времени.  Используется при построении БД. Подход выражается в понятии транзакции  -&ndash;неделимой последовательности действий с БД в т.ч. и над несколькими записями.  Действия или выполняются все, или не выполняется ни одно.<br />
    Тупиковые ситуации возникают и <strong>без использования ресурсов</strong>. Например. каждый из процессов просто  ожидает, когда второй выполнит какое-либо действие.<br />
    Существует понятие <strong>голодания</strong>.  При использовании некоторых алгоритмов планирования может возникать ситуация,  когда некоторые процессы вообще не получат требуемый ресурс. Происходит  голодание. Ситуация предотвращается, если используется стратегия &rdquo;первым пришел  &ndash; первым обслужен&rdquo;.&nbsp; </p>

</BODY>
</HTML>