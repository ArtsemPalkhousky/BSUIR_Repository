<!-- (C) 2011-2012 V.Prytkov, V. Suponev, A.Uvarov. BSUIR -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//RU">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1251">
<META HTTP-EQUIV="Content-Language" CONTENT="ru">
<link rel="stylesheet" type="text/css" href="../css/style.css" />
<title>Лекция №9. Управление  памятью.</title>
<base target="_top">
</HEAD><BODY>
  <p align="center"><strong>Управление  памятью</strong></p>
  <p><em>Управление  памятью. Задачи управления памятью. Однозадачная система. Сегментная  организация памяти. Настройка адресов и защита памяти. Подкачка. Битовые  массивы и связные списки. Алгоритмы выбора сегмента для размещения процесса.  Страничная организации памяти. Виртуальная память. Таблицы страниц.  Многоуровневые таблицы страниц. Буферы быстрого преобразования TLB.  Инвертированные таблицы страниц. Обработка страничного прерывания. </em></p>
  <p><img src="../images/1sem_theory_p9_clip_image002.gif" alt="1" width="314" height="238" hspace="12" align="right" />Память  в современных ПК представляет собой иерархическую структуру. Небольшая часть  &ndash;быстрая, дорогая, энергозависимая кэш-память. Среднее кол-во среднескоростной,  средней по цене, энергозависимой памяти ОЗУ, и большое кол-во медленной,  дешевой, энергонезависимой памяти на жестком диске. Одна из задач ОС &ndash;  координация использования всех этих составляющих. Часть ОС, отвечающая за&nbsp; управление памятью называется <strong>менеджером памяти</strong>. Он отслеживает,  какая часть памяти свободна, какая занята, при необходимости выделяет память  ресурсам и освобождает их по завершении процесса, управляет обменом между ОЗУ и  диском. В общем случае адреса в программе могут быть абсолютными, т.е. компилятор  генерирует код с непосредственными физическими адресами. Могут быть  относительными. В этом случае процесс загружается в память целиком, однако  адрес его загрузки заранее неизвестен. Компилятор генерирует специальную  таблицу настройки адресов, которая используется при загрузке процесса. Термин <strong>виртуальная память</strong> используется, когда  физический адрес страницы может изменяться в процессе выполнения программы в  результате выгрузки и загрузки в другую область. В этом случае настройка  адресов происходит аппаратно-программным способом. Рассмотрим методы организации  памяти.</p>
  <p><strong>Непрерывная  организация.</strong> В этом случае фактически вся память  разделена на три области: память, занимаемая ОС, память, занимаемая программой,  свободная память. ОС может находиться в нижней части памяти, начиная с нулевых  адресов ОЗУ. Эта модель ранее применялась на майнфреймах и мини-компьютерах, в  настоящее время малоупотребима. ОС может располагаться в верхних адресах  памяти, в ПЗУ. Этот вариант используется в некоторых карманных компьютерах и  встроенных системам. Третий вариант &ndash; драйверы устройств находятся вверху, в  ПЗУ, а остальная часть ОС в ОЗУ. Этот вариант устанавливался на ранних моделях  ПК, например, MS-DOS.&nbsp; В случае  непрерывной организации в каждый конкретный момент времени может работать  только один процесс. Как только с терминала вводится команда. ОС копирует  заданную программу с диска в память, запускает ее. После окончания ждет новой  команды. Новая программа в памяти грузится поверх старой.</p>
  <p>Использование <strong>оверлеев</strong> предполагает, что вся программа может быть разбита на части &ndash; сегменты.  Оверлейная программа имеет одну главную часть и несколько сегментов, причем в  памяти одновременно могут находиться только часть сегментов, включая главный.  Структура использовалась, когда логическое адресное пространство программы было  больше, чем свободная память .Пока в ОЗУ находятся выполняющиеся сегменты,  остальные находятся во внешней памяти. После завершения текущего сегмента либо  он сам обращается к ОС с указанием, какой сегмент теперь необходимо загрузить,  либо возвращает управление главному сегменту, который и взаимодействует с ОС,  какой сегмент выгрузить, а какой загрузить. Вначале обязанность выполнить  соответствующие системные вызовы ложилась на программистов, потом системы  программирования стали выполнять это автоматически при указании  соответствующего режима.<br />
    <img src="../images/1sem_theory_p9_clip_image004.gif" alt="2" width="315" height="190" hspace="12" align="right" /> <br />
    <strong>Фиксированные  границы раздела.</strong> Весь объем ОЗУ разбивается на  несколько, возможно, различных по объему,&nbsp;  разделов. В каждом разделе в один момент времени может располагаться  только один процесс. При этом можно использовать и оверлейные структуры. Первые  мультипрограммные ОС строились по такому принципу.<br />
    В случае отдельных очередей к каждому из сегментов возникает  проблема: к некоторым большим сегментам нет очереди, в то же время небольшие  задачи могут организовать значительную очередь, ожидая запуска, хотя память в  принципе свободна. В случае общей очереди имеется несколько стратегий выбора  раздела для размещения задачи. 1 вариант.&nbsp;  Задача, находящаяся ближе всего к началу очереди и подходящую для  выполнения в освободившемся разделе, загружается и начинается обработка. 2  вариант. Небольшие задачи нежелательно загружать в большие сегменты. В очереди  происходит поиск наибольшей из помещающихся в разделе задач, которая и запускается.  Чтобы избежать дискриминации маленьких задач, в системе существует хотя бы один  раздел достаточно маленького размера. Второй вариант &ndash; задача не может быть  пропущена более заданного числа раз.&nbsp; <br />
    В любом случае существует проблема &ndash; часть памяти в каждом  разделе не используется, что не рационально. Использование двух принципов  решает эту проблему: выделять ровно такой памяти, какой необходим процессу,  размещать процесс не в одной непрерывной области, а в нескольких, в т.ч. и не  смежных. </p>
  <p><img src="../images/1sem_theory_p9_clip_image006.gif" alt="3" width="254" height="158" hspace="12" align="right" /><strong>Разделы с подвижными границами.</strong> В этих системах использованы указанные выше принципы. При  этом используется <strong>своппинг или подкачка</strong>.  Каждый процесс полностью переносится в память, работает, затем целиком  выгружается на диск. Основное отличие в том, что количество, размещение и  размер разделов изменяются динамически по мере поступления и завершения  процессов. Это улучшает использование памяти, но усложняет операции размещения  процессов и освобождения памяти. <br />
    <img src="../images/1sem_theory_p9_clip_image008.gif" alt="4" width="151" height="163" hspace="12" align="right" />Как  видно из рисунка, возникает фрагментация памяти. Из-за сильной фрагментации  может сложиться ситуация, когда диспетчер не сможет образовать новый раздел,  хотя общий объем свободной памяти и достаточен для запуска процесса. В этом  случае может использоваться <strong>уплотнение  памяти</strong> &ndash; когда все разделы сдвигаются, устраняя <strong>фрагментацию</strong>. На это может потребоваться достаточно длинное время.  Помимо фрагментации имеется и еще одна проблема &ndash; процесс может потребовать  дополнительного распределения памяти уже во время выполнения. Какой объем  памяти предоставлять процессу при образовании сегмента? Как правило, им  предоставляют несколько больше памяти, чем необходимо. Если же и эта память  закончится, то либо процесс переносится в больший сегмент, либо выгружается на  диск до момента, когда станет возможным организовать сегмент необходимого  размера. При этом возможна следующая схема: область данных и стек, которые по  мере необходимости растут по направлению друг к другу. Свободная область  используется как куча для распределения памяти под данные.</p>
  <p>Многозадачность требует решения двух важных проблем &ndash; <strong>настройка адресов и защита</strong>. Поскольку  до запуска программы неизвестно, по каким адресам она будет располагаться, при  выделении сегмента памяти требуется настройка адресов в коде программы&nbsp; именно на выделенный блок. Один из вариантов  решения &ndash; при запуске изменять адреса. Для этого в код программы добавляется  компоновщиком таблица настройки адресов, используя которую при запуске и  происходит перезапись. Однако это не решает проблемы защиты &ndash; любая программа  может использовать любой адрес и соответственно, поменять код или данные в ином  сегменте. Второй вариант решения, который одновременно решает и проблему защиты  &ndash; использование базового и предельного регистров. В первых из них заносится  адрес начала раздела памяти, а во второй помещается длина раздела. К каждому  адресу перед его использованием в команде автоматически аппаратно добавляется  значение базового регистра. Дополнительно проверяется, что адрес не вышел за  границу, дозволенную предельным регистром. Пользовательские программы не могут  поменять значения этих регистров. Схема использовалась на первом  суперкомпьютере CDC6600. Сейчас схема используется редко.</p>
  <p><img src="../images/1sem_theory_p9_clip_image010.gif" alt="5" width="488" height="144" hspace="12" align="right" />При  динамическом выделении памяти этим процессом должна управлять ОС. Существует  два варианта управления: <strong>использование  битовых массивов</strong> и <strong>связных списков</strong>.<br />
    В случае битовой карты каждому блоку соответствует один бит  &ndash; 1, если блок занят и 0, если свободен. При размещении нового процесса длиной  N блоков требуется найти последовательную серию из N нулей. Это медленная  операция. В случае связных списков для каждого блока формируется элемент, содержащий  флаг, занят блок или свободен, его начальный адрес, длину, указатель на  следующий элемент списка. Список может быть и двусвязным. Закончившийся процесс  имеет два соседних блока. Если оба они заняты, требуется только лишь изменить  флаг занятости. Если занят один из соседей, то требуется еще и удалить один из  элементов списка, а в оставшемся скорректировать начало и длину блока. В  случае, если оба соседних блока свободны, из трех блоков остается только один с  соответствующей корректировкой.</p>
  <p>Существует несколько алгоритмов выбора свободных участков  для размещения процесса. <strong>Первый  подходящий</strong>. Менеджер последовательно просматривает список и как только  находит подходящий, распределяет его. В итоге участок делится на два &ndash; занятый  под процесс и оставшийся свободным остаток. Поиск максимально уменьшен, если  списки отсортированы по адресам, и алгоритм довольно быстр. <strong>Следующий подходящий</strong>. Похож на первый.  Отличие в том, что после поиска запоминается положение указателя поиска в  списке, и в следующий раз поиск продолжается с остановленного места. Производительность  у этого алгоритма несколько ниже. <strong>Самый  подходящий</strong>. Полный поиск по всему списку, выбирается подходящий фрагмент  минимального размера. Производительность его еще ниже, поскольку он заполняет  память большим количеством небольших областей, т.е. фрагментирует. <strong>Самый неподходящий</strong>. Выбирается самый  большой подходящий участок. После размещения процесса остается свободным  достаточно большой фрагмент для размещения нового процесса. Средняя производительность.  Любой из алгоритмов ускоряется, если списки занятых и свободных областей  ведутся отдельно. Однако тогда увеличивается сложность и происходит замедление  при освобождении областей, поскольку требуется еще и переместить элемент из  одного списка в другой<strong>. Быстрый  подходящий</strong>. Дополнительно поддерживаются списки блоков наиболее употребительных  размеров.</p>
  <p>Оставшиеся три метода называют разрывными &ndash; при их  использовании задача помещается уже не в один непрерывный блок, а в несколько.  Для этого дополнительно требуется относительная адресация. <br />
    <img src="../images/1sem_theory_p9_clip_image012.gif" alt="6" width="445" height="188" hspace="12" align="right" /> <br />
    <img src="../images/1sem_theory_p9_clip_image013.gif" alt="7" width="334" height="191" hspace="12" align="right" /><strong>Сегментный</strong>. Программа разбивается на части и уже каждой из частей  предоставляется память. В результате программа представляет собой множество  сегментов. Обращение к элементам программы выглядит в этом случае как указание  имени сегмента и смещение относительно его начала. В итоге виртуальный адрес  состоит из двух полей &ndash; номер сегмента и смещение. Сегментная организация  требует поддержки на уровне системы программирования, которая преобразует имена  сегментов в их номера и определяет их объем. Для каждого процесса ОС строит  таблицу <strong>дескрипторов сегментов</strong>, в  которой отмечает местоположение сегмента в оперативной или внешней памяти. В  ней имеются следующие поля: бит присутствия, указывающий в каком типе памяти  находится сегмент, адрес начала сегмента и его длина, тип (код или данные),  права доступа, информация об обращениях к этому сегменту, на основании которой  ОС принимает решение о замещении сегмента при необходимости загрузки нового.  При передаче управления новому процессу ОС заносит в соответствующий регистр  адрес таблицы дескрипторов сегментов данного процесса. В оперативной памяти  могут размещаться не все сегменты, а только те, с которыми идет реальная  работа. Общий объем виртуальной памяти. предоставляемой задаче может быть  значительно больше, чем объем предоставленных ей сегментов. Однако нельзя  загрузить в память слишком большое количество задач &ndash; тогда потребуется частое  переключение и соответственно загрузка-выгрузка сегментов, что резко снизит  производительность. Если требуемого&nbsp;  сегмента в памяти нет, то происходит прерывание и диспетчер памяти  передает управление программе загрузки сегмента. Пока происходит поиск сегмента  во внешней памяти, диспетчер определяет подходящее место. Если свободного места  нет, принимается решение о том, какой из сегментов будет выгружен (своппинг  сегментов). Интересной возникающей возможностью следует считать разделяемые программные  модули. Сегмент с разделяемым кодом располагается в памяти в единственном  экземпляре, а ссылки на его использование будут содержаться в нескольких  таблицах дескрипторов сегментов разных процессов. Для снижения потерь времени  на вычисление необходимых адресов используется кэширование таблицы дескрипторов  &ndash; она располагается в быстродействующем по сравнению с остальной памятью кэше.  Сегментную организацию использовала OS/2 v.1. </p>
  <p><strong>Страничный</strong>. В отличие от предыдущего варианта длина сегмента строго  фиксирована и имеет заданный размер. Такие сегменты называются страницами.  Часть страниц находится в ОЗУ, остальные на диске, в файле подкачки  (свопп-файле). В UNIX для выгруженных страниц используется специально выделенный  раздел. Аналогично используется таблица страниц. Основное отличие в том, что  дескриптор страницы не имеет поля длины. Длина страницы выбирается кратной  степени 2. Если размер страницы достаточно велик, то операция сложения может  быть заменена сдвигом. В случае, если когда даже часто используемые страницы не  помещаются в свободную область ОЗУ возникает <strong>пробуксовка</strong> &ndash; ситуация, когда при обращении к странице памяти  происходит выгрузка текущей страницы на диск. Аналогично используется  кэширование таблицы дескрипторов. Недостаток в том, что программа разбивается  на страницы случайным образом, без учета логических связей между частями, что  приводит к слишком частой перезагрузке страниц. </p>
  <p><strong>Сегментно-страничный</strong>. Как и в сегментном способе, программа разбивается на  логически законченные части &ndash; сегменты. Однако память разбита на фиксированное  число страниц. Виртуальный адрес представлен тремя полями: номер сегмента,  номер страницы в сегменте, смещение внутри страницы. Сначала вычисляется адрес  таблицы страниц сегмента, путем сложения начального адреса таблицы дескрипторов  сегментов и номера сегмента, по таблице страниц сегмента и номеру страницы  определяется физический адрес страницы, к которому наконец добавляется  смещение. Издержки на вычисление адреса еще больше увеличиваются. Аналогично  используется кэширование. </p>
  <p><strong>Многоуровневые  таблицы страниц. </strong>Большие страницы не устраняют  фрагментацию, поэтому размер страницы невелик. Тогда, если размер страницы 4К,  то для 32-разрядного адреса потребуется около миллиона страниц. Размер таблицы  очень велик. Чтобы не хранить ее постоянно в памяти используют многоуровневую  таблицу страниц. В этом случае адрес разбивается на три части. Первая часть  представляет собой номер строки в таблице верхнего уровня. В ней хранится адрес  таблицы второго уровня для данного диапазона адресов. Вторая часть адреса  используется как номер страницы для таблицы второго уровня, третья &ndash; как  смещение. Так, если каждая из таблиц второго уровня соответствует 4 Мб, и  размер страницы 4 Кб, то адрес в примере равен 1048576*4+1024+4. При такой  организации нет необходимости держать в памяти таблицу страниц для всего  виртуального адресного пространства в 4 Гб. Достаточно только страницы первого  уровня, и N страниц второго, в за<img src="../images/1sem_theory_p9_clip_image015.gif" alt="8" width="422" height="295" hspace="12" align="right" />висимости  от объема процесса (1 таблица второго уровня позволяет адресовать до 4 Гб).  Наиболее распространен формат 32битной записи для каждой страницы. В ней  содержится: номер страничного блока, бит присутствия, биты доступа, изменения и  обращения, блокирования кэша. Бит присутствия определяет, находится ли данная  виртуальная страница в физической памяти или нет. Биты защиты определяют права  доступа, в простейшем случае &ndash; чтение-запись или только для чтения. Бит  изменения устанавливается, когда содержимое страницы изменилось. Если ОС решает  выгрузить такой блок, его содержимое сначала надо сохранить на диск. Бит обращения  устанавливается, когда происходит обращение к данной странице. Он помогает ОС  при выборе страницы для замещения. Последний бит позволяет запретить кэширование  страницы. Это важно для страниц, отображающихся не на память, а на регистры  устройств. Если идет ожидание ответа от устройства вв, то нужно получить именно  новые данные, а не копию из кэша со старыми данными. Бит не нужен, если  архитектура машины имеет отдельное адресное пространство вв, не отображаемое на  память. 2 уровня &ndash; платформа Intel, 3 &ndash; Sun SPARC,  DECAlpha, заданное число уровней &ndash; Motorola. Ряд архитектур, например, MIPS R2000 (RISC) не поддерживают таблицы страниц, перекладывая организацию  поиска нужной страницы на ОС.</p>
  <p><strong>Буферы  быстрого преобразования адреса TLB.</strong> Хранение в памяти таблиц оказывает значительное влияние на производительность.  Однако большинство программ обращаются в основном только к небольшому четко  ограниченному набору страниц, к остальным же обращение происходит редко. Машина  снабжается аппаратным блоком, служащим для отображения виртуальных адресов в  физические без использования таблицы страниц. Как правило, оно позволяет иметь  порядка 64 записей о страницах. Фактически это ассоциативное ЗУ, дублирующее  информацию об наиболее используемых страницах. При обращении к странице памяти  параллельно по всей TLB проверяется номер страницы на совпадение. Если  указанная страница имеется в TLB ее адрес поступает на выход. Если же ее там  нет, адрес берется из обычной таблицы и вдобавок размещается в TLB. Теперь если  обращение к этому адресу произойдет повторно, он уже будет храниться в быстром  ассоциативном ЗУ. Многие современные RISC-компьютеры (SPARC, MIPS, Alpha, HP  PA) выполняют страничное управление программно. В них записи TLB явно  загружаются ОС. Если запись в буфере не найдена, диспетчер памяти вместо того,  чтобы переходить к таблице страниц для поиска, формирует ошибку и передает  управление ОС. Система находит страницу, замещает запись в буфере TLB и  перезапускает прерванную инструкцию. В результате диспетчер памяти организуется  значительно проще, что позволяет иметь на кристалле больше кэша</p>
  <p><strong>Инвертированные  таблицы страниц</strong>. Чтобы снизить размер таблиц,  используют таблицы не для виртуального адресного пространства, а для  физического. Однако в этом случае перевод виртуального адреса в физический  значительно усложняется.. Этот подход используется на машинах PowerPC, на ряде рабочих станций IBM и HP. </p>
  <p>В большинстве архитектур адресное пространство для кода и  данных едино, однако существуют архитектуры, в которых адресные пространства  данных и кода отдельны. В этом случае оба адресных пространства могут иметь  страничную организацию независимо друг от друга. Каждое из них обладает своей  собственной таблицей страниц и собственным отображением виртуальных страниц на  физические страничные блоки. </p>
  <p>Подкачка страниц работает лучше, если в системе имеется  достаточное количество свободных блоков, которые можно запросить при страничном  прерывании. Для поддержания этого количества, во многих  странично-организованных системах&nbsp;  имеется фоновый процесс, который периодически проверяет состояние  памяти. Если блоков мало, он начинает выбирать страницы в памяти для  освобождения.</p>
  <p>В ряде систем над картой памяти имеется определенный  программный контроль. В этом случае программисты могут именовать область  памяти, тогда один процесс сможет передать другому имя области памяти, и второй  сможет ею пользоваться. В этом случае реальной становится высокая пропускная  способность совместного доступа &ndash; один процесс пишет в разделяемую память, а  другой читает из нее. Этот же механизм может использоваться для построения  высокопроизводительных систем передачи сообщений. Еще одна разновидность  совместного доступа &ndash; распределенная память совместного доступа. В этом случае  несколько процессов в сети могут совместно использовать набор страниц. В случае  возникновения страничного прерывания, обработчик определяет машину, которая  содержит страницу, и посылает ей сообщение с просьбой выгрузить и переслать по  сети.</p>
  <p><strong>Обработка  страничного прерывания.</strong><br />
    Выполняется следующая последовательность действий:</p>
  <ol>
    <li>Аппаратное обеспечение переключает  систему в режим ядра, сохраняя счетчик команд в стеке. На большинстве машин в  специальных регистрах процессора сохраняется некоторая информация о состоянии  текущей инструкции. </li>
    <li>Запускается написанная на ассемблере  программа, сохраняющая основные регистры и другую изменяющуюся информацию,  защищая ее от разрушения ОС. Эта программа вызывается ОС как процедура.</li>
    <li>ОС обнаруживает, что произошло  страничное прерывание, и пытается найти необходимую виртуальную страницу. Часто  требуемую информацию содержит один из аппаратных регистров. Если нет, ОС должна  достать из стека счетчик команд, выбрать инструкцию, и программно  проанализировать ее, чтобы определить, что она делала в тот момент, когда случилась  ошибка.</li>
    <li>Как только становится известен  виртуальный адрес, вызвавший прерывание, система проверяет, имеет ли силу этот  адрес, и согласуется ли защита с доступом. Если нет, то процессу посылается  сигнал или процесс уничтожается. Если адрес действителен и не произошло ошибки  защиты, система проверяет наличие свободных страничных блоков. Если свободных  блоков нет, запускается алгоритм замещения страниц.</li>
    <li>Если выбранный страничный блок был  изменен, страница заносится в график записи на диск и происходит переключение  контекста, приостанавливающее вызвавший прерывание процесс и позволяющее работать  другому процессу до тех пор, пока не будет выполнен перенос страницы на диск. В  любом случае блок отмечается как занятый, чтобы предотвратить его использование  в других целях.</li>
    <li>Как только страничный блок очищается,  ОС ищет адрес на диске, где находится требуемая страница, и планирует дисковую  операцию для ее переноса в память. Во время загрузки страницы процесс,  вызвавший прерывание, все еще приостановлен, и выполняется другой  пользовательский процесс, если такой доступен.</li>
    <li>Когда дисковое прерывание отмечает, что  страница поступила в память, обновляется таблица страниц, отражая ее позицию, а  блок помечается как находящийся в нормальном состоянии.</li>
    <li>Прерванная команда возвращается к тому  состоянию, с которого она начиналась, и значение счетчика команд приостановленного  процесса (в стеке или в системной ячейке памяти) корректируется так, чтобы  указывать на эту команду.</li>
    <li>Прерванный процесс вносится в график, и  ОС возвращает управление ассемблерной процедуре, вызвавшей ее.</li>
    <li>Эта процедура перезагружает регистры и  другую информацию о состоянии и возвращает управление в пользовательское  пространство для продолжения выполнения пользовательской программы, как если бы  никакого прерывания не происходило.</li>
  </ol>
  <p>Чтобы перезапустить текущую команду, ОС должна определить,  где находится первый байт команды. Но значение счетчика команд зависит от того,  какой операнд вызвал ошибку, и от реализации микрокода контроллера. Поэтому  зачастую ОС не в состоянии точно определить, где начиналась команда. В  некоторых процессорах эта проблема решается путем наличия на кристалле скрытых  регистров, в которые переносится содержимое счетчика команд перед выполнением  каждой операции.</p>
  <p>Рассмотрим еще один момент. Пусть один процесс ожидает  завершения операции вв. Второй, активный процесс, вызывает страничное  прерывание. Если алгоритм подкачки глобальный, то есть шанс, что для удаления  из памяти будет выбрана страница, содержащая буфер ввода-вывода. Если в этот  момент устройство ВВ как раз и записывало данные в буфер, то выгрузка этой  страницы приведет к тому, что часть данных запишется в буфер, а часть &ndash; во  вновь загруженную страницу. Решение в том, чтобы блокировать страницы, занятые  ВВ, от выгрузки из памяти. Такое блокирование носит название <strong>пришпиливания</strong>.</p>
  
</BODY>
</HTML>