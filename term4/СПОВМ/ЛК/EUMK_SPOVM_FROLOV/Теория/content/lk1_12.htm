<!-- (C) 2011-2012 V.Prytkov, V. Suponev, A.Uvarov. BSUIR -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//RU">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1251">
<META HTTP-EQUIV="Content-Language" CONTENT="ru">
<link rel="stylesheet" type="text/css" href="../css/style.css" />
<title>Лекция №12. Подсистемы  ввода-вывода.</title>
<base target="_top">
</HEAD><BODY>
  <p align="center"><strong>Подсистемы  ввода-вывода</strong></p>
  <p><em>Управление  вводом-выводом. Блочные и символьные операции. Синхронные и асинхронные  операции. Отображение ввода-вывода на адресное пространство памяти. Прямой  доступ к памяти. Кэширование операций. Упреждающее чтение. Отложенная запись.  Программное обеспечение ввода-вывода. Драйверы </em><em>UNIX</em><em>. Псевдоустройства.  Переключатели устройств. Файл устройства. Драйверы Windows. Процесс загрузки  драйверов. Дерево устройств. Дисциплины оптимизации запросов чтения-записи</em></p>
  <p>Система вв, способная объединить в одной модели широкий  набор устройств, должна быть универсальной. Кроме того, необходимо обеспечить  доступ к устройствам вв множества параллельных задач. Используется следующий  принцип: любые операции по управлению вв объявляются привилегированными и могут  выполняться только кодом самой ОС. За управление вв отвечает компонент ОС,  называемый супервизором ОС. Он выполняет следующие действия:</p>
  <ol>
    <li>получает запросы на вв от прикладных  задач и модулей ОС., проверяет их на корректность, и или обрабатывает их дальше  или выдает соответствующее сообщение</li>
    <li>вызывает распределители каналов и  контроллеров, планирует вв, помещает задачи в очередь</li>
    <li>инициирует операции вв, передавая  управление соответствующим драйверам, если при этом используются прерывания,  предоставляет процессор диспетчеру задач для смены контекста</li>
    <li>при получении сигналов прерываний  идентифицирует их и передает управление соответствующему обработчику</li>
    <li>выполняет передачу сообщений об  ошибках, если они произошли в процессе операции вв</li>
    <li>передает сообщения о завершении  операции вв ожидающему процессу</li>
  </ol>
  <p>Уровни вв можно представить следующей иерархией: 1. ПО вв  уровня пользователя. Функции: обращение к вызовам вв, форматированный вв,  спулинг. 2. Устройство-независимое ПО ОС. Ф: именование, защита, блокирование,  буферизация, назначение увв. 3. Драйверы устройств. Установка регистров  устройства, завершение операции вв. 4. Обработчики прерываний. активирование  драйвера при завершении операции вв. 5. Аппаратура. выполнение операции вв.</p>
  <p>Устройства вв можно разделить на два класса: <strong>блочные</strong>, когда возможно чтение-запись данных  блоком и имеют четко выраженную адресную структуру, например, диск, и <strong>символьные</strong>, которые принимают или  передают поток символов без какой-либо блочной структуры, которые не являются  адресуемыми и не выполняют операцию поиска. Электронная составляющая устройства  вв называется <strong>контроллером</strong> или <strong>адаптером</strong>. <br />
    Интерфейс между устройством и контроллером является  интерфейсом очень низкого уровня. Например, контроллер диска при чтении сектора  принимает поток бит, содержащий заголовок сектора, собственно биты данных и  контрольную сумму ЕСС. Он преобразует поток бит в последовательность байт,  сравнивает ЕСС, после чего операция считается выполненной и передается в  память. <br />
    У контроллера имеются регистры, с которыми может  взаимодействовать центральный процессор для управления устройством, выбора  режима и т.д. Может присутствовать буфер данных, с которым также могут  выполняться операции чтения-записи. 2 способа доступа к управляющим регистрам и  буферам устройств вв. 1. Каждому регистру устройства назначается номер порта,  тогда операции вв могут выглядеть как IN  REG, PORT или OUT PORT,  REG. При такой схеме адресное пространство вв и памяти не  пересекается, а существует раздельно. 2. Все регистры устройств отображаются на  адресное пространство памяти, т.е. регистру присваивается номер ячейки памяти,  как правило это верхние адреса диапазона (например, Motorola 680x0).  Используются и гибридные варианты, например, в x86  существует адресное пространство портов вв от 0 до 64К, а адресное пространство  памяти от 640К до 1М зарезервировано под буферы устройств. Отображение на  адресное пространство памяти имеет следующие преимущества: не требуется  ассемблерных вставок на языках высокого уровня для команд IN и  OUT; не требуется специальных механизмов защиты от процессов  пользователей при доступе к устройствам вв, достаточно исключить ту часть  адресного пространства, на которую отображаются управляющие регистры увв из  адресного пространства пользователей; при отображении разных увв на разные  страницы памяти доступ пользователей можно ограничивать выборочно. Недостатки  этого решения: в современных системах используется кэширование памяти, что  требует запрещения кэширования отображаемого адресного диапазона, иначе при  обращении к увв будут считаны данные из кэша а не из реального устройства;  модули памяти должны отслеживать диапазон адресов и реагировать только на свой,  также как и увв;&nbsp; увв не могут отследить  обращения к памяти, если они происходят не по общей шине, а по прямой шине  процессор-память. В x86 во  время загрузки в специальные регистры моста шины PCI  загружаются значения отображаемого диапазона. При обращении к памяти с этими  адресами, обращение передаются не на прямую шину процессор-память, а на шину PCI.</p>
  <p>Существует вариант <strong>прямого  доступа к памяти</strong>, DMA (direct memory access), при котором устройство может  переслать/принять данные напрямую из памяти. Для этого необходим аппаратный  контроллер DMA, который и выполняет доступ к системной шине независимо от  центрального процессора. Контроллер может находиться как интегрировано в увв,  так и на материнской плате, обслуживая в последнем случае несколько увв. DMA  контроллер содержит управляющие регистры, доступные ЦП, в которых указывается  номер порта вв, направление пересылки данных, единица переноса (побайтно или  пословно0), размер переносимого блока. Механизм выглядит следующим образом. ЦП  программирует контроллер DMA, указывая, какие данные и куда перемещать. Далее  процессором дается команда контроллеру диска прочитать данные во внутренний  буфер. Как только контроллер диска сообщает, что операция выполнена, в работу  включается DMA. Он выставляет запрос на перенос одного слова, получает доступ к  шине и выполняет передачу, затем аналогично для следующего и т.д. Если ЦП в  этот момент нужна шина, он ожидает, так как шина занята DMA. Такой механизм  называется <strong>захват цикла</strong>, он требует  выставления запроса при передаче каждого слова, забирая случайный цикл шины у  ЦП и притормаживая его. Существует <strong>пакетный  режим</strong>, когда запрос выставляется один раз на серию пересылок, в этом случае  ЦП может простаивать достаточно долго, ожидая освобождения шины. По завершении  операции переноса данных, контроллер DMA  инициирует прерывание процессора, сообщая, что перенос данных завершен. В  результате ОС нет необходимости заниматься переносом данных в память, они уже  там. Контроллеры DMA  различаются по сложности. Простые могут выполнять одну операцию за один  раз,&nbsp; более сложные имеют несколько  каналов, каждый со своим набором управляющих регистров. Иногда в DMA контроллерах  доступен режим, когда контроллер устройства пересылает слово данных контроллеру  DMA, который затем выставляет на шину еще один запрос для  передачи его, куда нужно. Такая схема позволяет передать данные напрямую между  устройствами, минуя память, однако требует лишнего цикла шины. Большинство контроллеров  DMA работает с физическими адресами, однако некоторые позволяют  работать с виртуальным адресом (например, SPARC),  тогда контроллер DMA  использует менеджер памяти MMU для  преобразования адреса. Для этого MMU  должен быть частью памяти, а не процессора.  Как правило, контроллер DMA  значительно медленнее ЦП. Поэтому DMA  невыгодно использовать, если ЦП в  системе слабо загружен. Кроме того, машина без DMA,  где все пересылки выполняются программно, оказывается дешевле, что важно,  например, для встроенных систем.</p>
  <p>Имеется 2 основных режима обмена с устройствами вв: <strong>синхронный</strong> (блокирующий) и <strong>асинхронный</strong> (управляемый прерываниями).  В первом случае подав сигнал на операцию вв драйвер периодически опрашивает  состояние устройства, до получения сигнала готовности. Во втором случае вместо  цикла опроса управление переключается на другую задачу, а сигнал готовности  трактуется как запрос на прерывание, которое позволит продолжить обработку  операции вв. При этом существует механизм тайм-аута, позволяющий отреагировать на  ситуацию, когда устройство не ответило в течение заданного времени. Организация  обмена в режиме прерываний эффективнее, но сложнее в организационном плане.  Например, в Win9x, NT драйвер  печати работает через параллельный порт не в режиме прерываний, а в режиме  опроса готовности &ndash; это 100 загружает процессор и снижает эффективность. Другие  задачи в это время получают управление только благодаря вытесняющей  многозадачности. </p>
  <p><img src="../images/1sem_theory_p11_clip_image001.gif" alt="1" width="408" height="210" hspace="12" align="right" />Как  правило, при обмене используется буферизация, в общем случае это необходимо из-за  различной скорости выполнения операций на стороне приемника и передатчика. <strong>Варианты буферизации</strong>. Без буферизации.  Недостаток в том что процесс должен быть активирован при приеме каждого  символа. 2 вариант. Процесс предоставляет буфер определенного размера.  Обработчик прерываний активирует процесс только при заполнении буфера.  Недостаток. Страница памяти с буфером может оказаться выгруженной при приходе  денных. Фиксация буферов в памяти с запретом выгрузки снижает  производительность. 3 вариант. Обработчик помещает данные в буфер ядра. При его  заполнении данные переносятся в буфер пользователя. Недостаток в том, что  данные могут поступить при переносе в буфер пользователя, когда буфер ядра  заполнен. 4. Двойная буферизация. При заполнении буфера данные начинают  помещаться во второй буфер. Как только данные из первого буфера поместятся в  буфер пользователя, роль буферов меняется. Аналогичные схемы возможны и при  передаче данных. </p>
  <p>При чтении часто используется <strong>кэширование</strong>. В результате, если пользовательский процесс  многократно обращается к одним и тем же данным, они только при первом запросе  будут прочитаны с диска, а при последующих &ndash; из кэша. Кроме того используется  механизм <strong>упреждающего чтения</strong>. При  запросе каких либо данных, читается и несколько дополнительных следующих за  ними блоков (секторов). Это ускоряет операции чтения, поскольку часто следующие  затребованные задачей данные находятся в соседнем блоке. Следует различать кэш  контроллера диска и кэш ОС. Кэш контроллера содержит обычно содержит блоки, на  которые запрос еще не поступал, но которые удобно было прочитать, так как они  оказались под головкой при чтении других блоков. Кэш ОС состоит из блоков, на  которые были явные запросы, и которые по расчетам ОС могут снова понадобиться в  ближайшем будущем. При записи используется механизм <strong>отложенной записи</strong>. Данные сначала изменяются только в кэше и  помечаются как отложенная запись, в результате процессу нет необходимости  ожидать завершения медленной операции вв, он может продолжить работу  непосредственно. Система позже запишет данные на диск. Дополнительно такой  подход позволяет оптимизировать операции записи на диск. В Win используется  стратегия активного кэширования &ndash; под кэш отводится вся свободная память. В  результате потенциально возможна ситуация, когда кэш вырастает настолько, что  большинство страниц памяти оказываются сброшенными на диск в своп-файл. Поэтому  можно ограничить допустимые размеры кэша и размеры блоков данных в кэше. В Win 9x в System.ini  в разделе [vcache]  задаются параметры MinFileCache  (в Кб), MaxFileCache (в Кб), ChunkSize.  В Win NT  4, 2000, XP это  делается через реестр. В разделе HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session  Manager\Memory  Mamagment ключ  IOPageLockLimit задает  объем физической памяти для хранения буферов дискового кэша в байтах.  Виртуальный размер системного кэша по умолчанию равен 64МБ. Если в системе  более 4К страниц (16 Мб) физической памяти, виртуальный размер кэша равен 128  Мб + 64 Мб на каждые дополнительные 4 Мб физической памяти. Если на платформе x86 виртуальный размер кэша превышает 512 Мб, он  ограничивается 512 Мб.</p>
  <p>Для устройств, которые не которые не могут быть разделены  несколькими процессами, используется запрос на <strong>монопольное</strong> использование, захват в случае успешного выполнения  запроса и освобождение. Однако предоставление такой возможности  пользовательским процессам может не только снизить производительность но и  сделать устройство полностью недоступным. Для таких устройств часто  используется <strong>спулинг</strong>. При этом  создается специальный процесс <strong>демон</strong>,  и каталог или очередь спулинга. Все данные на передачу в виде ссылок или имен  файлов помещаются в очередь, а доступ к устройству реально имеет только демон.</p>
  <p>С концепцией независимости от увв связан принцип  единообразного именования. Имя файла или устройства должно быть текстовой  строкой или целым числом и не должно зависеть от физического устройства.  Например, в UNIX диски могут произвольно монтироваться в иерархию файловой  системы и пользователь может не знать какое имя какому устройству соответствует,  т.е. все файлы и устройства адресуется одним способом &ndash; по пути.</p>
  <p>Основной принцип разработки ПО &ndash; независимость от физических  устройств. Для этого вводится понятие виртуального устройства. Однако для  управления конкретным устройством требуется специальная программа, называемая <strong>драйвером</strong>. Как правило, для каждого  устройства или класса близких устройств требуется свой драйвер под каждую ОС.  Чтобы получить доступ к аппаратной части устройства, т.е. к регистрам  контроллера, драйвер должен быть частью ядра ОС. Возможно использование  архитектур, при которых драйверы будут реализованы в пространстве пользователя,  но в существующих архитектурах такой подход не используется. Драйверы пишутся  иными разработчиками, нежели ОС. Значит должна существовать строго определенная  модель функций драйвера и его взаимодействия с остальной частью ОС. В  большинстве ОС определен стандартный интерфейс, который должны поддерживать все  драйверы блочных устройств и второй стандартный интерфейс, который  поддерживается драйверами символьных устройств. Интерфейсы включают набор  стандартных процедур, которые могут вызываться остальной частью ОС. В ряде ОС  драйверы компилируются вместе с ядром, например UNIX.  При необходимости смены драйвера, ядро перекомпилируется. Другие ОС используют  динамическую подгрузку драйверов при работе системы. Драйвер не только  обрабатывает запросы на чтение-запись, но и при необходимости инициализирует устройство,  управляет энергопотреблением и т.д. Общий план обслуживания запроса на передачу  такой: проверка входных параметров, преобразование виртуальных адресов в  физические, проверка, свободно ли устройство, проверка состояния, можно ли  обслужить запрос сразу, определение серии необходимых команд, запись их в  регистры контроллера. Далее либо ожидание, пока прерывание от устройства не  разблокирует драйвер, либо устройство выполняет операцию сразу и ожидание не  требуется. В любом случае, проверяется, были ли ошибки, при необходимости  передача принятых данных выше по иерархии, передача информации о статусе  завершения операции. При этом требуется обработка следующих ситуаций: увв прекращает  операцию во время работы драйвера, поступление следующего пакета при еще не  обработанном текущем, горячее отключение устройства в процессе обмена.  Драйверам может быть разрешено обращение к некоторым системным процедурам. Стандартный  набор операций драйвера включает:</p>
  <ol>
    <li>get &ndash; чтение  символа, put &ndash; запись символа для символьных устройств</li>
    <li>read, write &ndash; чтение-запись блока, seek &ndash; перемещение указателя для доступа к  нужному блоку, для блочных устройств</li>
    <li>ioctl &ndash; для  передачи произвольной команды с произвольными параметрами (специфические для  устройства команды)</li>
    <li>open &ndash; инициализация  драйвера и устройства</li>
    <li>close  &ndash; завершение работы с устройством,  например, при отключении устройства</li>
    <li>poll &ndash; опрос  состояния устройства</li>
    <li>halt &ndash;  остановка драйвера при остановке ОС или выгрузке драйвера из памяти</li>
  </ol>
  <p>Драйвер не всегда управляет физическим устройством. Он может  использоваться в качестве интерфейса доступа, поддерживающего дополнительные  функции. Например в UNIX драйвер mem позволяет считывать из адресов физической памяти или  записывать по ним, устройство null  &nbsp;разрешает только запись в себя, удаляя все  получаемые данные, устройство zero является  источником памяти, заполненной нулями. Такие устройства называют <strong>псевдоустройствами.</strong></p>
  <p>В <strong>UNIX</strong> драйвер делится на 2 части, верхнюю, содержащую синхронные  процедуры, и нижнюю, содержащую асинхронные процедуры. Процедуры верхней  половины могут обращаться к адресному пространству и области u вызывающего процесса, и если необходимо, могут переводить  процесс в режим сна. Нижняя часть выполняется в системном контексте, и ее процедуры  как правило не имеют отношения к текущему процессу. Структура данных,  определяющая точки вхождения, поддерживаемые каждым устройством, называется <strong>переключателем устройств</strong>. Структура bdevsw &ndash; для блочных и cdevsw &ndash; для символьных:<br />
    struct bdevsw  {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct cdevsw  {<br />
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int  (*d_open)();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int  (*d_open)();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int  (*d_mmap)();<br />
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int (*d_close)();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int  (*d_close)();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int  (*d_segmap)();<br />
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int (*d_strategy)();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int (*d_read)();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int  (*d_xpoll)();<br />
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int (*d_size)();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int  (*d_write)();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int  (*d_xhalt)();<br />
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int (*d_xhalt)();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int  (*d_ioctl)();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct  streamtab* d_str;<br />
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &hellip;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }  cdevsw[];<br />
    } bdevsw[];<br />
    В разных версиях структуры переключателей могут несколько отличаться.  Переключатель определяет абстрактный интерфейс доступа к устройствам. Каждый  драйвер предоставляет специфическую реализацию этих функций. Драйверы следуют  стандартному соглашению об именовании функций переключателей, каждый драйвер  использует двухбуквенную аббревиатуру для описания самого себя. Например,  функции драйвера могут выглядеть как dkopen, dkclose и  т.д. Устройство может поддерживать не все точки входа. Для них как правило  используется общая процедура nodev(),  просто производящая выход с кодом ошибки ENODEV.  Для некоторых точек входа не определяется никаких действий, например, при  закрытии. Тогда можно использовать общую процедуру nulldev(), которая производит выход с кодом 0.</p>
  <p>Ядро идентифицирует каждое устройство по типу (блочное или  символьное) и по паре номеров &ndash; старший и младший номер устройства. Старший  номер определяет тип устройства, т.е. его драйвер. Младший номер определяет  экземпляр устройства. Обычно они объединяются в одну переменную, старшие биты  которой определяют старший номер, младшие &ndash; младший. Блочные и символьные  устройства имеют отдельные независимые наборы старших номеров. Старший номер  является индексом к таблице соответствующего переключателя. Если драйвер  обслуживает несколько устройств различного типа, ему может быть назначено  несколько старших номеров. </p>
  <p>Поддерживается&nbsp; единый  интерфейс доступа к файлам и устройствам с помощью <strong>файла устройства</strong>. Это специальный файл, ассоциированный с  определенным устройством, и не располагаемый ни в каком определенном месте  файловой системы. Все файлы устройств находятся в каталоге /dev или его подкаталогах. Пользователь может открывать или  закрывать такой файл, читать и писать данные, выполнять позиционирование  указателя как с обычным файлом. Стандартные потоки stdin,  stdout, stderr  перенаправляются командным  интерпретатором в соответствующие файлы устройства. Реально файл устройства  существенно отличается от обычного файла. Он не имеет блоков данных, хранимых  на диске, однако обладает постоянным индексным дескриптором в той файловой  системе, в которой он расположен. В отличие от обычного файла индексный дескриптор  содержит не список номеров блоков данных на диске, а старший и младший номер  устройства. Файл устройства может быть создан только суперпользователем с  помощью привилегированного системного вызова mknod(path, mode, dev), параметры соответственно &ndash; полное имя специального файла,  тип IFBLK или  IFCHR и привилегии, старший и младший номера устройства.</p>
  <p>В <strong>Windows</strong> поддерживается  множество типов драйверов устройств и сред их программирования. Эти среды могут  различаться даже для устройств одного типа. Драйверы могут работать в 2  режимах: пользовательском и ядра. Win поддерживает  несколько типов драйверов пользовательского режима:</p>
  <ol>
    <li>драйверы виртуальных устройств (VDD). Используются для эмуляции 16 разрядных программ MS DOS.  Они перехватывают обращения таких программ к портам вв и транслируют их в вызов  соответствующих API,  передаваемых реальным драйверам устройств.</li>
    <li>Драйверы принтеров. Транслируют  аппаратно-независимые запросы на графические операции в команды, специфичные  для принтера. Далее эти команды направляются драйверу режима ядра, например,  драйверу параллельного порта или принтера на USB шине.</li>
  </ol>
  <p>И режима ядра:</p>
  <ol>
    <li>драйверы файловой системы. Принимают и  выполняют запросы на вв, выдавая специфичные запросы драйверам устройств  массовой памяти или сетевым драйверам</li>
    <li>PnP  драйверы. Драйверы, работающие с оборудованием и интегрируемые с диспетчерами  электропитания и PnP. В т.ч.  драйверы для устройств массовой памяти, видеоадаптеров, устройств ввода и  сетевых адаптеров</li>
    <li>Драйверы, не поддерживающие PnP. Называются расширениями ядра. Расширяют функциональность,  предоставляя доступ из пользовательского режима к сервисам и драйверам режима  ядра. Не интегрируются с диспетчерами PnP. </li>
  </ol>
  <p>Драйверы устройств, отвечающие спецификации Windows Driver Model (WDM), поддерживают управление электропитанием, PnP, WMI.  Большинство драйверов PnP  реализованы в этой модели. Три типа  драйверов:</p>
  <ol>
    <li>драйверы шин. Управляют логическими или  физическими шинами. Отвечают за распознавание устройств, оповещение о них  диспетчера PnP и управление параметрами электропитания шины.</li>
    <li>Функциональные драйверы. Управляют  конкретным типом устройств. Устройства предоставляются функциональным драйверам  драйверами шин через диспетчер PnP.</li>
    <li>Драйверы фильтров. Это драйверы более  высокого логического уровня, дополняющие функциональность или изменяющие  поведение устройства либо другого драйвера.</li>
  </ol>
  <p>В системе присутствуют два типа системных объектов &ndash; Драйвер  и Устройство. Объект Драйвер представляет в системе отдельный драйвер. Объект  Устройство представляет физическое или логическое устройство и описывает его  характеристики. Диспетчер вв создает объект Драйвер при загрузке в систему  соответствующего драйвера и вызывает его инициирующую процедуру, которая  записывает в атрибуты объекта точки входа этого драйвера. Драйвер может сам  создавать объекты Устройство. Однако для большинства PnP драйверов используют иной механизм.  Объект Устройство создается внутренней процедурой добавления устройств, когда  диспетчер PnP информирует  их о присутствии управляемого ими устройства. Драйверы, не поддерживающие PnP могут  создавать объект Устройство при вызове диспетчером вв их инициирующих процедур.  Диспетчер вв выгружает драйвер после удаления последнего его объекта Устройство,  когда ссылок на устройство больше нет. При создании объекта Устройство ему  может быть присвоено имя. Этот объект помещается в пространство имен диспетчера  объектов. Как правило объекты Устройство помещаются в каталог \Device пространства имен, недоступный приложениям через WinAPI.</p>
  <p>Драйвер может загружаться явно и на основе перечисления.  Явную загрузку определяет ветвь реестра HKLM\SYSTEM\CurrentControlSet\Services. На основе перечисления загрузка происходит при  динамической загрузке диспетчером PnP.  Параметр Start при явной загрузке устанавливается следующим образом:</p>
  <ol>
    <li>если драйвер не поддерживает PnP, Start  настраивается таким образом, чтобы система загружала их на определенном этапе</li>
    <li>если драйвер должен загружаться  системным загрузчиком при запуске ОС, Start  устанавливается в 0 (запуск при загрузке системы). Например, драйвера системных  шин и файловой системы</li>
    <li>если драйвер не требуется для загрузки  системы, и распознает устройство, не перечисляемое драйвером системной шины, Start устанавливается  в 1 (запуск системой). Пример &ndash; драйвер последовательного порта</li>
    <li>если драйвер не поддерживает PnP, или это драйвер файловой системы не обязательный для  загрузки системы, Start  устанавливается в 2 (автозапуск).</li>
    <li>если драйвер PnP,  не обязательный для загрузки системы, Start  устанавливается в 3 (запуск по  требованию), например, драйверы сетевых адаптеров.</li>
  </ol>
  <p>Загрузка по перечислению. Диспетчер PnP начинает перечисление с виртуального  драйвера шины с именем Root, который  представляет всю систему. Он выступает в роли драйвера шины для драйверов, не  поддерживающих PnP  и для HAL.  HardWare Abstraction Layer &ndash; загружаемый  модуль ядра Hal.dll,  представляющий низкоуровневый интерфейс для аппаратной платформы, на которой  работает Windows. Он скрывает от ОС все, что связано с аппаратной  реализацией функциональности, специфичное для архитектуры и конкретного  оборудования, в т.ч. интерфейсы вв, контроллеры прерываний и механизмы  межпроцессорного взаимодействия.&nbsp; В свою  очередь HAL работает  как драйвер шины, перечисляющий устройства, напрямую подключенные к материнской  плате и такие системные компоненты, как аккумуляторы. Он определяет основную  шину, обычно PCI, устройства типа аккумуляторов и вентиляторов. Обычно HAL полагается  на описание оборудования в реестре, зафиксированное программой Setup при  установке ОС. Драйвер основной шины перечисляет устройства на этой шине, он  может обнаружить другие шины, и процесс продолжается рекурсивно. По мере  получения сообщений от драйверов шин об обнаруженных устройствах, диспетчер PnP формирует внутреннее <strong>дерево  устройств</strong>, отражающее взаимосвязи между устройствами. Узлы этого дерева  называются узлами устройств. Узел устройства содержит информацию об объектах  Устройство и другую PnP информацию.</p>
  <p>В результате процесс загрузки драйверов выглядит так:</p>
  <ol>
    <li>диспетчер вв вызывает входную процедуру  для драйверов, запускаемых при загрузке системы. Если у такого драйвера есть  дочерние устройства о них сообщается диспетчеру PnP.  Если соответствующие драйверы также должны запускаться при загрузке системы,  они конфигурируются и запускаются</li>
    <li>далее диспетчер PnP проходит  по дереву устройств и загружает драйверы для узлов, и запускает их устройства  независимо от параметра Start.  Аналогично перечисляются все дочерние устройства и загружаются соответствующие  им драйверы.</li>
    <li>далее&nbsp;  диспетчер PnP  загружает любые незагруженные драйверы,  запускаемые системой. Эти драйверы определяют свои устройства и сообщают о них.</li>
    <li>Диспетчер управления сервисами  загружает автоматически запускаемые драйверы.</li>
  </ol>
  <p>Все устройства, обнаруженные системой после установки,  регистрируются в подразделах раздела реестра HKLM\SYSTEM\CurrentControlSet\Enum. Драйвер класса дисков создает объекты Устройство,  представляющие диски и дисковые разделы. Имена таких объектов имеют вид \Device\HarddiskX\DRX, где Х &ndash; номер диска. Для идентификации разделов и создания  объектов Устройство, представляющих эти разделы, используется функция IoReadPartitionTable либо  IoReadPartitionTableEx. </p>
  <p>При поступлении значительного количества запросов на чтение  запись за малый промежуток времени, соседние из них могут требовать данные из  областей диска, находящихся далеко друг от друга. Поэтому в современных  системах используется оптимизация операции ввода-вывода. Как правило, драйверы  содержат таблицу, индексированную по номерам цилиндров, в которой в единый  список собираются все поступившие и ждущие обработки запросы. Основные  дисциплины обслуживания:</p>
  <ol>
    <li>FCFS (First Come First  Served) &ndash; первым пришел, первым обслужен.</li>
    <li>SSF (Shortest Seek First) &ndash; первым  выполняется запрос с наименьшим временем позиционирования. Однако при этом  некоторые запросы могут не обслуживаться в течении довольно долгого времени,  даже если они от высокоприоритетных задач. В принципе, нет гарантии  обслуживания самых крайних дорожек. Однако эта дисциплина обеспечивает максимальную  пропускную способность.</li>
    <li>Scan &ndash;  сканирование (элеваторный). Головки перемещаются от одного края к другому, по  пути обслуживая подходящие запросы. При такой дисциплине гарантируется  обслуживание запросов к крайним цилиндрам. </li>
    <li>Look. Отличие  в том, что если при движении в одном направлении попутных запросов больше нет,  направление изменяется на противоположное.</li>
    <li>NSS (Next Step Scan) &ndash;  отложенное сканирование. Отличается тем, что при сканировании обслуживаются  только те запросы, которые уже существовали на момент начала прохода.  Поступающие записи формируют новую очередь, которая будет обслужена при  обратном движении.</li>
    <li>C-Scan &ndash; циклическое сканирование. Головки перемещаются от  наружной дорожки к внутренним, по пути обслуживаются имеющиеся запросы, после  чего цикл повторяется, т.е. обратный проход является холостым. Характеризуется  очень малой дисперсией времени ожидания обслуживания. Не дискриминируются  крайние цилиндры.</li>
  </ol>
  <p>Пусть на диске 100 цилиндров. Начальное положение 63  цилиндр. Запросы на чтение цилиндров: 23, 67, 55, 14, 31, 7, 84, 10.<br />
    FCFS:&nbsp;&nbsp;&nbsp; 63 =&gt; 23 =&gt;  67 =&gt; 55 =&gt; 14 =&gt; 31 =&gt; 7 =&gt; 84 =&gt; 10; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 40+44+12+41+17+24+77+74=329<br />
    SSF:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 63 =&gt; 67 =&gt; 55 =&gt; 31 =&gt; 23  =&gt; 14 =&gt; 10 =&gt; 7 =&gt; 84;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4+12+24+8+9+4+3+77=141<br />
    Scan:&nbsp;&nbsp;&nbsp;&nbsp; 63 =&gt; 55 =&gt; 31 =&gt; 23 =&gt; 14  =&gt; 10 =&gt; 7 =&gt; 0 =&gt; 67 =&gt; 84;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8+24+8+9+4+3+7+67+17=147<br />
    Look:&nbsp;&nbsp;&nbsp;&nbsp; 63 =&gt; 55 =&gt; 31 =&gt; 23 =&gt; 14  =&gt; 10 =&gt; 7 =&gt; 67 =&gt; 84;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8+24+8+9+4+3+60+17=133<br />
    C-Scan: 63 =&gt; 55 =&gt; 31 =&gt; 23 =&gt; 14 =&gt; 10  =&gt; 7 =&gt; 0 =&gt; 99 =&gt; 84 =&gt; 67;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8+24+8+9+4+3+7+99+15+17=194</p>

</BODY>
</HTML>