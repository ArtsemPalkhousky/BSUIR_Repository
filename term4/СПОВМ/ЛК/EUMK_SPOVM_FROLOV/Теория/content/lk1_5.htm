<!-- (C) 2011-2012 V.Prytkov, V. Suponev, A.Uvarov. BSUIR -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//RU">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1251">
<META HTTP-EQUIV="Content-Language" CONTENT="ru">
<link rel="stylesheet" type="text/css" href="../css/style.css" />
<title>Лекция №5. Механизмы  взаимного исключения.</title>
<base target="_top">
</HEAD><BODY>
  <p align="center"><strong>Механизмы  взаимного исключения</strong></p>
  <p><em>Состояние  состязания. Задача об обедающих философах. Детерминированный набор. Условия  Бернстайна. Понятие критического ресурса. Критическая область. Взаимное  исключение. Механизмы взаимного исключения. Алгоритм Деккера. Алгоритм  Петерсона</em></p>
  <p>Взаимодействовать  могут либо конкурирующие, либо сотрудничающие процессы. Существует три основных  типа взаимодействий:<br />
    - передача информации от одного процесса  другому;<br />
    - исключение того, что процессы пересекутся  в конфликтных ситуациях;<br />
    - согласование обмена данными: если процесс  А поставляет данные, а процесс В использует их, то он должен ждать, пока  процесс А не даст данные. <br />
    Вторая  и третья ситуации относятся и к потокам. Передача информации для потоков не  является проблемой, поскольку у них общее адресное пространство. Рассмотрим  ситуацию, когда два процесса используют один и тот же ресурс, при этом работают  асинхронно. Пусть каждый из процессов хочет вывести файл на печать, для этого  он читает индекс свободной ячейки в очереди заданий на печать, помещает туда  имя файла и увеличивает индекс. Демон печати обрабатывает эту очередь. Например,  в очереди 2 задания уже есть, номер свободной ячейки в очереди заданий  соответственно 3. Процесс А читает индекс, это число 3. Тут время, выделенное  ему диспетчером задач, заканчивается, и управление переходит к процессу В. Он  также читает индекс, это по прежнему 3. Он помещает туда имя файла, увеличивает  значение индекса на 1. Тут управление возвращается к процессу А. Он знает, что  индекс равен 3, хотя на самом деле уже 4, и заносит в него имя файла,  увеличивает индекс. В итоге имя, занесенное процессом В, затирается, и этот  файл никогда не будет напечатан. С точки зрения демона, ошибок не произошло &ndash;  число заданий в очереди находится в полном соответствии с индексом. Ситуация,  когда несколько процессов считывают или записывают данные одновременно, и  результат зависит от того, кто из них был первым, называется <strong>состоянием состязания</strong>.</p>
  <p><strong>Проблема обедающих философов</strong>. Сформулирована в 1965 году Дейкстрой.  Пять философов сидят за круглым столом и у каждого есть тарелка со спагетти.  Чтобы пообедать, необходимо две вилки. Между каждыми тарелками лежит по одной  вилке. Философы в течение дня размышляют и обедают. Когда философ голоден, он  берет правую вилку, затем левую, съедает спагетти, кладет вилки и какое-то  время размышляет. Однако, если философы подойдут к столу одновременно, и одновременно  возьмут правые вилки, никто из них не сможет начать кушать: нет ни одной  свободной вилки. Произошла взаимоблокировка. Фактически каждый из процессов  (философов) захватил часть критического ресурса (одну из двух вилок). Требуется  организовать взаимное исключение. Здесь же имеется и еще одна проблема.  Например, можно решать задачу так. Если философ взял одну вилку, но вторую  взять не может, он должен положить вилку обратно, подождать и повторить все  сначала. Но если один философ очень медлителен, а его сосед, напротив, очень  быстр, то медленный философ умрет от голода: он подходит к столу, берет вилку,  вторая захвачена быстрым соседом, кладет вилку, немного ждет. За это время  быстрый сосед успевает покушать, положить вилки, поразмышлять, вновь подойти к  столу, и взять вилки для обеда. Медленный философ берет вилку, а вторая занята  соседом&hellip; И так до бесконечности. Это проблема называется <strong>голоданием</strong>. </p>
  <p>Бернстайн  сформулировал условия, при соблюдении которых при псевдопараллельном выполнении  нескольких процессов для одного и того же набора входных данных они дают  одинаковые выходные данные (т.е. набор процессов д<strong>етерминирован</strong>). Обобщение условий на N процессов выглядит следующим образом:<br />
    Пусть Ri &ndash; набор входных переменных процесса i, Wi &ndash;  выходных. Тогда выполнение N процессов детерминировано, если:</p>
  <ul>
    <li>Wi &#8898; Wj = &#8709;,  i,j=1,2,&hellip;,N; i&#8800;j</li>
    <li>Wi &#8898; Rj = &#8709;,  i,j=1,2,&hellip;,N; i&#8800;j</li>
  </ul>
  <p><strong>Пример</strong>. Пусть процесс А вычисляет: x=u+v; y=x*w; а  процесс В вычисляет: a=b*c; z=x+a;<br />
    Wa = {x,y}, Ra = {u,v,x,w}; Wb = {a,z}; Rb = {b,c,x,a}.<br />
    Wa &#8898; Wb = &#8709;, Wa &#8898; Rb ={x}, Wb &#8898; Ra = &#8709;. Условия не выполняются.</p>
  <p>Если  условия не соблюдаются, то параллельное выполнение набора процессов может быть  детерминированным, а может быть недетерминированным. Условия по сути требуют  практически невзаимодействующих процессов. Недетерминированный набор и приводит  к состояниям состязания. </p>
  <div class="imageTip"><img src="../images/1sem_theory_p5_clip_image001.gif" alt="1" width="566" height="134" hspace="12" /></div><p>Ресурсы, не допускающие одновременного использования, называются <strong>критическими</strong>. Для предотвращения  состязания, необходим механизм <strong>взаимного  исключения</strong>, не позволяющий процессам обращаться к критическому ресурсу  одновременно. В рассмотренном случае с принтером проблема возникла из-за того,  что процесс В начал работу с ресурсом до того, как процесс А закончил с ним  работать. Кроме реализации в ОС средств для организации взаимного исключения, в  ней должны быть средства для синхронизации процессов с целью обмена данными.  Типичным примером является взаимодействие типа поставщик-потребитель. Фрагмент  кода, в котором происходит обращение к критическим ресурсам, называется <strong>критической областью</strong> или критической  секцией. Решение задачи взаимного исключения в том, чтобы организовать такой  доступ к критическому ресурсу, когда только одному процессу разрешается  находиться в критической области. Если один из процессов владеет критическим  ресурсом, остальные процессы должны получить отказ и ждать освобождения  ресурса. При этом, если процессы выполняют операции, не приводящие к  конфликтам, т.е. вне критической области, они должны иметь возможность  параллельной работы. Если процесс, имеющий доступ к критическому ресурсу, выходит  из своей критической области, доступ должен быть передан другому процессу,  ожидающему доступа. Ситуация взаимного исключения поясняется на рисунке:</p>
  <p>Для  корректной организации взаимодействия параллельных процессов необходимо выполнение  следующих 4 условий:<br />
    - в любой момент времени только один  процесс должен находиться в своей критической области (условие взаимного исключения);<br />
    - никакой процесс, находящийся вне своей  критической секции, не должен влиять на выполнение других процессов, ожидающих  входа в критические область, т.е. он не должен блокировать критическую область  другого процесса; если несколько процессов одновременно хотят войти в  критическую область, то принятие решения, кому предоставить доступ,&nbsp; не должно откладываться бесконечно долго  (условие прогресса)<br />
    - ни один процесс не должен ждать  бесконечно долго вхождения в критическую область и, следовательно, ни один процесс  не должен находиться в критической секции бесконечно долго; (условие  ограниченного ожидания)<br />
    - не должно быть предположений о скорости  или количестве процессов.</p>
  <p>Все  системы имеют такое средство для организации взаимного исключения, как  блокировка памяти, запрещающее одновременное исполнение двух или более команд,  которые обращаются к одной и той же ячейке памяти, однако для полноценной  поддержки взаимного исключения его недостаточно. </p>
  <p><strong>Решения организации взаимного  исключения</strong>. Самый  простой способ состоит в <strong>запрещении  прерываний</strong> при входе в критическую область. Однако при этом запрещаются и  прерывания от таймера. Поскольку переключение задач происходит по прерыванию,  то отключение прерываний исключает передачу процессора другому процессу, что и  требовалось. Однако существуют довольно серьезные доводы против такого подхода.  Например, результате сбоя процесс может не вернуть систему прерываний в  разблокированное состояние. Далее, в многопроцессорной системе команда  блокирования прерываний повлияет только на один процессор, а ведь другие  процессы могут выполняться и на другом процессоре.</p>
  <p>Другое  решение состоит в использовании специальных <strong>переменных для блокировки.</strong> Выделяется переменная, изначально равная  0. Если процесс желает попасть в критическую область, он считывает эту  переменную, и если она равна 0, то устанавливает ее в 1 и входит в критическую  область. Если же переменная равна 1, то процесс ждет, пока она не установится в  0. Однако такое решение позволяет нескольким процессам одновременно войти в  критические области.</p>
  <p>Еще  одним вариантом организации взаимного исключения является <strong>чередование доступа</strong> к критическому ресурсу. Для этого имеется общая  переменная, указывающая, чья очередь входить в критическую область:</p>
  <p><em>int</em><em>turn</em><em>; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //  переменная, указывающая, чья очередь доступа</em></p>
  <p><em>void process1 (void)</em><br />
    <em>{while (TRUE)</em><br />
    <em>{</em><em>while</em><em>(</em><em>turn</em><em>!=1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //  ожидание, если очередь другого процесса</em><br />
    <em>critical</em><em>_</em><em>section</em><em>1();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //  выполнение критической секции</em><br />
    <em>turn</em><em>=2;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //  передача очереди другому процессу</em><br />
    <em>non</em><em>_</em><em>critical</em><em>_</em><em>section</em><em>1();}}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //  выполнение оставшейся, некритической части кода</em></p>
  <p><em>void process2 (void)</em><br />
    <em>{while (TRUE)</em><br />
    <em>{while(turn!=2);</em><br />
    <em>&nbsp;  critical_section2();</em><br />
    <em>&nbsp; turn=1;</em><br />
    <em>&nbsp; non</em><em>_</em><em>critical</em><em>_</em><em>section</em><em>2();}}</em></p>
  <p>Постоянная  проверка значения переменной в ожидании некоторого значения называется <strong>активным ожиданием</strong>. При этом  нерационально тратится процессорное время. Блокировка, использующая активное  ожидание, называется <strong>спин-блокировкой</strong>.  Здесь возможны и другие проблемы. Например, некритическая секция процесса 2  значительно длиннее, чем у процесса 1. Пусть очередь доступа у 1 процесса. Он  входит в критическую область. Второй процесс в это время ожидает вхождения в  цикле. Первый процесс выполняет критическую область, передает очередь. Второй  процесс входит в критическую область. Первый процесс выполняет некритическую  область. Второй процесс выполняет критическую область, передает очередь, и тоже  приступает к выполнению некритической области. Первый процесс вновь входит в  критическую область, выполняет ее, передает очередь, входит в некритическую  область. Второй процесс по прежнему находится вне критической области. Первый  процесс выполняет некритический фрагмент, и переходит к ожиданию в цикле, пока  второй процесс не передаст очередь. Но при этом второй процесс находится вне  критической секции, и выполнит ее еще очень не скоро. Т.о., нарушается одно из  условий, рассмотренных ранее: процесс, находящийся вне критической области  влияет на функционирование процесса, ожидающего доступа. Фактически требуется,  чтобы процессы попадали в критические секции строго поочередно, ни один из  процессов не может попасть в критическую секцию дважды подряд. </p>
  <p><strong>Алгоритм Деккера</strong>. Датским математиком Деккером впервые был  предложен алгоритм взаимного исключения, не требующий строгого чередования. По  сути, он объединяет два предыдущих подхода. Он основан на наличии 3 переменных:  switch[0], switch[1], turn, отвечающих за требования процессов на  вхождение в критическую область, и чья очередь на вхождение при условии, если  оба процесса требуют ресурс. Алгоритм работы процесса представлен на  граф-схеме.</p>
  <p><em>// глобальные переменные,  изначально все в значении 0</em><br />
    <em>int</em><em>turn</em><em>; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //  переменная, указывающая, чья очередь доступа</em><br />
    <em>int</em><em>switch</em><em>[2];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //  запросы на вхождение в критическую область</em><br />
    <em>#</em><em>define</em><em>PROC</em><em>_</em><em>NUM</em><em> 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //  0 &ndash; для 1 процесса, 1 &ndash; для второго</em></p>
  <p><em>void</em><em>process</em><em> (</em><em>void</em><em>)</em><br />
    <em>{</em><em>while</em><em> (1)</em><br />
    <em>{</em><em>switch</em><em>[</em><em>PROC</em><em>_</em><em>NUM</em><em>]=1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //  запрос на вхождение в критическую область</em><br />
    <em>L</em><em>:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </em><em>if</em><em> (</em><em>switch</em><em>[1-</em><em>PROC</em><em>_</em><em>NUM</em><em>]==1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //  если есть другие запросы, то</em><br />
    <em>{</em><em>if</em><em>(</em><em>turn</em><em>==</em><em>PROC</em><em>_</em><em>NUM</em><em>) {</em><em>goto</em><em>L</em><em>;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //  если очередь данного процесса, то ждем снятия других запросов</em><br />
    <em>else</em><br />
    <em>{</em><em>switch</em><em>[</em><em>PROC</em><em>_</em><em>NUM</em><em>]=0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //  если очередь другого процесса, снять запрос</em><br />
    <em>while</em><em> (</em><em>turn</em><em>==1-</em><em>PROC</em><em>_</em><em>NUM</em><em>);}}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //  ожидание, пока другой запрос не передаст очередь</em><br />
    <em>else</em><br />
    <em>{</em><em>critical</em><em>_</em><em>section</em><em>();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //  если нет других запросов, то выполнение критической секции</em><br />
    <em>turn</em><em>=1-</em><em>PROC</em><em>_</em><em>NUM</em><em>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //  передача очереди другому процессу</em><br />
    <em>switch</em><em>[</em><em>PROC</em><em>_</em><em>NUM</em><em>]=0;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //  снятие запроса</em><br />
    <em>non</em><em>_</em><em>critical</em><em>_</em><em>section</em><em>();}}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //  выполнение оставшейся, некритической части кода</em><br />
    <div class="imageTip"><img src="../images/1sem_theory_p5_clip_image003.jpg" alt="2" width="348" height="290" hspace="12"/></div> <br />
    Если  установлен флаг запроса от процесса 0, и нет флага запроса от процесса 1, то  выполняется критическая секция процесса 0 независимо от того, чья очередь, и  очередь передается другому процессу. Если же установлены оба флага, то  выполняется критическая секция того процесса, чья очередь. Второй процесс при  этом ожидает передачи очереди. Алгоритм Деккера позволяет гарантированно решить  проблему критических интервалов. Флаги запроса обеспечивают невозможность  одновременного вхождения в критическую область, переменная очереди избавляет от  взаимной блокировки. Однако в случае обобщения на N процессов алгоритм усложняется.</p>
  <p><strong>Алгоритм Петерсона.</strong> В 1981 году был разработан более простой  алгоритм взаимного исключения. Алгоритм основан на двух процедурах. Одна из них  вызывается перед вхождением в критическую область, вторая&nbsp; - по окончании ее.</p>
  <p><em>// глобальные переменные,  изначально все в значении 0</em><br />
    <div class="imageTip"><img src="../images/1sem_theory_p5_clip_image005.jpg" alt="3" width="251" height="265" hspace="12" /></div><em>int</em><em>turn</em><em>; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //  переменная, указывающая, чья очередь доступа</em><br />
    <em>int</em><em>switch</em><em>[2];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //  запросы на вхождение в критическую область</em></p>
  <p><em>#</em><em>define</em><em>PROC</em><em>_</em><em>NUM</em><em> 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //  0 &ndash; для 1 процесса, 1 &ndash; для второго</em></p>
  <p><em>void</em><em>process</em><em>(</em><em>void</em><em>)</em><br />
    <em>{</em><em>while</em><em> (1)</em><br />
    <em>{</em><em>switch</em><em>[</em><em>PROC</em><em>_</em><em>NUM</em><em>]=1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //  запрос на вхождение в КС</em><br />
    <em>turn</em><em>=</em><em>PROC</em><em>_</em><em>NUM</em><em>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //  установка очереди на текущий процесс</em><br />
    <em>while</em><em> (</em><em>turn</em><em>==</em><em>PROC</em><em>_</em><em>NUM</em><em> &amp;&amp; </em><em>switch</em><em>[1-</em><em>PROC</em><em>_</em><em>NUM</em><em>]==1);}// ожид., если </em><br />
    <em>// очередь тек. проц., но есть другие запросы</em><br />
    <em>critical</em><em>_</em><em>section</em><em>();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //  выполнение критической секции</em><br />
    <em>switch</em><em>[</em><em>PROC</em><em>_</em><em>NUM</em><em>]=0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //  снятие запроса</em><br />
    <em>non</em><em>_</em><em>critical</em><em>_</em><em>section</em><em>();}}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //  выполнение оставшейся, некритической</em><br />
    <em>// части  кода</em></p>
Изначально оба процесса вне критических областей. Процесс 0 вызывает функцию  вхождения в критическую область, устанавливает там флаг запроса, и переменную  очереди в 0 (процесс 0). Поскольку процесс 1 не устанавливал флаг запроса, то  процесс 0 входит в критическую область, затем, после ее выполнения, в функции  выхода снимает запрос. Если оба процесса вызывают функцию вхождения практически  одновременно, происходит следующее. Процесс 0 устанавливает флаг запроса, и  устанавливает переменную очереди на свой номер (0). В это время процесс 1  устанавливает свой флаг запроса и изменяет переменную очереди на свой номер  (1). Проверяется условие цикла:&nbsp; от  процесса 0 есть запрос и очередь установлена на текущий процесс. Процесс 1 переходит  к активному ожиданию. Тем временем процесс 0 приступает к определению  истинности условия цикла: запрос от процесса 1 есть, но очередь также  установлена на процесс 1. Условие ложно, ожидания не происходит, и процесс  входит в критическую область. После ее прохождения он снимает флаг запроса. В  этот момент у процесса 1 условие также становится ложным, поскольку уже нет  запросов от других процессов, и он входит в критическую секцию.
<p align="center">&nbsp;</p>

</BODY>
</HTML>