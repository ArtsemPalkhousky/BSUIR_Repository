<!-- (C) 2011-2012 V.Prytkov, V. Suponev, A.Uvarov. BSUIR -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//RU">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1251">
<META HTTP-EQUIV="Content-Language" CONTENT="ru">
<link rel="stylesheet" type="text/css" href="../css/style.css" />
<title>Лекция №7. Механизмы  межпроцессного взаимодействия.</title>
<base target="_top">
</HEAD><BODY>
  <p align="center"><strong>Механизмы  межпроцессного взаимодействия</strong></p>
  <p><em>Механизмы  для взаимодействия процессов. Сигналы. Каналы. Именованные и анонимные каналы.  Сообщения. Очереди сообщений. Порты. Буферы сообщений. Сообщения как средство  синхронизации. Рандеву. Барьеры. Поддержка механизмов взаимодействия в ОС </em><em>UNIX</em><em> и </em><em>Windows</em></p>
  <p><strong>Почтовые ящики (буферы  сообщений). </strong>Процессы  в ОС могут обмениваться сообщениями. Для хранения посланного, но еще не  полученного сообщения, необходимо место, называемое почтовым ящиком или буфером  сообщения. Если процесс хочет общаться с другим процессом, то он просит систему  выделить ему почтовый ящик, который свяжет эти два процесса. Для отправления  сообщения процесс просто помещает его в почтовый ящик, откуда второй процесс  может взять его в любое время. Второй процесс должен знать о существовании  ящика, и для получения сообщения выполнить к нему обращение. Если объем данных  велик, целесообразно не помещать их в ящик, а оставлять всего лишь информацию,  где их можно найти. Если почтовый ящик не связан жестко с конкретными  процессами, то сообщение должно содержать идентификаторы и процесса отправителя  и процесса получателя. Почтовый ящик состоит из заголовка, где содержится  информация о ящике и из нескольких буферов (ячеек) для сообщений. В простейшем  случае сообщения передаются только в одном направлении. Процесс может посылать  сообщения, пока есть свободные ячейки. Если они все заполнены, то процесс может  или ожидать или выполнять другие операции. Аналогично и процесс получатель  может получать сообщения, пока есть заполненные ячейки. Можно организовать  более сложные ящики. Например, двунаправленные. Такой ящик позволяет подтверждать  прием сообщений. Чтобы гарантировать доставку подтверждения в случае, когда все  ячейки заняты, подтверждение помещается туда же, где лежало исходное сообщение.  В эту ячейку не может быть помещено новое сообщение до тех пор, пока не будет получено  подтверждение. </p>
  <p>Как  правило, используется буфер из определенного количества элементов, тип которых  задается при создании ящика. Для реализации механизма достаточно двух  примитивов: <strong>send</strong> &ndash; отправить, и <strong>receive</strong> &ndash; принять.  Примитивы имеют два параметра, один из которых &ndash; собственно сообщение или его  адрес, второй параметр указывает или идентификатор взаимодействующего процесса,  или идентификатор почтового ящика. Еще один вариант организации сообщений &ndash; не  использовать буферизацию. В этом случае, если send выполняется раньше receive, посылающий процесс блокируется до  выполнения receive, когда  сообщение может быть напрямую скопировано от производителя к потребителю без  промежуточной буферизации и наоборот. Этот метод называется <strong>рандеву</strong>, он легче реализуется, чем  схема с буферизацией, однако процессы должны быть жестко синхронизированы.  Примитивы send и receive имеют скрытый механизм взаимоисключения, а  в большинстве систем и блокировки при чтении из пустого ящика или записи в  заполненный. Однако, несмотря на простоту использования, это решение менее  производительно. </p>
  <p><strong>Очереди сообщений.</strong> Очереди сообщений позволяют обрабатывать  сообщения в соответствии с разными дисциплинами обслуживания:</p>
  <ul>
    <li>FIFO &ndash;  первым пришел первым ушел (очередь).</li>
    <li>FILO &ndash;  первым пришел последним вышел (стек)</li>
    <li>приоритетный  &ndash; в зависимости от приоритета</li>
    <li>произвольный</li>
  </ul>
  <p>В  отличие от рассмотренных вариантов, можно организовать такой режим, при котором  прочитанное сообщение не удаляется из очереди, и может быть прочитано повторно  другими процессами. В очередях присутствуют не сами сообщения, а их адреса и  размер. При этом используется общая для всех процессов память, и процесс должен  вначале получить разрешение на доступ к ней с помощью системных запросов.  Дополнительной информацией при работе с очередями служит флаг, указывающий  требуется ли ожидание, если очередь пуста (полностью заполнена). Очередь  сообщений может быть реализована в виде <strong>порта</strong>.  Право на отправку сообщений в конкретный порт могут иметь несколько разных  процессов, но право получать сообщения из порта имеет только одна задача.</p>
  <p>Решение  производитель-потребитель с помощью сообщений:</p>
  <p><em>#define N 100&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // </em><em>ячеек</em><em>в</em><em>буфере</em><br />
    <em>void producer (void)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // </em><em>производитель</em><br />
    <em>{int item;</em><br />
    <em>&nbsp; message m;</em><br />
    <em>&nbsp; while (1)</em><br />
    <em>{item=produce_item();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // </em><em>создать</em><em>элемент</em><br />
    <em>&nbsp; receive</em><em>(</em><em>consumer</em><em>, &amp;</em><em>m</em><em>);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //  получить пустое сообщение</em><br />
    <em>build</em><em>_</em><em>message</em><em>(&amp;</em><em>m</em><em>, </em><em>item</em><em>);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //  сформировать сообщение для отправки</em><br />
    <em>send(consumer, &amp;m);}}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // </em><em>послать</em><em>сообщение</em></p>
  <p><em>void consumer (void)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // </em><em>потребитель</em><br />
    <em>{int item, i;</em><br />
    <em>&nbsp; message m;</em><br />
    <em>&nbsp; for (i=0;  i&lt;N; i++) send(producer, &amp;m);&nbsp;&nbsp; // </em><em>послать</em><em>серию</em><em>пустых</em><em>сообщений</em><br />
    <em>&nbsp; while (1)</em><br />
    <em>{</em><em>receive</em><em>(</em><em>producer</em><em>, &amp;</em><em>m</em><em>);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //  получить сообщение</em><br />
    <em>item</em><em>=</em><em>extract</em><em>_</em><em>item</em><em>(&amp;</em><em>m</em><em>);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //  извлечь элемент из сообщения</em><br />
    <em>send</em><em>(</em><em>producer</em><em>,&amp;</em><em>m</em><em>);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //  послать пустое сообщение</em><br />
    <em>consume</em><em>_</em><em>item</em><em>(</em><em>item</em><em>);}}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //  использовать элемент</em></p>
  <p>В UNIX для поддержки механизма сообщений  используются следующие вызовы:<br />
    int <strong>msgget</strong>(key_t key, int msgflg); - для создания очереди сообщений,  связанных с данным ключом<br />
    int <strong>msgsnd</strong> (int msqid, struct msgbuf* msgp, size_t msgsz, int msgflg) &ndash; для отправки сообщения<br />
    ssize_t <strong>msqrcv</strong> (int msqid, struct msgbuf *msgp, size_t msgsz, long msgtyp, int msgflg) &ndash; для получения сообщения<br />
    int <strong>msqctl</strong> (int msqid, int cmd, struct msqid_ds *buf); - для управления структурами</p>
  <p>В Windows также поддерживается модель буферов сообщений  (почтовых ящиков). Они являются однонаправленными. Сервер (считывающий процесс)  создает дескриптор почтового ящика <strong>CreateMailSlot</strong>, далее он ожидает сообщения с помощью <strong>ReadFile</strong>.  Клиент (отправляющий процесс) открывает ящик с помощью <strong>CreateFile</strong> и передает  сообщение c  помощью <strong>WriteFile</strong>. Если ни один сервер не ожидает сообщения,  открытие ящика завершится ошибкой. Сообщение может быть прочитано всеми  серверами.</p>
  <p>Проблемы  использования сообщений: сообщение может потеряться (особенно если процессы  происходят на различных машинах, объединенных сетью). Подтверждение призвано  гарантировать, что сообщение не потерялось. Если в течение некоторого времени  подтверждение не пришло, сообщение посылается повторно. Однако само  подтверждение также может потеряться. В итоге сообщение будет отправлено  повторно, хотя оно уже было получено. Требуется отличать копии от оригинала.  Обычно в тело сообщения помещают его порядковый номер. Если номер вновь  полученного сообщения совпадает с одним из номеров ранее принятых сообщений, то  оно считается копией и игнорируется. Кроме этого, необходимо однозначно  определять процесс (его имя). Встает и вопрос аутентификации (действительно ли  идет взаимодействие с файловым сервером, а не с процессом, пытающимся  нелегально получить информацию).</p>
  <p><strong>Программные каналы (</strong><strong>pipe</strong><strong>).</strong> Принцип работы основан на механизме в/в используемый при работе с файлами в UNIX. Задача, передающая информацию, действует  так, словно она записывает данные в файл, а задача, принимающая &ndash; словно читает  файл. Это упрощает программирование и не требует каких-либо новых механизмов.  На самом деле каналы не являются файлами, а представляют собой особые буферы,  работающие по принципу очереди (FIFO). Имеется два указателя, в начальный момент равные нулю. При  записи увеличивается один из них, при чтении второй. При достижении  максимального элемента, указатель опять изменяется на 0, т.е. наращивание  происходит циклически. Читать из канала может только тот процесс, который знает  его идентификатор. Каналы являются однонаправленными. После чтения данных они  становятся недоступными. При чтении из пустого канала процесс блокируется до  прихода данных, блокируется и процесс, записывающий в заполненный канал. </p>
  <p>В UNIX канал создается вызовом <strong>pipe</strong>. Вызов  возвращает 2 дескриптора &ndash; для чтения и для записи, которые могут наследоваться  потомками. Чтение и запись выполняются вызовами <strong>read</strong> и <strong>write</strong> с  помощью дескриптора канала. Типичное применение механизма программных каналов &ndash;  это перенаправление вывода одного процесса на ввод другого (Оператор | командной  строки). Ограничения, присущие каналам:</p>
  <ul>
    <li>канал  не может использоваться для передачи данных нескольким процессам;</li>
    <li>данные  интерпретируются как поток байт с заранее неизвестной длиной;</li>
    <li>если  данные читает несколько процессов, отправитель не может указать какие данные  какому из них предназначены.</li>
  </ul>
  <p>Помимо  неименованных каналов (анонимных), существуют именованные &ndash; named pipe. Они отличаются способами создания и  доступа. Они могут быть доступны любым процессам, не только потомкам, имеют имя  в пространстве имен файловой системы и являются постоянными, т.е. могут  содержать данные уже завершившего работу процесса. После использования их надо  удалять принудительно.<br />
    <img src="../images/1sem_theory_p7_clip_image002.gif" alt="1" width="273" height="124" hspace="12" align="right" />Современные Windows также  поддерживает каналы. Сервер создает именованный канал с помощью <strong>CreateNamedPipe</strong>. При этом сервер может создавать несколько дополнительных  экземпляров именованного канала. Для возможности соединения с клиентами  сервером используется функция <strong>ConnectNamedPipe</strong>. Для подключения к серверу клиенты  используют <strong>CreateFile</strong>. Чтение и запись данных выполняется  функциями <strong>ReadFile</strong> и <strong>WriteFile</strong> и  является двусторонней. Определить, есть ли данные в канале без их уничтожения  позволяет функция <strong>PeekNamedPipe</strong>. Анонимные каналы однонаправлены и  создаются функцией <strong>CreatePipe</strong>. </p>
  <p><strong>Барьеры</strong>. Предназначены для группы процессов.  Некоторые приложения делятся на фазы, и существует правило, что процесс не  может перейти к следующей, пока к этому не готовы все остальные процессы. Для  этого в конце каждой фазы располагается барьер. Процесс, доходя до барьера,  блокируется, пока все процессы не дойдут до него. Через какое-то время процесс D выполняет оставшиеся вычисления, и  запускает примитив barrier,  являющийся обычно библиотечной функцией. Поскольку только один процесс у  барьера, он переходит в ожидание. Затем аналогично процесс B, потом С, и наконец А. Как только  последний из процессов выполнил вызов, блокировка снимается для всех ожидающих  процессов, и они переходят за барьер.</p>

</BODY>
</HTML>