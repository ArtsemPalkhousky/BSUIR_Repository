<!-- (C) 2011-2012 V.Prytkov, V. Suponev, A.Uvarov. BSUIR -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//RU">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1251">
<META HTTP-EQUIV="Content-Language" CONTENT="ru">
<title>Лабораторная работа №5. Асинхронные файловые операции. </title>
<base target="_top">
</HEAD><BODY>
<p align="center"><strong>Лабораторная работа  №5. Асинхронные файловые операции</strong></p>
<p align="center"><strong>Организация операций асинхронного ввода-вывода под Windows и Linux. Работа с динамическими библиотеками</strong></p>
<p>Цель работы: Научиться осуществлять асинхронные файловые операции. Разобраться с понятием «динамическая библиотека», научиться 
создавать их и динамически использовать в приложениях.</p>
<p align="center"><strong>Теоретическая часть</strong></p>
<p><strong><br />Асинхронные файловые операции</strong></p>
<p>Классическая схема чтения/записи файла выглядит следующим образом: вызвать системную функцию чтения/записи, указать ей параметры 
доступа к файлу, дождаться конца ее выполнения. В данном случае по окончанию работы функции гарантируется, что операция чтения/записи
 окончена. Это так называемый случай синхронной файловой операции.</p>
<p>Асинхронные файловые операции реализованы по другому принципу. В этом случае функция чтения/записи лишь инициирует соответствующую 
процедуру, которая запускается в фоновом режиме. Это означает, что функция чтения/записи возвращает управление немедленно, в то время как 
сама операция может выполняться еще некоторое время после этого в отдельном потоке. Асинхронные файловые операции, как правило, ускоряют 
работу приложения, однако порождают следующую проблему: в большинстве случаев необходимо убедиться, что операция завершена и все данные 
переданы. Поскольку реализация фонового режима программе не видна, нужны средства, позволяющие определить текущий статус операции.</p>
<p>Реализация самих асинхронных операций, а также механизмы отслеживания результата их выполнения различны для разных операционных систем.</p>
<p><strong>Linux<br /></strong></p>
<p>Асинхронные файловые операции в Linux реализованы в библиотеке aio (asynchronous input-output).</p>
<p>Все функции, реализующие асинхронный ввод-вывод, используют специальную структуру aiocb. Она имеет следующие поля:
<ul>
<li>int aio_fildes – дескриптор файла;</li>
<li>off_t aio_offset – смещение, по которому будет осуществлено чтение/запись;</li>
<li>volatile void *aio_buf – адрес буфера в памяти;</li>
<li>size_t aio_nbytes – число передаваемых байт;</li>
<li>int aio_reqprio – величина понижения приоритета;</li>
<li>struct sigevent aio_sigevent – сигнал, отвечающий за синхронизацию операции, т.е. за оповещение о ее окончании;</li>
<li>int aio_lio_opcode – запрошенная операция.</li>
</ul></p>
<p>Для асинхронных чтения/записи данных используются функции aio_read() и aio_write(). Обе они принимают адрес сформированной структуры 
aiocb в качестве единственного аргумента. В нормальной ситуации функции возвращают 0, если запрос был принят и поставлен в очередь. 
В противном случае возвращается -1.</p>
<p>Определить статус выполняемой операции можно либо при помощи поля aio_sigevent структуры aiocb, либо при помощи функции aio_error(). 
Если операция была завершена успешно, функция вернет нулевой результат. Если она все еще продолжает выполнение, возвращаемое значение 
будет равно EINPROGRESS.</p>
<p><strong>Windows<br /></strong></p>
<p>Использование асинхронных файловых операций в Windows схоже с библиотекой aio. Аналогом структуры aiocb является структура OVERLAPPED, 
имеющая следующие поля:
<ul>
<li>Internal – код ошибки для операции;</li>
<li>InternalHigh – количество переданных байт. Устанавливается после успешного завершения операции;</li>
<li>Offset – младшее слово смещения в файле, с которого производится операция;</li>
<li>OffsetHigh – старшее слово смещения;</li>
<li>hEvent – дескриптор синхронизирующего события.</li>
</ul></p>
<p>Для асинхронных чтения/записи могут использоваться два семейства функций: стандартные и расширенные.</p>
<p>Во-первых, классические функции ReadFile() и WriteFile() замечательно умеют работать в асинхронном режиме. Для этого надо передать 
им последним параметром указатель на сформированную структуру OVERLAPPED. Основным способом узнать, закончилась ли операция асинхронного
 ввода-вывода, в данном случае является использование поля hEvent. Его необходимо проинициализировать дескриптором существующего события. 
 Перед началом операции функции ReadFile()/WriteFile() переводят его в несигнальное состояние. Переход же события в сигнальное состояние 
 свидетельствует о том, что операция была завершена.</p>
<p>Иной случай – использование расширенного семейства функций ReadFileEx()/WriteFileEx(). Этим функциям также надо передавать указатель 
на структуру OVERLAPPED, однако поле hEvent ими игнорируется. Вместо этого последним параметром эти функции принимают указатель на 
процедуру обратного вызова. Иными словами, можно сообщить Ex-функциям, какую функцию следует вызвать по завершении асинхронной операции.</p> 
<p align="center"><strong>Задание</strong></p>
<p>Функции чтения-записи должны быть выделены в динамическую библиотеку, подключены на этапе выполнения программы.</p>
<p><strong>Динамические библиотеки<br /></strong></p>
<p>В программировании весьма часто возникает ситуация, когда запущенные приложения используют одни и те же функции или участки кода. 
Многократно продублированные таким образом, они приводят к избыточному использованию памяти. Очевидное решение: выделить общие функции 
в отдельные библиотеки, загружая в память лишь одну их копию, которая используется всеми приложениями. Такие библиотеки называются 
разделяемыми или динамически подключаемыми. Рассмотрим детали реализации в различных операционных системах.</p>
<p><strong>Linux<br /></strong></p>
<p>В Linux динамическая библиотека создается полностью аналогично обычному бинарному исполняемому файлу:
<ul>
<li>компиляция исходного кода в объектный файл;</li>
<li>линковка объектного файла в результирующий формат.</li>
</ul></p>
<p>Указать компилятору, что на выходе он должен породить динамическую библиотеку, можно при помощи ключа –shared: <br />
<code>gcc –shared –o mylibrary.so mylibrary.o</code></p>
<p>Имя результирующей библиотеки в данном случае mylibrary.so. Расширение .so (shared object) является обязательным.</p>
<p>Подключение динамической библиотеки к приложению можно осуществить двумя способами. Во-первых, ее можно указать при линковке 
приложения с помощью ключа gcc –l. В этом случае система при загрузке приложения будет автоматически подгружать указанную библиотеку. 
Однако нередки случаи, когда для работы приложения нет необходимости все время иметь в памяти загруженную библиотеку либо из библиотеки
 используется лишь небольшое количество функций, в то время как остальные только занимают место в памяти. В такой ситуации используется
 механизм динамического подключения библиотеки.</p>
<p>Для загрузки библиотеки в произвольный момент времени служит функция dlopen(). Первым параметром она принимает имя загружаемой 
библиотеки, а вторым – флаг загрузки. Он может иметь одно из следующих значений:
<ul>
<li>RTLD_LAZY – разрешение всех неопределенных ссылок в коде будет произведено при непосредственном обращении к загружаемым функциям;</li>
<li>RTLD_NOW – разрешение всех символов производится сразу при загрузке библиотеки;</li>
<li>RTLD_GLOBAL – внешние ссылки, определенные в библиотеке, будут доступны загруженным после библиотекам. Флаг может указываться через 
OR с перечисленными выше значениями.</li>
</ul></p> 
<p>Функция dlopen() возвращает дескриптор загруженной библиотеки. Для непосредственной работы с функциями и переменными, определенными 
в библиотеке, необходимо получить их адрес в памяти. Это можно сделать с помощью функции dlsym(), передав ей дескриптор подключенной 
библиотеки и имя соответствующей функции.</p>
<p>После завершения работы с библиотекой ее можно выгрузить из памяти функцией dlclose().</p>
<p><strong>Windows<br /></strong></p>
<p>Создание динамически подключаемых библиотек (DLL – Dynamically Linked Library) практически в любой среде разработки Windows сводится 
к выбору соответствующего шаблона при создании проекта, так что нет необходимости останавливаться на этом пункте подробнее. Гораздо больший
 интерес представляет динамическое подключение библиотеки.</p>
<p>Загрузка библиотеки производится функцией LoadLibrary(), которая принимает строку с именем dll-файла и возвращает дескриптор загруженной
 библиотеки. Получить адрес переменной или функции из библиотеки можно функцией GetProcAddress(), сообщив ей дескриптор библиотеки и имя 
 соответствующего символа. Выгрузка библиотеки осуществляется при помощи FreeLibrary().</p>
<p align="center"><strong>Задание</strong></p>
<p>В каталоге имеется набор текстовых файлов. Разрабатываемое приложение состоит из двух потоков, которые работают по следующей схеме:
<ul>
<li>1) первый поток (читатель) асинхронным образом считывает содержимое одного файла;</li>
<li>2)  поток-читатель уведомляет второй поток (писатель) о том, что содержимое файла прочитано и может быть передано писателю;</li>
<li>3) поток-писатель получает от первого потока содержимое файла и асинхронным образом записывает полученную строку в конец выходного файла;</li>
<li>4) поток-писатель уведомляет читателя о том, что строка записана в выходной файл и можно приступать к чтению следующего файла;</li>
<li>5) процедура повторяется с п.1, пока не закончится список файлов.</li>
</ul></p>
<p>В результате должна быть произведена конкатенация (объединение) входных текстовых файлов в один результирующий.</p>
<p>Функции чтения-записи использовать из лабораторной работы, посвященной разработке DLL. Динамические библиотеки должны быть выгружены после отработки основного цикла.</p>
</BODY>
</HTML>
