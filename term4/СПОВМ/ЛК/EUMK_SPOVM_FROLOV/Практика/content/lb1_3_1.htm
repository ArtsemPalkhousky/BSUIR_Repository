<!-- (C) 2011-2012 V.Prytkov, V. Suponev, A.Uvarov. BSUIR -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//RU">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1251">
<META HTTP-EQUIV="Content-Language" CONTENT="ru">
<title>Лабораторная работа №3. Потоки. </title>
<base target="_top">
</HEAD><BODY>
<p align="center"><strong>Лабораторная работа  №3. Потоки</strong></p>
<p align="center"><strong>Базовая работа с потоками под Windows и Linux</strong></p>
<p>Цель работы: научиться создавать, уничтожать и управлять вычислительными потоками.</p>
<p align="center"><strong>Теоретическая часть</strong></p>
<p>Понятие потока несколько различается в системах Linux и Windows. Рассмотрим эти концепции подробнее.</p>
<p><strong>Linux<br /></strong></p>
<p>В Linux поток представляет собой облегченную версию процесса (lightweight process). Потоки можно представить как особые процессы, 
принадлежащие родительскому процессу и разделяющие с ним адресное пространство, файловые дескрипторы и обработчики сигналов. Такие потоки
 являются гораздо более легковесными для системы, и как следствие быстрее выполняется переключение между ними, увеличивается быстродействие.
 Однако использование общего адресного пространства порождает ряд проблем синхронизации и некоторые трудности отладки.</p>
<p>У любого потока имеется так называемся потоковая функция, иногда именуемая телом потока. Это функция, указываемая потоку при создании
 и содержащая код, который поток должен выполнить. При выходе из этой функции поток завершается.</p> 
<p>В Linux существует множество библиотек, предоставляющих интерфейс к системным вызовам, управляющим потоками. Стандартом де-факто 
считается библиотека pthreads  (POSIX threads), основные функции которой рассмотрим ниже:</p> 
<p><code>int pthread_create(pthread_t *thread, pthread_attr_t *attr, void * (*start_routine)(void *), void *arg);</code></p>
<p>Функция создает новый поток и принимает следующие параметры:
<ul>
<li>thread – по этому указателю будет записан идентификатор созданного потока;</li>
<li>attr – атрибуты потока;</li>
<li>start_routine – указатель на функцию потока. Она должна иметь прототип void * start_routine(void *). Имя функции произвольно;</li>
<li>arg – аргументы, передаваемые в поток. Если необходимо передать в поток какие-то данные при его создании, их можно записать в отдельную
 область памяти и передать указатель на нее этим параметром, который является аргументом потоковой функции.</li>
</ul></p>
<p>Для завершения потока используйте функцию pthread_exit().</p>
<p>Поскольку потоки выполняются параллельно, открытыми остаются вопросы синхронизации. Первым средством решения этой проблемы является 
использование функции pthread_join(). Данная функция принимает в качестве первого аргумента идентификатор потока и приостанавливает 
выполнение текущего потока, пока не будет завершен поток с указанным идентификатором.</p>
<p>Использование этой функции – инструмент эффективный, но грубый и не всегда подходящий для тонкой синхронизации, когда оба потока должны,
 не завершаясь, синхронизировать свои действия. Для «умной» синхронизации используются специальные объекты, мьютексы.</p>
<p>Мьютекс представляет собой бинарный флаг, который имеет два состояния: «свободно» и «занято». Общая процедура синхронизации, описанной 
в л.р. №2, остается актуальной и для мьютексов. При этом используются следующие функции:
<ul>
<li>pthread_mutex_init – создание мьютекса;</li>
<li>pthread_mutex_lock – установка мьютекса в положение «занято». Если мьютекс уже занят, функция ждет его освобождения и после этого 
занимает его;</li>
<li>pthread_mutex_unlock – установка мьютекса в положение «свободно»;</li>
<li>pthread_mutex_trylock – функция аналогична pthread_mutex_lock, только при занятости мьютекса не ждет его освобождения, а тут же 
возвращает значение EBUSY;</li>
<li>pthread_mutex_destroy – уничтожение мьютекса.</li>
</ul></p> 
<p><strong>Windows<br /></strong></p>
<p>В Windows ситуация несколько отлична от Linux. Здесь процесс на самом деле не выполняет никакого кода, являясь лишь контейнером
 для вычислительных потоков. Потоки - отдельные объекты ядра, коренным образом отличающиеся от процессов. Любой процесс может иметь 
 несколько параллельно выполняющихся внутри него потоков, объединенных общим адресным пространством, общими таблицами дескрипторов 
 процесса и т.д. В процессе должен существовать как минимум один поток, иначе он завершается. При создании процесса создается первичный
 поток, который вызывает входную функцию (main(), WinMain() и т.д.). При завершении входной функции управление вновь передается стартовому
 коду, и тот вызывает функцию ExitProcess(), завершая текущий процесс.</p>
<p>Работа с потоками в Windows, несмотря на основополагающие архитектурные отличия, во многом аналогична работе в Linux. В потоках Windows 
тоже используется понятие потоковой функции. Поток создается следующей функцией WinAPI:</p> 
<p><code>HANDLE CreateThread( PSECURITY_ATTRIBUTES lpThreadAttributes, DWORD dwStackSize,PTHREAD_START_ROUTINE lpStartAddress, PVOID 
lpParameter, DWORD dwCreationFlags, PDWORD lpThreadId);</code></p>
<p>Функция работает со следующими параметрами:
<ul>
<li>lpThreadAttributes – атрибуты безопасности потока;</li>
<li>dwStackSize – размер стека, выделяемого под поток;</li>
<li>lpStartAddress – адрес потоковой функции. Она должна следовать прототипу DWORD WINAPI ThreadFunc(PVOID pvParam);</li>
<li>lpParameter – указатель на параметры, передаваемые функции потока при его создании;</li>
<li>dwCreationFlags – флаг создания потока (поток запускается немедленно или создается в остановленном состоянии);</li>
<li>lpThreadId – указатель, по которому будет записан идентификатор созданного потока.</li>
</ul></p>
<p>Завершается поток одним из четырех способов:
<ul>
<li>функция потока возвращает управление;</li>
<li>поток вызывает функцию ExitThread();</li>
<li>текущий или другой поток вызывает функцию TerminateThread();</li>
<li>завершается процесс, в котором выполняется поток.</li>
</ul></p>
<p>Стоит отметить, что использование функции CreateThread() может привести к некорректной работе приложения, если используются глобальные
 функции и переменные стандартной библиотеки C/C++ (errno, strok, strerror и т.д.). Если их использование необходимо, то рекомендуется 
 прибегнуть к функциям _beginthreadex и _endthreadex, которые реализуют аналогичную функциональность, но безопасны в работе.</p>
<p>Для решения проблемы синхронизации в Windows также существуют мьютексы. Однако они представляют собой, по сути, бинарные семафоры
 и предназначены в первую очередь для взаимодействия процессов. Использование подобных глобальных объектов в многопоточном приложении
 не всегда оправдано.</p> 
<p>Более подходящим механизмом для синхронизации потоков являются критические секции. Логика их использования на самом деле очень похожа
 на работу мьютексов в pthreads. Существуют пять основных функций для работы с критическими секциями:
<ul>
<li>InitializeCriticalSection – создание и инициализация объекта «критическая секция»;</li>
<li>EnterCriticalSection – вход в критическую секцию. Это действие аналогично блокировке мьютекса. Если блокируемая критическая секция 
уже кем-то используется, функция ждет ее освобождения;</li>
<li>LeaveCriticalSection – покинуть критическую секцию;</li>
<li>TryEnterCriticalSection – попробовать войти в критическую секцию. Функция аналогична EnterCriticalSection(). Если критическая секция 
занята, возвращается ноль, в противном случае – ненулевое значение;</li>
<li>DeleteCriticalSection – удалить критическую секцию.</li>
</ul></p> 
<p align="center"><strong>Задание</strong></p>
<p>Задание аналогично лабораторной работе №2, но с реализацией с помощью потоков. Работа выполняется в двух вариантах: под Linux и Windows.</p>
</BODY>
</HTML>
 

