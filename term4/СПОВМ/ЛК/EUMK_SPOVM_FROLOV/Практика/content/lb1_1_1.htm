<!-- (C) 2011-2012 V.Prytkov, V. Suponev, A.Uvarov. BSUIR -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//RU">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1251">
<META HTTP-EQUIV="Content-Language" CONTENT="ru">
<title>Лабораторная работа №1. Cинхронизация процессов. </title>
<base target="_top">
</HEAD><BODY>
<p align="center"><strong>Лабораторная работа №1. Cинхронизация процессов.</strong></p>
<p align="center"><strong>Использование механизмов синхронизации процессов: события в Windows, сигналы в Linux</strong></p>
<p>Цель работы: научиться организовывать синхронизацию нескольких параллельно выполняющихся процессов.</p>
<p align="center"><strong>Теоретическая часть</strong></p>
<p>При разработке программ, использующих несколько параллельно выполняющихся процессов, могут возникать ситуации, требующие синхронизации
 вычислений. К примеру, существует понятие состояния гонки (race condition). В таких случаях должна выполняться строгая последовательность 
 выполнения операций. Такое возможно, когда, к примеру, один процесс должен подготовить ресурс к использованию другим процессом.</p>
<p>Бывают также ситуации, когда процессы одновременно используют некий общий ресурс, доступ к которому не должен перекрываться. Например,
 два процесса выполняют посимвольный вывод текстовых строк в общий файл. В таком случае процесс перед выполнением критической операции 
 должен заблокировать доступ к ресурсу до ее окончания. Только после этого другой процесс имеет право произвести свои действия с этим 
 ресурсом.</p>
<p>Как правило, для синхронизации процессов используют различные индикаторы занятости ресурса. В общем случае процедура синхронизации 
состоит из следующих шагов:
<ul>
<li>проверить доступность ресурса;</li>
<li>если ресурс доступен, заблокировать его. В противном случае подождать до разблокирования его другим процессом;</li>
<li>выполнить необходимую операцию;</li>
<li>разблокировать ресурс.</li>
</ul></p>
<p>Как в Linux, так и в Windows существует большое количество способов синхронизации процессов. Мы рассмотрим два способа на каждую ОС.</p>
<p><strong>Linux<br /></strong></p>
<p>В качестве инструментов синхронизации в Linux наиболее распространены сигналы и семафоры.</p>
<p><strong>Сигналы</strong></p>
<p>Сигналы можно интерпретировать как программные прерывания. При получении сигнала выполнение текущей операции прекращается, и вызывается
 функция-обработчик данного сигнала. Сигналы традиционно делятся на ненадежные и надежные. «Ненадежность» сигнала выражается в том, что в
 некоторых ситуациях процесс может не получить сгенерированный сигнал. Кроме этого, у процессов довольно ограничены возможности по 
 управлению ненадежными сигналами.</p>
<p>Одна из проблем в ненадежных сигналах выражается в том, что обработчик сигнала сбрасывается в значение по умолчанию всякий раз, 
как срабатывает сигнал. Пример использования ненадежных сигналов:<br />
<pre><code>
int sig_int(); /* Прототип функции-обработчика сигнала */
...
signal(SIGINT, sig_int);  /* установка обработчика на сигнал */
...
sig_int();
{
     signal(SIGINT, sig_int);  /* восстановить обработчик */
     ...                       /* обработать сигнал... */
}
</code></pre></p> 
<p>Данный фрагмент кода будет работать корректно в большинстве случаев, однако возможны ситуации, когда второй сигнал придет в промежуток
 времени между срабатыванием функции-обработчика и восстановлением обработчика посредством вызова signal. В таком случае будет вызван 
 обработчик по умолчанию, что для SIGINT означает завершение процесса.</p>
<p>Для установки обработчика сигнала в ненадежной модели используется следующая функция:<br />
<code>
#include &lt;signal.h&gt; <br />
void (*signal(int signo, void (*func)(int)))(int);
</code></p> 
<p>В качестве параметров функция signal принимает номер сигнала (допустимы мнемонические макроопределения SIGINT, SIGUSR1 и т.д.) и 
указатель на функцию-обработчик, которая должна принимать значение типа int (номер сигнала) и не возвращать ничего. Функция signal 
возвращает указатель на предыдущий обработчик данного сигнала. В качестве второго параметра signal можно указать константы SIG_IGN 
(игнорировать данный сигнал) или SIG_DFL (установить значение по умолчанию).</p>
<p>Надежная семантика сигналов подразумевает, что ядро ОС гарантирует, что любой сигнал будет доставлен процессу. При этом процесс 
имеет возможность указать, какие сигналы он будет перехватывать, а какие игнорировать, т.е. составить т.н. маску сигналов.</p>
<p>Установка обработчика в надежной модели производится следующей функцией:<br />
<code>
#include &lt;signal.h&gt; <br />
int sigaction(int signo, const struct sigaction *restrict act, struct sigaction *restrict oact);
</code></p>
<p>Данная функция может как устанавливать новый обработчик, так и возвращать старый. Если параметр act не равен NULL, устанавливается 
новая реакция на сигнал. Если параметр oact не равен NULL, в этот указатель возвращается старый обработчик. Параметр signo – номер сигнала
 – аналогичен таковому параметру в функции signal.</p>
<p>В случае успешной операции sigaction возвращает 0, в противном случае – -1.</p> 
<p>Рассмотрим теперь, что представляет собой структура sigaction:<br />
<pre><code>
struct sigaction {
    void      (*sa_handler)(int);
    sigset_t  sa_mask;
    int       sa_flags;
    void      (*sa_sigaction)(int, siginfo_t *, void *);
};
</code></pre></p>
<p>Эта структура содержит следующие поля:
<ul>
<li>sa_handler – указатель на функцию-обработчик. Может принимать значения SIG_IGN и SIG_DFL;</li>
<li>sa_mask – дополнительная маска игнорируемых сигналов, которая добавляется к существующей, прежде чем будет вызвана функция-обработчик
 сигнала. После возврата управления обработчиком маска возвращается в предыдущее состояние;</li>
<li>sa_flags – флаги, отвечающие за обработку сигнала. Обычно этот параметр устанавливается в 0;</li>
<li>sa_sigaction – альтернативный обработчик сигналов. Используется, если выставлен флаг SA_SIGINFO.</li>
</ul></p>
<p>Для генерации сигналов используются две функции: kill() и raise(). Первая служит для отправки сигнала произвольному процессу, 
вторая - текущему, т.е. самому себе. Синтаксис их вызова таков:<br />
<code>
#include &lt;signal.h&gt; <br />
int kill(pid_t pid, int signo);<br />
int raise(int signo);<br />
</code></p>
<p>Здесь pid – идентификатор процесса, которому отправляется сигнал, а signo – номер сигнала.</p>
<p><strong>Семафоры</strong></p>
<p>Сигналы позволяют реализовать произвольную логику взаимодействия процессов, инициируя срабатывание функций-обработчиков
 в нужное время. Семафоры – инструмент, разработанный исключительно для реализации механизма критических секций в межпроцессном 
 взаимодействии (IPC).</p>
<p>Семафор представляет собой глобальный системный счетчик, теоретически доступный всем процессам. При этом оперирует не одним семафором, 
а набором семафоров (semaphore set).</p>
<p>Создать набор семафоров можно следующей функцией:<br />
<code>
#include &lt;sys/sem.h&gt; <br />
int semget(key_t key, int nsems, int flag);
</code></p>
<p>Данная функция принимает следующие параметры:
<ul>
<li>key – уникальный ключ, идентифицирующий набор семафоров. Имеет тип длинное целое (long int) и обычно генерируется при помощью функции 
ftok();</li>
<li>nsems – количество семафоров в наборе;</li>
<li>flag – флаг, устанавливающий права доступа к набору семафоров.</li>
</ul></p>
<p>Функция возвращает идентификатор набора семафоров в случае успешной операции и -1 при ошибке. При этом данная функция может как 
создавать новый набор семафоров (flag должен содержать значение  IPC_CREAT), так и получать доступ к уже существующему. Для открытия
 существующего набора семафоров необходимо указать ключ key, идентифицирующий созданный ранее набор. В этом случае обычно nsems 
 устанавливается в 0.</p>
<p>Операции с семафорами производятся при помощи двух основных функций: semop() и semctl().</p> 
<p>Функция semop() работает следующим образом:<br />
<code>
#include &lt;sys/sem.h&gt; <br />
int semop(int semid, struct sembuf semoparray[], size_t nops);
</code></p>
<p>Здесь semid – идентификатор набора семафоров, над которым производится операция; semoparray – массив структур типа sembuf, описывающих
 конкретные операции (если операция одна, массив представляет собой указатель на структуру); nops – количество операций (элементов в 
 массиве).</p>
<p>Рассмотрим структуру sembuf:<br />
<pre><code>
struct sembuf {
   unsigned short  sem_num;
   short           sem_op;
   short           sem_flg;
};
</code></pre>
</p>
<p>Sem_num – номер семафора в наборе, над которым производится операция (начиная с нуля). Sem_op – сама операция. При этом действие этого
 параметра отличается в каждом из нижеперечисленных случаев:
<ul>
<li>sem_op &gt;0: значение параметра прибавляется к текущему значению счетчика семафора;</li>
<li>sem_op ==0: операция «дождаться нуля». Процесс переводится в состояние ожидания, пока значение семафора не станет равным нулю;</li>
<li>sem_op &lt;0: модуль значения параметра отнимается от текущего значения счетчика семафора, если при этом результат не становится 
меньше нуля. В противном случае процесс переводится в состояние ожидания, пока такая операция не станет возможна, т.е. пока значение 
счетчика не станет больше либо равным модулю sem_op. При этом, если sem_flg установлен в IPC_NOWAIT, процесс в состояние ожидания не 
переводится, а во всех соответствующих случаях функция semop() возвращает значение -1 и устанавливает переменную errno в EAGAIN.</li>
</ul></p>
<p>Состояние ожидание процесса прерывается не только установкой семафора в соответствующее состояние, но также в следующих случаях:
<ul>
<li>удаление набора семафоров, вызвавших блокировку процесса;</li>
<li>получение процессом сигнала, на который установлен обработчик.</li>
</ul></p>
<p>Функция semctl() предоставляет расширенный спектр операций над семафорами, позволяя получать статус семафора, получать и устанавливать
 значение счетчика семафора, удалять набор семафоров и т.д. В общем случае для решения задач межпроцессного взаимодействия достаточно 
 функции semop(), а semctl() обычно используется для удаления набора семафоров, когда в них отпадает надобность. Делать это необходимо, 
 потому что семафоры являются глобальными объектами ядра и сохраняются в системе и после завершения процесса.</p>
<p><strong>Windows</strong></p>
<p>Для синхронизации процессов в Windows обычно используются события и семафоры.</p>
<p><strong>События</strong></p>
<p>Один из самых распространенных механизмов межпроцессной синхронизации в Windows – события. Они не являются полным аналогом unix-сигналов,
 представляя собой бинарные флаги, имеющие два потенциальных состояния: сигнальное (свободное, открытое) и несигнальное (занятое, закрытое). 
 Событие может быть одного из двух типов: со сбросом вручную и с автосбросом.</p>
<p>Для создания события используется функция CreateEvent():<br />
<code>HANDLE CreateEvent(PSECURITY_ATTRIBUTES psa, BOOL fManualReset, BOOL fInitialState, PCTSTR pszName);</code></p>
<p>Функция принимает следующие параметры:
<ul>
<li>psa – атрибуты защиты;</li>
<li>fManualReset – TRUE, если событие сбрасывается вручную, FALSE в противном случае;</li>
<li>fInitialState – начальное состояние события (TRUE – сигнальное, FALSE - несигнальное);</li>
<li>pszName – уникальное имя-идентификатор события.</li>
</ul></p>
<p>Получить доступ к событию из другого процесса можно следующими способами:
<ul>
<li>вызвав функцию CreateEvent() с тем же именем, которое было присвоено событию первым процессом;</li>
<li>унаследовав дескриптор;</li>
<li>применив функцию DuplicateHandle();</li>
<li>вызвав функцию OpenEvent() с указанием имени существующего события.</li>
</ul></p>
<p>Управлять состоянием события позволяют две функции: SetEvent() переводит его в сигнальное состояние, ResetEvent() – в несигнальное. 
Для ожидания события используется функция WaitForSingleObject(). Если событие создано с флагом автосброса, то при успешном окончании 
ожидания событие автоматически переведется в несигнальное состояние.</p>
<p><strong>Семафоры</strong></p>
<p>Второй рассматриваемый тип синхронизирующих объектов в Windows – семафоры. Принципиальных различий между семафорами в Unix и Windows
 не так много, основное различие для программиста заключается в инструментальных средствах управления ими.</p>
<p>Семафор создается функцией CreateSemaphore():<br />
<code>HANDLE CreateSemaphore( PSECURITY_ATTRIBUTE psa, LONG lInitialCount, LONG lMaximumCount, PCTRTR pszName);</code></p> 
<p>Функция принимает следующие параметры:
<ul>
<li>psa – атрибуты защиты;</li>
<li>fManualReset – TRUE, если событие сбрасывается вручную, FALSE в противном случае;</li>
<li>lInitialCount – начальное значение счетчика семафора;</li>
<li>lMaxCount – максимальное значение счетчика семафора;</li>
<li>pszName – уникальное имя-идентификатор события.</li>
</ul></p>
<p>Очевидно, что, в отличие от Linux, Windows оперирует не наборами, а отдельными семафорами. Унаследовать созданный семафор можно теми
 же методами, что и событие. Для открытия семафора можно использовать OpenSemaphore().</p>
<p>Значение счетчика ресурсов увеличивается при вызове функции ReleaseSemaphore(). При этом можно изменить его не только на 1, как это 
обычно делается, но и на любое другое значение.</p> 
<p>Дождаться освобождения ресурса (ненулевого состояния семафора) можно при помощи функции WaitForSingleObject(). При этом счетчик ресурсов 
автоматически будет уменьшен на единицу.</p>
<p align="center"><strong>Задание</strong></p>
<p>Начальный процесс является управляющим. Он принимает поток ввода с клавиатуры и контролирует дочерние процессы. По нажатию клавиши ‘+’ 
добавляется новый процесс, ‘-’ – удаляется последний добавленный, ‘q’ – программа завершается. Каждый дочерний процесс посимвольно выводит 
на экран в вечном цикле свою уникальную строку. При этом операция вывода строки должна быть атомарной, т.е. процесс вывода должен быть 
синхронизирован таким образом, чтобы строки на экране не перемешивались. Выполняется в двух вариантах: под Linux и Windows. В качества 
метода синхронизации использовать сигналы/события.</p>
</BODY>
</HTML>
 


