<!-- (C) 2011-2012 V.Prytkov, V. Suponev, A.Uvarov. BSUIR -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//RU">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1251">
<META HTTP-EQUIV="Content-Language" CONTENT="ru">
<title>Лабораторная работа №2. Взаимодействие процессов. </title>
<base target="_top">
</HEAD><BODY>
<p align="center"><strong>Лабораторная работа  №2. Взаимодействие процессов</strong></p>
<p align="center"><strong>Организация взаимодействия процессов с синхронизацией с помощью семафоров: каналы и FileMapping в Windows, 
каналы и сегменты разделяемой памяти в Linux</strong></p>
<p>Цель работы: Научиться осуществлять передачу произвольных данных между параллельно выполняющимися процессами.</p>
<p align="center"><strong>Теоретическая часть</strong></p>
<p>При взаимодействии нескольких параллельных процессов часто возникает необходимость обмена данными между ними. При этом встает 
следующая проблема: каждый процесс имеет собственное адресное пространство, и переменные одного процесса недоступны другим процессам. 
Обычно для передачи данных между процессами используют глобальные объекты ядра, выделение общих сегментов памяти, сокеты, каналы и т.д. 
Под каждую из рассматриваемых операционных систем существует большое количество методов и способов решения данной проблемы, поэтому 
подробно остановимся на наиболее часто используемых.</p>
<p><strong>Linux<br /></strong></p>
<p>Чаще всего для передачи данных между процессами в Linux используются каналы (pipes) и сегменты разделяемой памяти.</p>
<p><strong>Каналы<br /></strong></p>
<p>Канал представляет собой специальный файл, связывающий два процесса. Таким образом, передача информации через канал сводится к 
записи в него данных в одном процессе и чтению из него в другом. Ранние unix-системы не поддерживали полнодуплексную передачу данных, 
т.е. чтение и запись одним процессом через один канал; для двусторонней связи приходилось организовывать два канала. Несмотря на то, 
что практически все современные системы такую возможность предоставляют, необходимо быть осторожным при разработке приложений и 
предусматривать наличие только полудуплексной передачи данных.</p>
<p>Канал создается системной функцией pipe():<br />
<code>
#include &lt;unistd.h&gt;<br />
int pipe(int filedes[2]);
</code></p>
<p>Функции надо передать массив filedes из двух целочисленных элементов, первый из которых будет проинициализирован файловым дескриптором
 для чтения, а второй – для записи.</p>
<p>Если канал создан успешно, функция pipe() возвратит 0. В противном случае - -1.</p> 
<p>Дескрипторы можно использовать напрямую функциями read() и write(), а можно преобразовать к стандартному файловому потоку FILE* 
функцией fdopen(). Второй вариант позволяет использовать высокоуровневые функции форматированного ввода-вывода, такие как fprintf() и
fgets().</p>
<p>Необходимо учитывать также, что каналы можно использовать только с процессами, имеющими общего предка. Обычно канал создается до вызова 
fork() и используется затем в обоих процессах-клонах.</p>
<p>Существует правило, согласно которому неиспользуемый конец канала должен быть закрыт. То есть процесс-писатель закрывает дескриптор 
чтения и наоборот.</p>
<p><strong>Сегменты разделяемой памяти<br /></strong></p>
<p>Каналы позволяют связать два процесса. Если взаимодействующих процессов больше, либо по каким-то причинам использование каналов 
исключается, можно использовать сегменты разделяемой памяти. При этом выделяется область памяти, идентифицируемая уникальным 
целочисленным ключом и доступная всем процессам, которые пожелают обратиться к ней по этому ключу.</p>
<p>Сегмент разделяемой памяти выделяется следующей функцией:<br />
<code>
#include &lt;sys/shm.h&gt; <br />
int shmget(key_t key, size_t size, int flag);
</code></p>
<p>Функции необходимо передать следующие параметры:
<ul>
<li>key – уникальный ключ. Правила формирования ключа аналогичны случаю с семафорами;</li>
<li>tsize – размер выделяемой области в байтах;</li>
<li>flag – флаг доступа, аналогичный случаю с семафорами.</li>
</ul></p>
<p>При успешном завершении функция возвращает идентификатор созданного сегмента, в противном случае - -1. Так же, как и с семафорами, 
можно получить доступ к созданной ранее области разделяемой памяти, через ключ key.</p>
<p>Для непосредственного использования разделяемой памяти необходимо получить адрес сегмента с помощью функции shmat():<br />
<code>
#include &lt;sys/shm.h&gt; <br />
void *shmat(int shmid, const void *addr, int flag);
</code></p>
<p>Функция принимает идентификатор существующего сегмента, указатель, в который будет записан адрес сегмента, и флаг доступа. После 
вызова функции с памятью можно работать через прямой указатель. Все данные, записанные через этот указатель, будут доступны процессам, 
использующим данный сегмент. После завершения работы необходимо вызвать функцию shmdt() для отсоединения сегмента.</p>
<p>Для расширенных операций над сегментом разделяемой памяти используется функция shmctl(). В спектре ее возможностей получение и 
установка параметров сегмента, его удаление, а также блокирование/разблокирование. Операции по блокировке сегмента предоставляют не 
все Unix-системы; на данный момент эта возможность присутствует только в Linux и Solaris.</p>
<p>Удаление сегмента производится посредством вызова функции shmctl() с параметром IPC_RMID. При этом сегмент удаляется, когда все 
процессы, его использующие, отсоединяют его. Во избежание накапливания неиспользуемых сегментов разделяемой памяти, каждый сегмент 
должен быть вручную удален после завершения работы с ним. Использование функций exit() и exec() отсоединяет сегмент, но не удаляет его.</p>
<p><strong>Windows<br /></strong></p>
<p>Среди наиболее часто употребляемых механизмов передачи данных между процессами в Windows можно выделить каналы и разделяемую память.</p>
<p><strong>Каналы<br /></strong></p>
<p>Подобно каналам в Linux, в Windows каналы также связывают два процесса. Процесс, создающий канал, обычно называют сервером, а процесс, 
использующий этот канал – клиентом. Каналы в Windows бывают двух типов: анонимные и именованные. Первые универсальны и быстры, однако 
процессу-клиенту сложнее получить дескриптор канала, они не поддерживают дуплексную передачу данных и не работают в сетях. Именованные 
каналы свободны от этих недостатков, однако немного более тяжеловесны для операционной системы.</p>
<p>Использование каналов в Windows во многом подобно таковому в Linux. Рассмотрим основные функции для работы с каналами.</p>
<p><code>BOOL CreatePipe(  PHANDLE hReadPipe, PHANDLE hWritePipe, LPSECURITY_ATTRIBUTES lpPipeAttributes, DWORD nSize);</code></p>
<p>Функция создает анонимный канал с параметрами:
<ul>
<li>hReadPipe – дескриптор чтения;</li>
<li>hWritePipe – дескрпитор записи;</li>
<li>lpPipeAttributes – атрибуты защиты;</li>
<li>nSize – количество байт, резервируемых для канала.</li>
</ul></p>
<p><code>HANDLE CreateNamedPipe(  LPCTSTR lpName, DWORD   dwOpenMode, DWORD   dwPipeMode, DWORD   nMaxInstances, DWORD   nOutBufferSize, 
DWORD   nInBufferSize, DWORD   nDefaultTimeOut, LPSECURITY_ATTRIBUTES lpSecurityAttributes);</code></p>
<p>Функция принимает следующие параметры:
<ul>
<li>lpName – имя канала. Как правило, оно представляет собой примерно следующую строку: «\\Имя сервера\pipe\Имя канала». При использовании
 именованных каналов на локальной машине данная строка сокращается до «\\.\pipe\Имя канала»;</li>
<li>dwOpenMode – режим открытия канала;</li>
<li>nMaxInstances – максимальное количество реализаций канала;</li>
<li>nOutBufferSize – размер выходного буфера;</li>
<li>nInBufferSize – развер входного буфера;</li>
<li>nDefaultTimeOut – время ожидания в миллисекундах;</li>
<li>lpSecurityAttributes – атрибуты защиты.</li>
</ul></p>
<p>Для дальнейшего использования канала с серверной и клиентской сторон необходимо использовать следующие функции: ConnectNamedPipe() 
(для именованных каналов), CreateFile(), ReadFile(), WriteFile(). После установления соединения через канал с ним можно работать как с 
обычным файлом.</p>
<p><strong>Разделяемая память<br /></strong></p>
<p>Еще один способ передать данные между процессами – использование файлов, отображаемых в память. При этом один процесс создает 
специальный объект, «файловую проекцию», выделяя область памяти, которая связывается с определенным файлом и в дальнейшем может быть 
доступна глобально из других процессов.</p>
<p>Для передачи данных между процессами такое решение может показаться избыточным. Однако нет необходимости в некоем специальном файле, 
проекция может использоваться исключительно для выделения виртуальной памяти без привязки к конкретному файлу.</p>
<p>Последовательность действий при этом такова. Для создания файловой проекции используется следующая функция:</p>
<p><code>HANDLE WINAPI CreateFileMapping( HANDLE hFile,  LPSECURITY_ATTRIBUTES lpAttributes,  DWORD flProtect,  DWORD dwMaximumSizeHigh,  
DWORD dwMaximumSizeLow, LPCTSTR lpName);</code></p>
<p>Данная функция принимает параметры:
<ul>
<li>hFile – дескриптор файла, связываемого с выделяемой областью памяти. Если связывать файл не нужно, а функция используется только для 
выделения общей области памяти, данный параметр устанавливатся в INVALID_HANDLE_VALUE. При этом в качестве проецируемого файла будет 
использоваться системный файл подкачки. В этом случае также необходимо явно указать размер выделяемой памяти в параметрах dwMaximumSizeHigh
 и dwMaximumSizeLow;</li>
<li>lpAttributes – атрибуты безопасности;</li>
<li>flProtect – флаги защиты выделенной области;</li>
<li>dwMaximumSizeHigh – старшее слово размера выделяемой памяти в байтах;</li>
<li>dwMaximumSizeLow – младшее слово размера выделяемой памяти в байтах;</li>
<li>lpName – имя объекта «файловая проекция».</li>
</ul></p>
<p>После создания файлового отображения, необходимо получить его адрес в памяти для того, чтобы записать туда передаваемые данные. Это 
производится следующей функцией:</p>
<p><code>LPVOID MapViewOfFile( HANDLE hFileMappingObject,   DWORD dwDesiredAccess,  DWORD dwFileOffsetHigh,  DWORD dwFileOffsetLow, 
SIZE_T dwNumberOfBytesToMap);</code></p>
<p>Принимаемые параметры:
<ul>
<li>hFileMappingObject – дескриптор файловой проекции, полученный от предыдущей функции;</li>
<li>dwDesiredAccess – режим доступа к области памяти;</li>
<li>dwFileOffsetHigh – старшее слово смещения файла, с которого начинается отображение;</li>
<li>dwFileOffsetLow – младшее слово смещения;</li>
<li>dwNumberOfBytesToMap – число отображаемых байт. Если параметр равен нулю, отображается весь файл.</li>
</ul></p>
<p>Данная функция возвращает указатель на спроецированную область памяти. После его получения можно записывать в полученную общую память 
необходимые данные.</p>
<p>Процесс-клиент должен получить доступ к выделенной другим процессом памяти. Здесь нужно учитывать, что файловая проекция уникально 
идентифицируется именем, указанным в функции CreateFileMapping(). Для получения дескриптора проекции необходимо воспользоваться функцией 
OpenFileMapping() и по полученному дескриптору при помощи функции MapViewOfFile() получить указатель на искомую область памяти.</p>
<p align="center"><strong>Задание</strong></p>
<p>Создаются два процесса: клиентский и серверный. Серверный процесс ждет ввода пользователем текстовой строки и по нажатию клавиши 
Enter производит следующие действия:
<ul>
<li>клиентский процесс уведомляется о том, что серверный процесс готов начать передачу данных (синхронизация);</li>
<li>серверный процесс передает полученную от пользователя строку клиентскому процессу, используя либо каналы, либо сегменты разделяемой 
памяти / файловые проекции;</li>
<li>клиентский процесс выводит полученную строку на экран и уведомляет серверный процесс об успешном получении строки;</li>
<li>серверный процесс ожидает ввода следующей строки и т.д.</li>
</ul></p>
<p>В данной работе продолжается освоение синхронизации процессов. Уведомление процессов должно производиться посредством семафоров. 
Реализация механизма непосредственной передачи данных остается на выбор студента, однако в теории освоены должны быть все варианты.</p>
<p>Работа выполняется в двух вариантах: под Linux и Windows.</p>
</BODY>
</HTML>




