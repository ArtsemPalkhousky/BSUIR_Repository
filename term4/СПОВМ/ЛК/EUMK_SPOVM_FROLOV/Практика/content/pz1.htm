<!-- (C) 2011-2012 V.Prytkov, V. Suponev, A.Uvarov. BSUIR -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//RU">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1251">
<META HTTP-EQUIV="Content-Language" CONTENT="ru">
<title>Практическое занятие №1: Взаимоблокировки.</title>
<base target="_top">
<style type="text/css">
.f1 {
	color: #0F0;
}
.f1 {
	color: #0F0;
}
.f2 strong {
	color: #F00;
}
f2 {
	color: #F00;
}
</style>
</HEAD><BODY>
<h2 style="text-align: center;">Практическое занятие №1: Взаимоблокировки.</h2>
<ul>
<li>Основные термины</li>
<li>Обнаружение взаимоблокировок</li>
</ul>
<h2 style="page-break-before: always;"><strong>Взаимоблокировки</strong></h2>
<ul>
<li><em><strong>Взаимоблокировка (тупик, deadlock)&ndash; это ситуация, когда существует некоторая круговая последовательность параллельных процессов, каждый из которых для продолжения работы требует ресурса, удерживаемого следующим в данной последовательности процессом </strong></em><img src="../images/pz1_1.gif" width="292" height="266" align="right"></li>
<li><em><strong>Задача об обедающих философах</strong></em></li>
<li><em><strong>Модель Холта</strong></em></li>
<li><em><strong>Модель безопасных состояний</strong></em></li>
</ul>
<ul>
<li><em><strong>Условия, необходимые и достаточные для возникновения взаимоблокировок (Коффман):</strong></em></li>
<ul>
<li><em><strong>условие взаимного исключения</strong></em></li>
<ul>
<li><em><strong>каждый ресурс в данный момент времени или отдан ровно одному процессу, или доступен</strong></em></li>
</ul>
<li><em><strong>условие удержания и ожидания</strong></em></li>
<ul>
<li><em><strong>процессы, удерживающие полученные ранее ресурсы, могут запрашивать новые ресурсы</strong></em></li>
</ul>
<li><em><strong>условие отсутствия принудительной выгрузки</strong></em></li>
<ul>
<li><em><strong>у процесса нельзя принудительно забрать ранее полученные им ресурсы</strong></em></li>
</ul>
<li><em><strong>условие циклического ожидания</strong></em></li>
<ul>
<li><em><strong>см. определение взаимоблокировки</strong></em></li>
</ul>
</ul>
</ul>
<p><em><strong>Стратегии при решении проблемы тупиков :</strong></em></p>
<ul>
<li><em><strong>пренебрежение проблемой </strong></em></li>
<li><em><strong>обнаружение и восстановление: позволить взаимоблокировке произойти, обнаружить ее и предпринять какие-либо действия</strong></em></li>
<li><em><strong>предотвращение с помощью структурного опровержения одного из четырех условий, необходимых для взаимоблокировки</strong></em></li>
<li><em><strong>Избегание (обход) тупика с помощью аккуратного распределения ресурсов</strong></em></li>
</ul>
<p><img src="../images/pz1_2.gif" width="680" height="474"></p>
<h2 style="page-break-before: always;"><strong>Моделирование тупиков с помощью графов</strong></h2>
<p><strong>На такой модели очень хорошо проверить возникает ли взаимоблокировка. Если есть цикл, значит, есть и взаимоблокировка.</strong></p>
<p><strong>Рассмотрим простой пример:</strong></p>
<p><strong>три процесса A, B, C</strong></p>
<p><strong>три ресурса R, S, T</strong></p>
<p><img src="../images/pz1_3.gif" width="647" height="176"></p>
<p class="f1"><strong>Последовательное выполнение процессов, взаимоблокировка не возникает</strong></p>
<p><strong>Рассмотрим циклический алгоритм:</strong></p>
<p><strong>три процесса A, B, C</strong></p>
<p><strong>три ресурса R, S, T</strong></p>
<p><img src="../images/pz1_4.gif" width="741" height="364"></p>
<p class="f2"><strong>Возникает взаимоблокировка</strong></p>
<p><strong>Рассмотрим тот же самый случай, но допустим, что система, зная о предстоящей взаимоблокировке, заблокирует процесс&nbsp;B.</strong></p>
<p><img src="../images/pz1_5.gif" width="730" height="368"></p>
<p class="f1"><strong>Взаимоблокировка не возникает.</strong></p>
<h2 style="page-break-before: always;"><strong>Обнаружение взаимоблокировок: <em>модель Холта</em></strong></h2>
<p><em><strong>Обнаружение тупика при наличии одного ресурса каждого вида</strong></em></p>
<p><em><strong>Составляется граф ресурсов (модель Холта)</strong></em></p>
<p><img src="../images/pz1_6.gif" width="657" height="467"></p>
<p><strong>Визуально хорошо видна взаимоблокировка, но нам нужно чтобы ОС сама определяла взаимоблокировку.</strong></p>
<p><strong>Для этого нужен алгоритм.</strong></p>
<p><strong>Для каждого узла N в графе выполняется пять шагов.</strong></p>
<p>&nbsp;</p>
<ul>
<li><strong>Задаются начальные условия: L-пустой список, все ребра не маркированы.</strong></li>
<li><strong>Текущий узел добавляем вконец списка L и проверяем количество появления узла в списке. Если он встречается два раза, значит цикл и взаимоблокировка.</strong></li>
<li><strong>Для заданного узла смотрим, выходит ли из него хотя бы одно немаркированное ребро. Если да, то переходим к шагу 4, если нет, то переходим к шагу 5.</strong></li>
<li><strong>Выбираем новое немаркированное исходящее ребро и маркируем его. И переходим по нему к новому узлу и возвращаемся к шагу 3.</strong></li>
<li><strong>Зашли в тупик. Удаляем последний узел из списка и возвращаемся к предыдущему узлу. Возвращаемся к шагу 3. Если это первоначальный узел, значит, циклов нет, и алгоритм завершается.</strong></li>
</ul>
<p><img src="../images/pz1_7.gif" width="673" height="567"></p>
<h2 style="page-break-before: always;"><strong>Обнаружение взаимоблокировок</strong></h2>
<p><em><strong>По графу определяется, имеется ли взаимоблокировка</strong></em></p>
<ul>
<li><em><strong>Обнаружение замкнутых циклов</strong></em></li>
</ul>
<p><img src="../images/pz1_8.gif" width="932" height="599"></p>
<p>&nbsp;</p>
<h2 style="page-break-before: always;"><strong>Обнаружение взаимоблокировок: <em>Редукция вершин</em></strong></h2>
<ul>
<li><em><strong>Редукция вершин</strong></em></li>
<ul>
<ul>
<li><em><strong>Процессы, которым предоставлены все требуемые ресурсы, либо запрашиваемые ресурсы помечены как свободные, редуцируются</strong></em></li>
<li><em><strong>Ресурсы, связанные с такими процессами, помечаются как свободные</strong></em></li>
<li><em><strong>Если были редукции, цикл повторяется</strong></em></li>
<li><em><strong>Если в результате в графе остались нередуцированные процессы, то имеется взаимоблокировка</strong></em></li>
</ul>
</ul>
</ul>
<h2 style="page-break-before: always;"><strong>Обнаружение взаимоблокировок: <em>матричный подход</em></strong></h2>
<p><em><strong>Обнаружение тупика при наличии нескольких ресурсов каждого вида</strong></em></p>
<ul>
<li><em><strong>Используются рассмотренные алгоритмы с учетом множественного предоставления ресурса</strong></em></li>
<li><em><strong>Используется матричный подход:</strong></em></li>
<ul>
<ul>
<li><em><strong>n число процессов P1&hellip;Pn в системе</strong></em></li>
<li><em><strong>m &ndash; число классов ресурсов</strong></em></li>
<li><em><strong>Ei &ndash; число ресурсов класса i, 1&lt;=i&lt;=m</strong></em></li>
<li><em><strong>Е = { E1,&hellip;Em } &ndash; вектор существующих ресурсов</strong></em></li>
<li><em><strong>Аi &ndash; это количество не использующихся экземпляров ресурса i</strong></em></li>
<li><em><strong>А = { A1&hellip;Am} &ndash; вектор доступных ресурсов</strong></em></li>
</ul>
</ul>
</ul>
<p>&nbsp;</p>
<ul>
<ul>
<ul>
<li><em><strong>C &ndash; матрица текущего распределения</strong></em></li>
<li><em><strong>Cij &ndash; количество экземпляров ресурса j, которое занимает процесс i</strong></em></li>
<li><em><strong>i строка матрицы показывает, какое количество ресурсов каждого класса использует процесс Pi</strong></em></li>
<li><em><strong>R &ndash; матрица запросов</strong></em></li>
<li><em><strong>Rij &ndash; количество экземпляров ресурса j, которое хочет получить процесс Pi</strong></em></li>
</ul>
</ul>
</ul>
<p><img src="../images/pz1_9.gif" width="875" height="235"></p>
<p><em><strong>Если сложить все экземпляры ресурса j, предоставленные процессам и доступные в данный момент, то в результате получим существующее в системе количество экземпляров данного класса ресурсов:</strong></em></p>
<p><img src="../images/pz1_10.gif" width="302" height="128"></p>
<p><em><strong>Алгоритм обнаружения взаимоблокировок основан на сравнении векторов. Определим, что A&lt;=B тогда и только тогда когда Ai&lt;=Bi, 1&lt;=i&lt;=m</strong></em></p>
<p>&nbsp;</p>
<h2 style="page-break-before: always;"><strong>Обнаружение взаимоблокировок</strong><img src="../images/pz1_11.gif" width="508" height="532" align="right"></h2>
<ul>
<li><em><strong>В начальном состоянии все процессы немаркированы </strong></em></li>
<li><em><strong>Алгоритм ищет процесс, который может быть завершен</strong></em></li>
<li><em><strong>Для него все требуемые ресурсы должны быть доступны</strong></em></li>
<li><em><strong>Найденный процесс может завершить работу и вернуть ресурсы</strong></em></li>
<li><em><strong>На него ставится маркер, что он может завершить работу </strong></em></li>
<li><em><strong>После окончания алгоритма любой немаркированный процесс будет находится в тупике</strong></em></li>
</ul>
<p>&nbsp;</p>
<h1 style="page-break-before: always;">&nbsp;</h1>
<p><em><strong>&nbsp; &nbsp; &nbsp; Рес1 Рес2 Рес3 Рес4</strong></em></p>
<p><em><strong>E={ 4 &nbsp; &nbsp; &nbsp; 2 &nbsp; &nbsp; &nbsp;3 &nbsp; &nbsp; &nbsp; 1} - существующие ресурсы</strong></em></p>
<p><em><strong>A={ 2 &nbsp; &nbsp; &nbsp; 1 &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; 0} - доступные ресурсы</strong></em></p>
<p>&nbsp;</p>
<p><em><strong>М-ца текущего распределения Матрица запросов</strong></em></p>
<p><em><strong>&nbsp; &nbsp; &nbsp; 0 0 1 0 &nbsp; &nbsp; &nbsp; 2 0 0 1</strong></em></p>
<p><em><strong>С= 2 0 0 1 R= 1 0 1 0</strong></em></p>
<p><em><strong>&nbsp; &nbsp; &nbsp; 0 1 2 0 &nbsp; &nbsp; &nbsp; 2 1 0 0</strong></em></p>
<p>&nbsp;</p>
<h1 style="page-break-before: always;">&nbsp;</h1>
<p><em><strong>&nbsp; &nbsp; &nbsp; 0010 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2001 A={ 2 1 0 0 } </strong></em></p>
<p><em><strong>С= 2001 &nbsp; &nbsp; R= 1010</strong></em></p>
<p><em><strong>&nbsp; &nbsp; &nbsp; 0120 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2100 R1 &gt; A; R2 &gt; A; R3 = A</strong></em></p>
<p>&nbsp;</p>
<p><em><strong>&nbsp; &nbsp; &nbsp; 0010 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2001 A={ 2 2 2 0 }</strong></em></p>
<p><em><strong>С= 2001 &nbsp; &nbsp; R= 1010</strong></em></p>
<p><em><strong>&nbsp; &nbsp; &nbsp; 0000 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0000 R1 &gt; A; R2 &lt;= A;</strong></em></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><em><strong>&nbsp; &nbsp; &nbsp; 0010 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2001 A = { 4 2 2 1 } </strong></em></p>
<p><em><strong>С= 0000 &nbsp; &nbsp; R= 0000</strong></em></p>
<p><em><strong>&nbsp; &nbsp; &nbsp; 0000 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0000 R1 &lt;= A; </strong></em></p>
<p>&nbsp;</p>
<p><em><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;A = { 4 2 3 1 }</strong></em></p>
<h2 style="page-break-before: always;"><strong>Восстановление</strong></h2>
<p><em><strong>Восстановление:</strong></em></p>
<ul>
<li><em><strong>Принудительной выгрузкой ресурса (нарушаем условие Хоффмана) </strong></em></li>
<ul>
<ul>
<li><em><strong>Это не всегда возможно</strong></em></li>
<li><em><strong>Часто требует ручного вмешательства</strong></em></li>
</ul>
</ul>
<li><em><strong>Откат</strong></em></li>
<ul>
<ul>
<li><em><strong>Процессы периодически создают контрольные точки</strong></em></li>
<li><em><strong>Новая КТ не должна записываться поверх старой</strong></em></li>
<li><em><strong>При обнаружении взаимоблокировки требуется определить, каких ресурсов процессам не хватает</strong></em></li>
<li><em><strong>Процесс-владелец этого ресурса выполняет откат к той контрольной точке, когда ресурс был свободен</strong></em></li>
<li><em><strong>Вся работа, выполненная после этой КТ, теряется</strong></em></li>
</ul>
</ul>
</ul>
<ul>
<li><em><strong>Уничтожение процессов</strong></em></li>
<ul>
<ul>
<li><em><strong>Наиболее эффективный способ</strong></em></li>
<li><em><strong>Уничтожается процесс, находящийся в цикле взаимоблокировки</strong></em></li>
<li><em><strong>Если после этого взаимоблокировка не исчезла, удаляют еще один процесс из цикла</strong></em></li>
<li><em><strong>По возможности, следует уничтожать те процессы, которые можно запустить с самого начала без лишних затрат</strong></em></li>
</ul>
</ul>
</ul>
<h2 style="page-break-before: always;"><strong>Избегание тупика. Алгоритм банкира</strong></h2>
<p><em><strong>Алгоритм банкира &ndash; Дейкстра, 1965</strong></em></p>
<ul>
<li><em><strong>Безопасное (надежное) состояние - система не находится в тупике и существует такой порядок планирования, при котором каждый процесс может работать до завершения, даже если все процессы захотят немедленно получить свое максимальное количество ресурсов</strong></em></li>
<li><em><span style="text-decoration: underline;"><strong>Ненадежное состояние может привести к блокировке, а может и не привести</strong></span></em></li>
<li><em><strong>Модель основана на примере банкира в небольшом городке, имеющего клиентов (процессы), которым выдает кредиты (ресурсы)</strong></em></li>
<li><em><strong>При заявке клиента на получение еще одного кредита, проверяется, хватит ли у банкира сумм, чтобы в итоге все клиенты смогли завершить свои операции</strong></em></li>
</ul>
<h2 style="page-break-before: always;"><strong>Алгоритм банкира</strong></h2>
<ul>
<li><em><strong>Фактически алгоритм идентичен алгоритму поиска взаимоблокировок</strong></em></li>
<ul>
<li><em><strong>При запросе очередного ресурса, система проверяет, что произойдет, если ресурс будет выделен</strong></em></li>
<li><em><strong>Моделируется ситуация, при которой процесс получил требуемый ресурс и выполняется проверка на взаимоблокировку</strong></em></li>
<li><em><strong>Если ее нет, состояние системы останется безопасным и ресурс процессу предоставляется</strong></em></li>
<li><em><strong>Если же обнаруживается взаимоблокировка, то состояние становится небезопасным, и запрос отклоняется</strong></em></li>
</ul>
</ul>
<ul>
<li><em><strong>Однако подобный алгоритм требует</strong></em></li>
<ul>
<li><em><strong>полных сведений о том, сколько ресурсов может потребоваться процессу</strong></em></li>
<li><em><strong>процессы должны гарантированно возвращать ресурсы</strong></em></li>
<li><em><strong>количество процессов и ресурсов не должно меняться</strong></em></li>
</ul>
<li><em><strong>на практике рассмотренный алгоритм практически не используется</strong></em></li>
</ul>
<h2 style="page-break-before: always;"><strong>Избегание тупика</strong><img src="../images/pz1_12.gif" width="572" height="571" align="right"></h2>
<ul>
<li>Недостижимые (запрещенные)</li>
<li>Опасные (ненадежное)</li>
<li>Безопасное (надежное)</li>
<li>Условно безопасное (потенциально опасное)</li>
<li>Тупик (взаимоблокировка)</li>
</ul>
<p>&nbsp;</p>
<table style="height: 274px;" border="1" width="519">
<tbody>
<tr>
<td>&nbsp;</td>
<td>
<p><em><strong>Макс.</strong></em></p>
</td>
<td colspan="10">
<p><em><strong>Имеет</strong></em></p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td colspan="5">
<p><em><strong>Безопасно</strong></em></p>
&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td colspan="5">
<p><em><strong>Небезопасно</strong></em></p>
&nbsp;&nbsp;&nbsp;&nbsp;</td>
</tr>
<tr>
<td>
<p><em><strong>А</strong></em></p>
</td>
<td>
<p><em><strong>9</strong></em></p>
</td>
<td>
<p><em><strong>3</strong></em></p>
</td>
<td>
<p><em><strong>3</strong></em></p>
</td>
<td>
<p><em><strong>3</strong></em></p>
</td>
<td>
<p><em><strong>3</strong></em></p>
</td>
<td>
<p><em><strong>3</strong></em></p>
</td>
<td>
<p><em><strong>3</strong></em></p>
</td>
<td>
<p><em><strong>4</strong></em></p>
</td>
<td>
<p><em><strong>4</strong></em></p>
</td>
<td>
<p><em><strong>4</strong></em></p>
</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>
<p><em><strong>В</strong></em></p>
</td>
<td>
<p><em><strong>4</strong></em></p>
</td>
<td>
<p><em><strong>2</strong></em></p>
</td>
<td>
<p><em><strong>4</strong></em></p>
</td>
<td>
<p><em><strong>0</strong></em></p>
</td>
<td>
<p><em><strong>0</strong></em></p>
</td>
<td>
<p><em><strong>0</strong></em></p>
</td>
<td>
<p><em><strong>2</strong></em></p>
</td>
<td>
<p><em><strong>2</strong></em></p>
</td>
<td>
<p><em><strong>4</strong></em></p>
</td>
<td>
<p><em><strong>0</strong></em></p>
</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>
<p><em><strong>С</strong></em></p>
</td>
<td>
<p><em><strong>7</strong></em></p>
</td>
<td>
<p><em><strong>2</strong></em></p>
</td>
<td>
<p><em><strong>2</strong></em></p>
</td>
<td>
<p><em><strong>2</strong></em></p>
</td>
<td>
<p><em><strong>7</strong></em></p>
</td>
<td>
<p><em><strong>0</strong></em></p>
</td>
<td>
<p><em><strong>2</strong></em></p>
</td>
<td>
<p><em><strong>2</strong></em></p>
</td>
<td>
<p><em><strong>2</strong></em></p>
</td>
<td>
<p><em><strong>2</strong></em></p>
</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>
<p><em><strong>Свободно</strong></em></p>
</td>
<td>
<p><em><strong>10</strong></em></p>
</td>
<td>
<p><em><strong>3</strong></em></p>
</td>
<td>
<p><em><strong>1</strong></em></p>
</td>
<td>
<p><em><strong>5</strong></em></p>
</td>
<td>
<p><em><strong>0</strong></em></p>
</td>
<td>
<p><em><strong>7</strong></em></p>
</td>
<td>
<p><em><strong>3</strong></em></p>
</td>
<td>
<p><em><strong>2</strong></em></p>
</td>
<td>
<p><em><strong>0</strong></em></p>
</td>
<td>
<p><em><strong>4</strong></em></p>
</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<h2 style="page-break-before: always;"><strong>Нарушение условий Коффмана</strong></h2>
<ul>
<li><em><strong>взаимное исключение: каждый ресурс в данный момент времени или отдан ровно одному процессу, или доступен</strong></em></li>
<ul>
<li><em><strong>позволить разделять ресурс несколькими процессами</strong></em></li>
<li><em><strong>можно организовать спулер</strong></em></li>
<li><em><strong>Не всегда возможно</strong></em></li>
</ul>
<li><em><strong>условие удержания: процессы, владеющие ресурсом, могут запрашивать новые ресурсы</strong></em></li>
<ul>
<li><em><strong>запрашивать все необходимые ресурсы до начала работы</strong></em></li>
<li><em><strong>процесс или получает все необходимое для работы, что исключает взаимоблокировки или ожидает ресурсы, не блокируя другие процессы</strong></em></li>
<li><em><strong>предварительно не всегда известно, какие ресурсы будут требоваться</strong></em></li>
<li><em><strong>ресурсы используются не оптимально</strong></em></li>
</ul>
</ul>
<ul>
<li><em><strong>условие удержания (продолжение)</strong></em></li>
<ul>
<li><em><strong>Использовать двухфазовое блокирование</strong></em></li>
<li><em><strong>Если процессу требуется несколько ресурсов, он пытается их заблокировать (получить) по одному</strong></em></li>
<li><em><strong>Если получить все необходимые ресурсы не удалось, выполняется освобождение занятых ресурсов и попытка повторяется</strong></em></li>
<li><em><strong>Фактически подход требует аккуратного программирования</strong></em></li>
<li><em><strong>не обобщается на системы реального времени</strong></em></li>
<li><em><strong>Используется при построении БД, выражается в понятии транзакции -&ndash; неделимой последовательности действий с БД в т.ч. и над несколькими записями</strong></em></li>
<li><em><strong>Операции над набором семафоров помогают использовать такой подход</strong></em></li>
</ul>
</ul>
<ul>
<li><em><strong>условие отсутствия принудительной выгрузки: у процесса нельзя принудительно забрать ранее полученные им ресурсы</strong></em></li>
<ul>
<li><em><strong>Отбирать ресурсы у процесса</strong></em></li>
<li><em><strong>Это не всегда возможно</strong></em></li>
<li><em><strong>Часто требует ручного вмешательства</strong></em></li>
<li><em><strong>Процесс может потерять результаты работы</strong></em></li>
<li><em><strong>Возможна дискриминация отдельных процессов</strong></em></li>
</ul>
<li><em><strong>условие циклического ожидания:</strong></em> <em><strong>существование круговой последовательности параллельных процессов, каждый из которых для продолжения работы требует ресурса, удерживаемого следующим в данной последовательности процессом</strong></em></li>
</ul>
<ul>
<li><em><strong>условие циклического ожидания: </strong></em></li>
<ul>
<li><em><strong>разрешить процессу имеет право только на один ресурс в конкретный момент времени</strong></em></li>
<li><em><strong>Невозможно</strong></em></li>
<li><em><strong>Общая нумерация всех ресурсов</strong></em></li>
<li><em><strong>Процессы могут запрашивать столько ресурсов сколько захотят, но запросы должны быть сделаны в в порядке возрастания номеров ресурсов</strong></em></li>
<li><em><strong>В этом случае граф распределения ресурсов никогда не будет иметь циклов</strong></em></li>
<li><em><strong>не всегда возможно выполнить нумерацию ресурсов</strong></em></li>
<li><em><strong>Пример: упорядоченный список спин-блокировок в Windows 2000</strong></em></li>
</ul>
</ul>
<p align="center"><strong>Контрольные вопросы и задачи</strong></p>
<ul>
<li><em><strong>1)  Что такое тупиковое состояние? Приведите несколько примеров возникновения тупиковой ситуации.</strong></em></li>
<li><em><strong>2)  Что является причиной возникновения тупиков на ресурсах типа SR? Перечислите условия,при которых возникает тупик. </strong></em></li>
<li><em><strong>3)  Приведите пример графа повторно используемых ресурсов.Что позволяет сделать этамодель Холта? </strong></em></li>
<li><em><strong>4)  Приведите пример теоретико-множественного описания сети Петри. </strong></em></li>
<li><em><strong>5)  Что такое маркировка сети Петри? Что представляет собой пространство возможных состояний сети Петри? </strong></em></li>
<li><em><strong>6)  Приведите пример графического представления сети Петри.</strong></em></li>
<li><em><strong>7)  Что следует предпринять для реализации стратегии предотвращения тупиковых ситуаций? Какие реальные проблемы при этом возникают?</strong></em></li>
<li><em><strong>8)  Что представляет собой «обходтупика»? Приведите алгоритм банкира Дейк-стры. Почему на практике невозможно воспользоваться алгоритмом банкира для борьбы с тупиковыми ситуациями? </strong></em></li>
<li><em><strong>9)  Что такое «опасное состояние»? Приведите пример опасного состояния на модели состояний системы.</strong></em></li>
<li><em><strong>10) Опишите метод обнаружения тупика посредством редукции графа повторно используемых ресурсов</strong></em></li>
<li><em><strong>11) Опишите алгоритм обнаружения тупика по наличию замкнутой цепочки запросов. </strong></em></li>
</ul></p>
</BODY>
</HTML>