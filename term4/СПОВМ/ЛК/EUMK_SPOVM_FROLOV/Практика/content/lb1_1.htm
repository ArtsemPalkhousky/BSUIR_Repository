<!-- (C) 2011-2012 V.Prytkov, V. Suponev, A.Uvarov. BSUIR -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//RU">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1251">
<META HTTP-EQUIV="Content-Language" CONTENT="ru">
<title>Лабораторная работа №1. Процессы. </title>
<base target="_top">
</HEAD><BODY>
<p align="center"><strong>Лабораторная работа  №1. Процессы</strong></p>
<p align="center"><strong>Введение в Linux. Базовая работа с процессами под Windows и Linux</strong></p>
<p>Цель работы: ознакомиться с основами разработки ПО под Linux. Научиться создавать процессы под Unix и Windows, освоить базовые принципы
работы с ними.</p>
<p align="center"><strong>Теоретическая часть</strong></p>
<p><strong>Знакомство с Linux<br /></strong></p>
<p><strong>Введение</strong></p>
<p>Лабораторные занятия по курсу СПО ЭВМ предполагают решение каждой задачи в двух вариантах: под Linux и Windows. При этом будем считать, 
что студенты обладают базовыми навыками программирования под Windows, полученными при обучении на предшествующих курсах. Основные моменты, 
связанные с программированием под Unix-системы, будут рассмотрены ниже.</p>
<p>Для комфортной работы в среде Linux существует большое количество оконных менеджеров (KDE, Gnome, WindowMaker), интерактивных сред 
разработки (KDevelop, NetBeans, SlickEdit), текстовых редакторов (Kate, KWrite, OpenOffice Writer) и прочих графических средств, принцип 
работы которых более-менее привычен Windows-пользователю. Однако для понимания основ функционирования Linux и разработки приложений под 
Unix-подобные ОС необходимо иметь навыки работы с текстовой консолью и использования консольных приложений, таких как vim, gcc, gdb и др. 
Выполнение первого задания предполагает использование исключительно консольных инструментов. В дальнейшем студент волен выбрать наиболее 
подходящую для него среду разработки.</p>
<p>Ознакомление с разработкой приложений под Linux подразумевает освоение следующих операций:
<ul>
<li>работа с файловой системой;
<li>создание и редактирование текстовых файлов;
<li>компиляция и линковка программ;
<li>запуск исполняемых файлов;
<li>использование встроенных страниц справки (man).
</ul>
</p>
<p><strong>Работа с файловой системой</strong></p>
<p>Файловые системы, используемые в Linux,  организованы по древовидному принципу. В отличие от FAT и NTFS, здесь нет отдельных дисков, 
обозначаемых литерами. Файловая система имеет один общий корень, обозначаемый символом ‘/’, и иерархию каталогов, исходящую из него. Все 
дополнительные файловые системы, размещающиеся как на разделах жесткого диска, таки и на CD и DVD диска, флэш-накопителях, дискетах и т.д., 
встраиваются в общее дерево в виде подкаталогов. Процесс связывания внешней файловой системы и локального каталога называется монтированием
 (см. команду mount).</p>
<p>Существуют два основных способа адресации файла или директории: относительный и абсолютный. В первом случае файл адресуется относительно
 текущей директории. При абсолютной же адресации указывается полный путь к файлу от корня файловой системы: <br />
 <code>/home/somefile.txt</code> </p>
 <p>В данном случае файл somefile.txt находится в каталоге home, который, в свою очередь, находится в корневой директории. Абсолютный 
 адрес должен начинаться с символа ‘/’, ссылающегося на корневой каталог. При указании как абсолютного, так и относительного адресов 
 можно использовать метаобозначения ‘.’ (текущий каталог) и ‘..’ (родительский каталог). </p>
 <p>Для манипулирования файлами и директориями можно выделить следующие основные команды:
 <ul>
 <li><strong>pwd </strong>Получение абсолютного адреса текущей директории
 <li><strong>cd </strong>Смена текущей директории
 <li><strong>ls </strong>Получение списка файлов и каталогов в текущей директории
 <li><strong>cp </strong>Копирование файлов или каталогов
 <li><strong>mv </strong>Перемещение/переименование файлов или каталогов
 <li><strong>rm </strong>Удаление файлов
 <li><strong>mkdir </strong>Создание новой директории
 <li><strong>rmdir </strong>Удаление пустой директории
 <li><strong>cat </strong>Вывод на экран содержимого файла
 <li><strong>more (less) </strong>Страничный вывод содержимого файла
 <li><strong>tail </strong>Вывод на экран N последних строк файла
 <li><strong>chmod </strong>Смена прав доступа к файлу
 <li><strong>chown </strong>Смена владельца файла
 </ul>
Подробное описание этих и других команд можно получить в страницах встроенной помощи (man).</p>
<p><strong>Создание и редактирование текстовых файлов</strong></p>
<p>Одним из наиболее мощных консольных текстовых редакторов является ViM (Vi iMproved – улучшенная версия редактора Vi). Для его запуска 
наберите “vim” в командной строке. Если не было передано никакого имени файла в качестве параметра, по умолчанию создается новый файл.</p>
<p>Принципы работы с ViM отличаются от привычного подхода к редактированию файлов. Полное описание возможностей редактора занимает несколько
 сот man-страниц, здесь же обрисуем базовые его возможности, необходимые для работы.</p>
<p>ViM может находиться в одном из двух основных режимов работы: режим редактирования текста и режим ввода команд. Индикатором режима 
редактирования является слово “INSERT” в левом нижнем углу. Данный режим является привычным и трудностей не представляет. Режим ввода команд 
активируется нажатием клавиши Esc. После этого можно использовать основные команды для управления файлом. Команда ViM обычно представляет
 собой символ ‘:’, после которого следует обозначение команды и при необходимости ее параметры.</p>
<p>ViM насчитывает огромное количество команд, но сейчас нас будут интересовать команды выхода и сохранения файла:
<ul>
<li><strong>:q </strong>Выход из редактора, если файл не был модифицирован</li>
<li><strong>:wq </strong>Выход из редактора с сохранением файла</li>
<li><strong>:q! </strong>Выход из редактора без сохранения изменений</li>
<li><strong>:w </strong>Сохранение изменений в файле без выхода из редактора</li>
</ul>
Командам сохранения можно указывать имя файла в качестве параметра.</p>

<p><strong>Компиляция и линковка программ</strong></p>
<p>Предположим, вы уже написали тестовую программу при помощи редактора ViM. Процесс трансляции исходного кода в бинарный исполняемый 
файл состоит из двух фаз: компиляции и линковки. Обе эти операции выполняются с помощью компилятора gcc (g++ для C++). Пример компиляции 
исходного кода:<br />
<code>gcc –c somefile.o somefile.c</code>
</p>
<p>При этом из файла somefile.c будет создан объектный код somefile.o. Если производится компиляция нескольких исходных кодов в один 
объектный файл, то исходные файлы перечисляются через пробел.</p>
<p>Скомпилированные объектные коды можно теперь транслировать в исполняемый формат. Для этого используется тот же gcc, но с ключом –o:<br />
<code>gcc –o somefile somefile.o</code>
</p>
<p>В итоге на выходе получится исполняемый файл с именем somefile. Как и в предыдущем случае, в конце можно указывать список из линкуемых
 объектных файлов.</p>
<p>Стоит обратить внимание, что результирующий файл был указан без расширения. В отличие от DOS/Windows, исполняемым является файл не 
со специфическим расширением (.exe), а с установленным соответствующим битом в правах доступа. В среде Linux-разработчиков принято, что
 исполняемые файлы расширения, как правило, не имеют. Это не означает, что все файлы без расширения – исполняемые. Многие конфигурационные
 файлы, к примеру, также не имеют расширения. Просто следует усвоить, что в Linux расширение файла не является существенным его атрибутом.</p>
<p>Стоит отметить, что возможна и сокращенная форма трансляции: <code>gcc somefile.c</code></p>
<p>При этом будут выполнены фазы компиляции и линковки, и на выходе получится исполняемый файл с именем a.out. Это один из немногих случаев
 нарушения правила об отсутствии расширения у исполняемых файлов. При кажущейся легкости и простоте использования данный способ крайне не 
 рекомендуется, так как дальнейшее использование такого “имени по умолчанию” может вызвать путаницу. Подобный прием может быть применен на
 этапе первоначальной отладки приложения, однако считается весьма дурным тоном программирования.</p>
<p><strong>Запуск исполняемых файлов</strong></p>
<p>После компиляции и линковки исходного кода в текущей директории окажется исполняемый бинарный файл. Вопреки шаблонному представлению, 
запустить его, просто набрав его имя в командной строке, не получится. Для запуска надо указать абсолютный или относительный адрес файла. 
Обычно используется адресация относительно текущего каталога:<br />
<code>./somefile</code>
</p>
<p><strong>Использование встроенных страниц справки</strong></p>
<p>В Linux существует встроенная система справки, доступная из консоли. В ней содержатся страницы руководства по консольным командам, 
функциям языков программирования, установленным в системе, основным программам и т.д. Как правило, любая программа, предполагающая работу с
 консолью, инсталлирует свои страницы помощи в данном формате.</p>
<p>Получить доступ к справочной системе можно при помощи команды man. В качестве параметра man требует ключевое слово, для которого 
запрашивается справка. Например:<br />
<code>man gdb</code>
</p>
<p>Данный запрос выведет на экран страницы помощи по консольному отладчику gdb. Многие man-руководства насчитывают сотни страниц с подробным
 описанием всех возможностей конкретных программ. Выход из справочной системы осуществляется посредством клавиши ‘q’.</p> 
<p>Однако бывают случаи, когда несколько разделов справки именуются одинаковым образом. К примеру, time – это и команда shell, и библиотечная
 функция языка Си. Для разрешения подобных конфликтов страницы man разделены на несколько разделов. В самих страницах можно встретить ссылки
 на другие команды и функции. Как правило, они оформляются в виде команда(раздел). Например, ссылка на команду time будет выглядеть так: 
 time(1). Если подобная двусмысленность имеет место, необходимо явно указать команде man раздел, в котором следует искать справочную 
 информацию:<br />
 <code>man 1 time</code>
</p>
<p>Т.е. первым параметром идет номер раздела, вторым – команда, для которой запрашивается помощь.</p>
<p>Страницы помощи в Linux обычно разбиваются на следующие разделы:
<ul>
<li><strong>Команды</strong> - Команды, которые могут быть запущены пользователем из оболочки</li>
<li><strong>Системные вызовы</strong> - Функции, исполняемые ядром</li>
<li><strong>Библиотечные вызовы</strong> - Большинство функций libc, таких, как qsort(3)</li>
<li><strong>Специальные файлы</strong> - Файлы, находящиеся в /dev</li>
<li><strong>Форматы файлов</strong> - Формат файла /etc/passwd и подобных ему легко читаемых файлов</li>
<li><strong>Игры</strong></li>
<li><strong>Макропакеты</strong> - Описание стандартной "раскладки" файловой системы, сетевых протоколов, кодов ASCII и других таблиц, 
данная страница документации и др.</li>
<li><strong>Команды управления системой</strong> - Команды типа mount(8), которые может использовать только root</li>
<li><strong>Процедуры ядра</strong> - Это устаревший раздел руководства. В свое время появилась идея держать документацию о ядре Linux в 
этом разделе. Однако, в то время документация о ядре была неполной и, по большей части, устаревшей. Существуют значительно более удобные
 источники информации для разработчиков ядра</li>
</ul>
</p>
<p><strong>Понятие процессов</strong></p>
<p>Процесс – одно из средств организации параллельных вычислений в современных ОС. Под процессом обычно понимают выполняющуюся программу и 
все ее элементы, включая адресное пространство, глобальные переменные, регистры, стек, открытые файлы и т.д.</p>
<p>Параллельные вычисления подразумевают одновременное исполнение нескольких процессов. Для однопроцессорных систем характерно применение
 т.н. псевдопараллельного режима, когда операционная система последовательно выделяет для каждого процессора определенное количество квантов
 процессорного времени, тем самым достигая иллюзии одновременной работы процессов.</p> 
<p>Для управления процессом, обеспечения синхронизации и взаимодействия нескольких параллельных процессов необходимо знать, как 
идентифицируется процесс в операционной системе. Идентификатором процесса служит уникальный номер (pid), определяющий его положение в 
системных таблицах.</p>
<p>Ниже рассмотрим процедуры создания и завершения новых процессов в Linux и Windows.</p>
<p><strong>Linux</strong></p>
<p>Новый процесс в Linux создается при помощи системного вызова fork(). Данный вызов создает дубликат процесса-родителя; выполнение 
процесса-потомка начинается со следующего после fork() оператора. Функция fork() возвращает родительскому процессу идентификатор созданного
 процесса-потомка, самому потомку – 0, а в случае ошибки – -1.</p>
<p>Классический пример создания процесса:</p>
<p><code><pre>
pid = fork();
switch( pid ) {
    -1     : ... ; // Ошибка
     0     : ... ; // Дочерний процесс
    default: ... ; // Родительский процесс
}
</pre></code></p>
<p>Распараллеливание вычислений при помощи дублирования текущего процесса не всегда эффективно с точки зрения программирования. Для 
запуска произвольных исполняемых файлов существует семейство функций exec. Все функции этого семейства (execv, execve, execl и т.д.) 
замещают текущий процесс новым образом, загружаемым из указанного исполняемого файла. По этой причине exec-функции не возвращают никакого
 значения, кроме случая, когда при их запуске происходит ошибка.</p>
<p>Наиболее распространенная схема создания нового процесса в Unix – совместное использование fork() и exec-функций. При этом создаваемый
 fork() дубликат родительского процесса замещается новым модулем.</p>
<p>При выборе конкретной функции надо иметь в виду следующие моменты:
<ul>
<li>Функции, содержащие в названии литеру ‘p’ (execvp и execlp), принимают в качестве аргумента имя запускаемого файла и ищут его в 
прописанном в окружении процесса пути. Функции без этой литеры нуждаются в указании полного пути к исполняемому файлу.</li>
<li>Функции с литерой ‘v’ (execv, execve и execvp) принимают список аргументов как null-терминированный список указателей на строки. 
Функции с литерой ‘l’ (execl, execle и execlp) принимают этот список, используя механизм указания произвольного числа переменных языка C.</li>
<li>Функции с литерой ‘e’ (execve и execle) принимают дополнительный аргумент, массив переменных окружения. Он представляет собой 
null-терминированный массив указателей на строки, каждая из которых должна представлять собой запись вида “VARIABLE=value”.</li>
</ul>
</p>
<p>Процесс завершается по окончании работы основного потока (main) либо после системного вызова exit().</p>
<p>Получить идентификатор текущего процесса можно при помощи функции getpid(). Идентификатор родительского процесса возвращается 
функцией getppid().</p>
<p>Родительский процесс должен явно дождаться завершения дочернего при помощи функций wait() или waitpid().Если родитель завершился, не 
 вызвав wait(), новым родителем всем его потомкам назначается init, корневой процесс ОС Unix. Init автоматически производит очистку 
 дочерних процессов. Однако, если дочерний процесс завершен, и родитель не вызвал какую-либо из вышеназванных функций, Init не может быть
 назначен родителем уже завершенного процесса, и дочерний становится т.н. «зомби»-процессом. Несмотря на то, что он ничего не 
 выполняет, он явно присутствует в системе.  Поэтому хорошим стилем программирования считается контролировать жизненный цикл дочерних
 процессов из родительского, не перекладывая эту задачу на систему.</p>
<p><strong>Windows</strong></p>
<p>В Windows создание процессов любого типа реализуется при помощи системной функции CreateProcess(). Функция принимает следующие аргументы:
<ul>
<li>pszApplicationName – имя исполняемого файла, который должен быть запущен;</li>
<li>pszCommandLine – командная строка, передаваемая новому процессу;</li>
<li>psaProcess – атрибуты защиты процесса;</li>
<li>psaThread – атрибуты защиты потока;</li>
<li>bInheritHandles – признак наследования дескрипторов;</li>
<li>fdwCreate – флаг, определяющий тип создаваемого процесса;</li>
<li>pvEnvironment – указатель на блок памяти, содержащий переменные окружения;</li>
<li>pszCurDir – рабочий каталог нового процесса;</li>
<li>psiStartupInfo – параметры окна нового процесса. Элементы этой структуры должны быть обнулены перед вызовом CreateProcess(), если им 
не присваивается специальное значение. Поле cb должно быть проинициализировано размером структуры в байтах.</li>
<li>ppiProcInfo – указатель на структуру PROCESS_INFORMATION, в которую будут записаны идентификаторы и дескрипторы нового процесса и 
основного его потока.</li>
</ul></p> 
<p>Существует четыре способа явно завершить процесс:
<ul>
<li>входная функция первичного потока возвращает управление;</li>
<li>один из потоков процесса вызывает ExitProcess();</li>
<li>любой поток любого процесса вызывает TerminateProcess();</li>
<li>все потоки процесса завершаются.</li>
</ul></p>
<p>В Windows нет понятия «зомби»-процесса. Однако в ряде случаев необходимо дождаться окончания выполнения процесса. Делается это при
 помощи функции WaitForSingleObject() либо же WaitForMultipleObjects().</p>
<p align="center"><strong>Задание</strong></p>
<p>Разработать консольное приложение, в котором базовый процесс порождает дочерний. Для каждого процесса предусмотрена своя область 
вывода, в которой он выводит текущее системное время. Работа выполняется в двух вариантах: под Linux и Windows. Под Linux использовать 
библиотеку ncurses.</p>
</BODY>
</HTML>