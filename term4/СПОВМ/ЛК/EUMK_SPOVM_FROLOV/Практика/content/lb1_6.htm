<!-- (C) 2011-2012 V.Prytkov, V. Suponev, A.Uvarov. BSUIR -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//RU">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1251">
<META HTTP-EQUIV="Content-Language" CONTENT="ru">
<title>Лабораторная работа №6. Менеджер памяти. </title>
<base target="_top">
</HEAD><BODY>
<p align="center"><strong>Лабораторная работа  №6. Менеджер памяти</strong></p>
<p align="center"><strong>Эмуляция простого менеджера памяти под заданную ОС (Windows либо Linux)</strong></p>
<p>Цель работы: ознакомиться с основами функционирования менеджеров памяти, реализовать собственный алгоритм учета памяти.</p>
<p align="center"><strong>Теоретическая часть</strong></p>
<p>При программировании самых различных приложений часто возникает необходимость динамически выделить участок памяти заданного размера, 
получить указатель на него, изменить размер этого участка, освободить выделенную память и т.д. Для программиста эти операции сводятся к 
вызову функций malloc(), realloc(), free(), использованию операторов new и delete и т.д. Непосредственным же манипулированием участками 
памяти занимается так называемый менеджер памяти.</p>
<p>В стандартных библиотеках С/С++ менеджер памяти представляет собой реализацию перечисленных выше функций и операторов. Однако часто 
возникает ситуация, когда стандартного функционала менеджера памяти недостаточно. К примеру, может потребоваться индексирование выделенных
 участков памяти, их дефрагментация, сборка мусора и т.д. В этих случаях наиболее логично написание собственного менеджера памяти.</p>
<p>В отличие от предыдущих лабораторных работ, которые сводились к изучению соответствующих библиотечных функций, данная работа посвящена 
в первую очередь архитектурному  проектированию собственной системы, т.е. собственной реализации стандартных функций.</p> 
<p>В качестве составных компонент менеджера памяти традиционно выделяют следующее:
<ul>
<li>управляющие структуры, описывающие размещение выделенных областей памяти;</li>
<li>набор функций, позволяющих оперировать выделением памяти (аналог malloc(), free() и т.д.);</li>
<li>дополнительные внутренние функции и компоненты, осуществляющие сервисные операции (автоматическая сборка мусора, например).</li>
</ul></p>
<p>Для выполнения задания необходимо рассмотреть следующие понятия:
<ul>
<li>Сборка мусора – автоматическое освобождение менеджером памяти неиспользуемых участков памяти принудительно или в фоновом режиме. 
Подразумевает отсутствие функции free() (оператора delete) или совместную с ней работу. Как правило, неиспользуемым считается участок 
памяти, на который отсутствуют ссылки.</li>
<li>Дефрагментация – процесс упорядочивания выделенных областей памяти и устранение пустого неиспользуемого пространства между ними. 
Фрагментация оперативной памяти возможна при последовательном выделении и освобождении памяти. Это означает, что теоретически возможна 
ситуация, когда общего объема свободной памяти достаточно для выделения, однако вся она сосредоточена в небольших пустых областях между 
выделенными участками. В такой ситуации невозможно выделить непрерывный участок памяти требуемого размера, несмотря на то, что в принципе 
нужный объем памяти помечен как свободный.</li>
<li>Свопинг – процесс сброса на жесткий диск участков памяти, используемых менее всего, для их освобождения под другие нужды. Это 
происходит, когда общего объема памяти становится недостаточно, и ведет к замедлению работы программы. При последующем обращении к 
освобожденному таким образом участку менеджер памяти должен считать его с жесткого диска и вновь выделить для него память нужного объема.</li>
</ul></p>
<p align="center"><strong>Задание</strong></p>
<p>Разработать собственный менеджер памяти, реализующий аналоги функций malloc() и free(). Архитектура менеджера и детали реализации 
остаются на усмотрение студента. Предусмотреть дополнительную функциональность в одном из следующих вариантов:
<ul>
<li>динамическое изменение размеров выделенной области (realloc());</li>
<li>автоматическая сборка мусора;</li>
<li>дефрагментация;</li>
<li>механизм свопинга при превышении максимально доступной памяти.</li>
</ul></p>
<p>Задание выполняется в одном варианте под любую операционную систему на выбор студента.</p>
</BODY>
</HTML>

